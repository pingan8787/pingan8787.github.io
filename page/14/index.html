<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/14/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-97-【JavaScript】ES5和ES6正则表达式总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/05/97-%E3%80%90JavaScript%E3%80%91ES5%E5%92%8CES6%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2018-10-05T14:45:38.000Z" itemprop="datePublished">2018-10-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/05/97-%E3%80%90JavaScript%E3%80%91ES5%E5%92%8CES6%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93/">97-【JavaScript】ES5和ES6正则表达式总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#x69;&#110;&#x67;&#x61;&#x6e;&#56;&#55;&#x38;&#55;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;">&#x70;&#x69;&#110;&#x67;&#x61;&#x6e;&#56;&#55;&#x38;&#55;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章</td>
<td><a target="_blank" rel="noopener" href="https://0x9.me/KMrv3">https://0x9.me/KMrv3</a></td>
</tr>
</tbody></table>
<hr>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><strong>正则表达式</strong>（regular expression）是一种表达文本模式（即字符串结构）的方法。</p>
<p>创建方式有<strong>两种方式</strong>：</p>
<p>一种是使用字面量，以<strong>斜杠表示开始和结束</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/</span></span><br></pre></td></tr></table></figure>

<p>另一种是使用RegExp构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>它们的主要区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p>
<h2 id="2-实例属性"><a href="#2-实例属性" class="headerlink" title="2.实例属性"></a>2.实例属性</h2><ul>
<li><p><strong>i</strong> :忽略大小写</p>
</li>
<li><p><strong>m</strong> :多行模式</p>
</li>
<li><p><strong>g</strong> :全局搜索</p>
</li>
</ul>
<h2 id="3-实例方法"><a href="#3-实例方法" class="headerlink" title="3.实例方法"></a>3.实例方法</h2><h3 id="3-1-RegExp-prototype-test"><a href="#3-1-RegExp-prototype-test" class="headerlink" title="3.1 RegExp.prototype.test()"></a>3.1 RegExp.prototype.test()</h3><p>正则实例对象的<code>test方法</code>返回一个布尔值，表示当前模式<strong>是否能匹配</strong>参数字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/小智/.test(<span class="string">&#x27;小智 终身学习执行者&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>reg.exec(str)</code> 返回匹配结果数组，不匹配则返回<code>null</code>，每执行一次<code>exec</code>就向后匹配一次</p>
<h3 id="3-2-RegExp-prototype-exec"><a href="#3-2-RegExp-prototype-exec" class="headerlink" title="3.2 RegExp.prototype.exec()"></a>3.2 RegExp.prototype.exec()</h3><ul>
<li> <strong>reg.exec(str)</strong> 返回匹配结果数组，不匹配则返回<code>null</code>，每执行一次<code>exec</code>就向后匹配一次<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;<span class="keyword">var</span> r1 = <span class="regexp">/x/</span>;<span class="keyword">var</span> r2 = <span class="regexp">/y/</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;x&quot;]r2.exec(s) // null</span></span><br></pre></td></tr></table></figure></li>
<li>如果表达式里有括号()，称为组匹配，返回结果中，第一个是整体匹配结果，后面依次是每个括号匹配的结果<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/_(x)/</span>;</span><br><span class="line"></span><br><span class="line">r.exec(s) <span class="comment">// [&quot;_x&quot;, &quot;x&quot;]</span></span><br></pre></td></tr></table></figure>
<code>exec</code>方法的返回数组还包含以下两个属性：</li>
<li>*input**：整个原字符串。</li>
</ul>
<p><strong>index</strong>：整个模式匹配成功的开始位置（从0开始计数）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a(b+)a/</span>;</span><br><span class="line"><span class="keyword">var</span> arr = r.exec(<span class="string">&#x27;_abbba_aba_&#x27;</span>);</span><br><span class="line"></span><br><span class="line">arr <span class="comment">// [&quot;abbba&quot;, &quot;bbb&quot;]</span></span><br><span class="line"></span><br><span class="line">arr.index <span class="comment">// 1arr.input // &quot;_abbba_aba_&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果表达式中有g选项进行全局搜索，则可以多次使用 exec，下次的匹配从上次的结果后开始<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;<span class="keyword">var</span> str = <span class="string">&#x27;abc_abc_abc&#x27;</span><span class="keyword">var</span> r1 = reg.exec(str);</span><br><span class="line">r1 <span class="comment">// [&quot;a&quot;]r1.index // 0reg.lastIndex // 1var r2 = reg.exec(str);</span></span><br><span class="line">r2 <span class="comment">// [&quot;a&quot;]r2.index // 4reg.lastIndex // 5var r3 = reg.exec(str);</span></span><br><span class="line">r3 <span class="comment">// [&quot;a&quot;]r3.index // 8reg.lastIndex // 9var r4 = reg.exec(str);</span></span><br><span class="line">r4 <span class="comment">// nullreg.lastIndex // 0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-字符串的实例方法"><a href="#4-字符串的实例方法" class="headerlink" title="4.字符串的实例方法"></a>4.字符串的实例方法</h2><h3 id="4-1-str-match-reg"><a href="#4-1-str-match-reg" class="headerlink" title="4.1 str.match(reg)"></a>4.1 str.match(reg)</h3><p>与 <code>reg.exec</code>相似，但是，如果使用<code>g</code>选项，则str.match`一次性返回所有结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;abba&#x27;</span>;<span class="keyword">var</span> r = <span class="regexp">/a/g</span>;</span><br><span class="line"></span><br><span class="line">s.match(r) <span class="comment">// [&quot;a&quot;, &quot;a&quot;]r.exec(s) // [&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-str-search-reg"><a href="#4-2-str-search-reg" class="headerlink" title="4.2 str.search(reg)"></a>4.2 str.search(reg)</h3><p>返回匹配成功的第一个位置,如果没有任何匹配，则返回-1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;_x_x&#x27;</span>.search(<span class="regexp">/x/</span>)<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-str-replace-reg-newstr"><a href="#4-3-str-replace-reg-newstr" class="headerlink" title="4.3 str.replace(reg,newstr)"></a>4.3 str.replace(reg,newstr)</h3><p>用第一个参数<code>reg</code>去匹配，用第二个参数<code>newstr</code> 去替换，正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;aaa&#x27;</span>.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)<span class="comment">// &quot;baa&quot;</span></span><br><span class="line"><span class="string">&#x27;aaa&#x27;</span>.replace(<span class="regexp">/a/</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// &quot;baa&quot;</span></span><br><span class="line"><span class="string">&#x27;aaa&#x27;</span>.replace(<span class="regexp">/a/g</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// &quot;bbb&quot; </span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-str-split-reg-maxLength"><a href="#4-4-str-split-reg-maxLength" class="headerlink" title="4.4 str.split(reg[,maxLength])"></a>4.4 str.split(reg[,maxLength])</h3><p>用匹配的模式切割，第二个参数是限制返回结果的最大数量</p>
<h2 id="5-匹配规则"><a href="#5-匹配规则" class="headerlink" title="5. 匹配规则"></a>5. 匹配规则</h2><h3 id="5-1-字面量字符和元字符"><a href="#5-1-字面量字符和元字符" class="headerlink" title="5.1 字面量字符和元字符"></a>5.1 字面量字符和元字符</h3><p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“<strong>字面量字符</strong>”（literal characters）。<br>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“<strong>元字符</strong>”（metacharacters），主要有以下几个。</p>
<ul>
<li>(1) 点字符（<code>.</code>）</li>
</ul>
<p>点字符（.）匹配除回车（r）、换行(n) 、行分隔符（u2028）和段分隔符（u2029）以外的所有字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/c.t/</span><br></pre></td></tr></table></figure>
<p>上面代码中，c.t匹配c和t之间包含任意一个字符的情况，只要这三个字符在同一行，比如cat、c2t、c-t等等，但是不匹配coot。</p>
<ul>
<li>(2)位置字符</li>
</ul>
<p><strong>^</strong> 表示字符串的开始位置</p>
<p><strong>$</strong> 表示字符串的结束位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test必须出现在开始位置/</span></span><br><span class="line">^test/.test(<span class="string">&#x27;test123&#x27;</span>)   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test必须出现在结束位置</span></span><br><span class="line">/test$/.test(<span class="string">&#x27;new test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从开始位置到结束位置只有</span></span><br><span class="line">test/^test$/.test(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">/^test$/.test(<span class="string">&#x27;test test&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>(3)选择符（|）</li>
</ul>
<p>竖线符号（<code>|</code>）在正则表达式中表示“<code>或关系</code>”（OR），即cat|dog表示匹配cat或dog。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">11</span>|<span class="number">22</span>/.test(<span class="string">&#x27;911&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式指定必须匹配11或22。</p>
<h3 id="5-2-转义符"><a href="#5-2-转义符" class="headerlink" title="5.2 转义符"></a>5.2 转义符</h3><p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配+，就要写成+。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">1</span>+<span class="number">1</span>/.test(<span class="string">&#x27;1+1&#x27;</span>)<span class="comment">// false/1\+1/.test(&#x27;1+1&#x27;)// true</span></span><br></pre></td></tr></table></figure>
<p>正则表达式中，需要反斜杠转义的，一共有12个字符<code>：^、.、[、$、(、)、|、*、+、?、&#123;</code>和。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;1\+1&#x27;</span>)).test(<span class="string">&#x27;1+1&#x27;</span>)<span class="comment">// false</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;1\\+1&#x27;</span>)).test(<span class="string">&#x27;1+1&#x27;</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-字符类"><a href="#5-3-字符类" class="headerlink" title="5.3 字符类"></a>5.3 字符类</h3><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[abc]/.test(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/[abc]/.test(<span class="string">&#x27;apple&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>有两个字符在字符类中有特殊含义。</p>
<ul>
<li><p>（1）脱字符（^）<br>如果方括号内的第一个字符是[^xyz]表示除了x、y、z之外都可以匹配：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[^abc]/.test(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/[^abc]/.test(<span class="string">&#x27;bbc&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Please yes\nmake my day!&#x27;</span>;</span><br><span class="line">s.match(<span class="regexp">/yes.*day/</span>) <span class="comment">// nulls.match(/yes[^]*day/) // [ &#x27;yes\nmake my day&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串s含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败；第二个正则表达式[^]包含一切字符，所以匹配成功。</p>
</li>
<li><p>（2）连字符（-）</p>
</li>
</ul>
<p>某些情况下，对于连续序列的字符，连字符（<code>-</code>）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[<code>a-c</code>]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/a-z/.test(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/.test(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// true </span></span><br></pre></td></tr></table></figure>
<p>以下都是合法的字符类简写形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>-<span class="number">9.</span>,]</span><br><span class="line">[<span class="number">0</span>-9a-fA-F]</span><br><span class="line">[a-zA-Z0-<span class="number">9</span>-]</span><br><span class="line">[<span class="number">1</span>-<span class="number">31</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码中最后一个字符类[1-31]，不代表1到31，只代表1到3。</p>
<p>另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是[A-z]，表面上它是选中从大写的A到小写的z之间52个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[A-z]/.test(<span class="string">&#x27;\\&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于反斜杠（’’）的ASCII码在大写字母与小写字母之间，结果会被选中。</p>
<h3 id="5-4-预定义模式"><a href="#5-4-预定义模式" class="headerlink" title="5.4 预定义模式"></a>5.4 预定义模式</h3><p>预定义模式指的是某些常见模式的简写方式。</p>
<p><strong>d</strong> 匹配0-9之间的任一数字，相当于[0-9]。</p>
<p><strong>D</strong> 匹配所有0-9以外的字符，相当于[^0-9]。</p>
<p><strong>w</strong> 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。</p>
<p><strong>W</strong> 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。</p>
<p><strong>s</strong> 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。</p>
<p><strong>S</strong> 匹配非空格的字符，相当于[^ \t\r\n\v\f]。</p>
<p><strong>b</strong> 匹配词的边界。</p>
<p><strong>B</strong> 匹配非词边界，即在词的内部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \s 的例子</span></span><br><span class="line">/\s\w*<span class="regexp">/.exec(&#x27;hello world&#x27;) /</span><span class="regexp">/ [&quot; world&quot;]</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ \b 的例子</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>\bworld/.test(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/\bworld/.test(<span class="string">&#x27;hello-world&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/\bworld/.test(<span class="string">&#x27;helloworld&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// \B 的例子</span></span><br><span class="line">/\Bworld/.test(<span class="string">&#x27;hello-world&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/\Bworld/.test(<span class="string">&#x27;helloworld&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>通常，正则表达式遇到换行符（n）就会停止匹配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/.*/</span>.exec(html)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// &quot;&lt;b&gt;Hello&lt;/b&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串html包含一个换行符，结果点字符（<code>.</code>）不匹配换行符，导致匹配结果可能不符合原意。这时使用s字符类，就能包括换行符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/[\S\s]*/</span>.exec(html)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，[Ss]指代一切字符。</p>
<h3 id="5-5-重复类"><a href="#5-5-重复类" class="headerlink" title="5.5 重复类"></a>5.5 重复类</h3><p>模式的精确匹配次数，使用大括号（<code>&#123;&#125;</code>）表示。<code>&#123;n</code>}表示恰好重复n次，<code>&#123;n,&#125;</code>表示至少重复n次，<code>&#123;n,m&#125;</code>表示重复不少于n次，不多于m次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/lo&#123;<span class="number">2</span>&#125;k/.test(<span class="string">&#x27;look&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/lo&#123;<span class="number">2</span>,<span class="number">5</span>&#125;k/.test(<span class="string">&#x27;looook&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个模式指定o连续出现2次，第二个模式指定o连续出现2次到5次之间。</p>
<h3 id="5-6-量词符"><a href="#5-6-量词符" class="headerlink" title="5.6 量词符"></a>5.6 量词符</h3><p><code>*. ?</code> 问号表示某个模式出现0次或1次，等同于{0, 1}。<br><code>*. *</code> 星号表示某个模式出现0次或多次，等同于{0,}。<br><code>*. +</code> 加号表示某个模式出现1次或多次，等同于{1,}。</p>
<h3 id="5-7-贪婪模式"><a href="#5-7-贪婪模式" class="headerlink" title="5.7 贪婪模式"></a>5.7 贪婪模式</h3><p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">s.match(<span class="regexp">/a+/</span>) <span class="comment">// [&quot;aaa&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，模式是<code>/a+/</code>，表示匹配1个a或多个a，那么到底会匹配几个a呢？因为默认是贪婪模式，会一直匹配到字符a不出现为止，所以匹配结果是3个a。</p>
<p>如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">s.match(<span class="regexp">/a+?/</span>) <span class="comment">// [&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>
<p>除了非贪婪模式的加号，还有非贪婪模式的星号（<code>*</code>）和非贪婪模式的问号（<code>?</code>）</p>
<p><code>+?</code>：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</p>
<p><code>*?</code>：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</p>
<p><code>??</code>：表格某个模式出现0次或1次，匹配时采用非贪婪模式。</p>
<h3 id="5-8-组匹配"><a href="#5-8-组匹配" class="headerlink" title="5.8 组匹配"></a>5.8 组匹配</h3><ul>
<li>（1）概述</li>
</ul>
<p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/fred+<span class="regexp">/.test(&#x27;fredd&#x27;) /</span><span class="regexp">/ true</span></span><br><span class="line"><span class="regexp">/</span>(fred)+<span class="regexp">/.test(&#x27;fredfred&#x27;) /</span><span class="regexp">/ true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个模式没有括号，结果<code>+</code>只表示重复字母d，第二个模式有括号，结果<code>+</code>就表示匹配fred这个词。</p>
<p>下面是另外一个分组捕获的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abcabc&#x27;</span>.match(<span class="regexp">/(.)b(.)/</span>);</span><br><span class="line">m<span class="comment">// [&#x27;abc&#x27;, &#x27;a&#x27;, &#x27;c&#x27;]   </span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式<code>/(.)b(.)/</code>一共使用两个括号，第一个括号捕获a，第二个括号捕获c。</p>
<p>注意，使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abcabc&#x27;</span>.match(<span class="regexp">/(.)b(.)/g</span>);</span><br><span class="line">m <span class="comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>正则表达式内部，还可以用n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(.)b(.)\1b\<span class="number">2</span>/.test(<span class="string">&quot;abcabc&quot;</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，1表示第一个括号匹配的内容（即a），2表示第二个括号匹配的内容（即c）。</p>
<ul>
<li>（2）非捕获组</li>
</ul>
<p><code>(?:x)</code>称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</p>
<p>非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成<code>/(foo)&#123;1, 2&#125;/</code>，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为<code>/(?:foo)&#123;1, 2&#125;/</code>，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abc&#x27;</span>.match(<span class="regexp">/(?:.)b(.)/</span>);</span><br><span class="line">m <span class="comment">// [&quot;abc&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。</p>
<ul>
<li>（3）先行断言</li>
</ul>
<p><code>x(?=y)</code>称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成<code>/d+(?=%)/</code>。</p>
<p>“先行断言”中，括号里的部分是不会返回的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abc&#x27;</span>.match(<span class="regexp">/b(?=c)/</span>);</span><br><span class="line">m <span class="comment">// [&quot;b&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面的代码使用了先行断言，b在c前面所以被匹配，但是括号对应的c不会被返回。</p>
<ul>
<li>（4）先行否定断言</li>
</ul>
<p><code>x(?!y)</code>称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成<code>/d+(?!%)/</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?!\.)/.exec(<span class="string">&#x27;3.14&#x27;</span>)<span class="comment">// [&quot;14&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是14。</p>
<h2 id="6-实战"><a href="#6-实战" class="headerlink" title="6. 实战"></a>6. 实战</h2><h3 id="6-1-消除字符串首尾两端的空格"><a href="#6-1-消除字符串首尾两端的空格" class="headerlink" title="6.1 消除字符串首尾两端的空格"></a>6.1 消除字符串首尾两端的空格</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;  #id div.class  &#x27;</span>;</span><br><span class="line">str.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>)   <span class="comment">// &quot;#id div.class&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-验证手机号码"><a href="#6-2-验证手机号码" class="headerlink" title="6.2 验证手机号码"></a>6.2 验证手机号码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/1[24578]\d&#123;9&#125;/</span>;reg.test(<span class="string">&#x27;154554568997&#x27;</span>); <span class="comment">//truereg.test(&#x27;234554568997&#x27;); //false</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3-把手机号码替换成"><a href="#6-3-把手机号码替换成" class="headerlink" title="6.3 把手机号码替换成 *"></a>6.3 把手机号码替换成 *</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/1[24578]\d&#123;9&#125;/</span>;<span class="keyword">var</span> str = <span class="string">&#x27;姓名：张三 手机：18210999999 性别：男&#x27;</span>;</span><br><span class="line"></span><br><span class="line">str.replace(reg, <span class="string">&#x27;***&#x27;</span>) <span class="comment">//&quot;姓名：张三 手机：*** 性别：男&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-4-匹配网页标签"><a href="#6-4-匹配网页标签" class="headerlink" title="6.4 匹配网页标签"></a>6.4 匹配网页标签</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strHtlm = <span class="string">&#x27;小智小智&lt;div&gt;222222@.qq.com&lt;/div&gt;小智小智&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/&lt;(.+)&gt;.+&lt;\/\1&gt;/</span>;</span><br><span class="line"></span><br><span class="line">strHtlm.match(reg); <span class="comment">// [&quot;&lt;div&gt;222222@.qq.com&lt;/div&gt;&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="6-5-替换敏感字"><a href="#6-5-替换敏感字" class="headerlink" title="6.5 替换敏感字"></a>6.5 替换敏感字</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;中国共产党中国人民解放军中华人民共和国&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> r = str.replace(<span class="regexp">/中国|军/g</span>, <span class="function"><span class="params">input</span> =&gt;</span> &#123;   </span><br><span class="line">    <span class="keyword">let</span> t = <span class="string">&#x27;&#x27;</span>;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;input.length; i++) &#123;</span><br><span class="line">        t += <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    &#125;    <span class="keyword">return</span> t;</span><br><span class="line">&#125;) </span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//**共产党**人民解放*中华人民共和国 </span></span><br></pre></td></tr></table></figure>

<h3 id="6-6-千位分隔符"><a href="#6-6-千位分隔符" class="headerlink" title="6.6 千位分隔符"></a>6.6 千位分隔符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;100002003232322&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> r = str.replace(<span class="regexp">/(\d)(?=(?:\d&#123;3&#125;)+$)/g</span>, <span class="string">&#x27;$1,&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//100,002,003,232,322</span></span><br></pre></td></tr></table></figure>
<p>原文链接  <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016593077">https://segmentfault.com/a/1190000016593077</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/10/05/97-%E3%80%90JavaScript%E3%80%91ES5%E5%92%8CES6%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93/" data-id="ckts3ejwg00bm4d9ka8etb97l" data-title="97-【JavaScript】ES5和ES6正则表达式总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-96-【CSS】一个心跳动画的loading效果" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/30/96-%E3%80%90CSS%E3%80%91%E4%B8%80%E4%B8%AA%E5%BF%83%E8%B7%B3%E5%8A%A8%E7%94%BB%E7%9A%84loading%E6%95%88%E6%9E%9C/" class="article-date">
  <time class="dt-published" datetime="2018-09-30T06:21:35.000Z" itemprop="datePublished">2018-09-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/30/96-%E3%80%90CSS%E3%80%91%E4%B8%80%E4%B8%AA%E5%BF%83%E8%B7%B3%E5%8A%A8%E7%94%BB%E7%9A%84loading%E6%95%88%E6%9E%9C/">96-【CSS】一个心跳动画的loading效果</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#105;&#110;&#x67;&#97;&#x6e;&#x38;&#x37;&#x38;&#55;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#109;">&#x70;&#105;&#110;&#x67;&#97;&#x6e;&#x38;&#x37;&#x38;&#55;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章</td>
<td><a target="_blank" rel="noopener" href="https://0x9.me/KMrv3">https://0x9.me/KMrv3</a></td>
</tr>
</tbody></table>
<hr>
<h2 id="预览效果"><a href="#预览效果" class="headerlink" title="预览效果"></a>预览效果</h2><p><img src="http://images.pingan8787.com/20180930-01.gif" alt="效果图">  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>脉动 loading<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">            <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">            <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">#eee</span> <span class="number">70%</span>, pink);</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.loader</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">6em</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">6em</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">3em</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">0.8em</span> solid hotpink;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">            <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">            <span class="attribute">justify-content</span>: space-between;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation</span>: loader-animate <span class="number">1.5s</span> infinite ease-in-out;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.loader</span> &gt; <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: .<span class="number">5em</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: deeppink;</span></span><br><span class="line"><span class="css">            <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">05</span>) <span class="built_in">translateX</span>(-.<span class="number">5em</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">animation</span>: span-animate <span class="number">1.5s</span> infinite ease-in-out;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation-delay</span>: <span class="built_in">calc</span>(<span class="built_in">var</span>(--n) * .<span class="number">05s</span> );</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.loader</span> &gt; <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123; --n: <span class="number">1</span>; &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.loader</span> &gt; <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123; --n: <span class="number">2</span>; &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.loader</span> &gt; <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123; --n: <span class="number">3</span>; &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.loader</span> &gt; <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123; --n: <span class="number">4</span>; &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.loader</span> &gt; <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>) &#123; --n: <span class="number">5</span>; &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.loader</span> &gt; <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">6</span>) &#123; --n: <span class="number">6</span>; &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.loader</span> &gt; <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">7</span>) &#123; --n: <span class="number">7</span>; &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.loader</span> &gt; <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">8</span>) &#123; --n: <span class="number">8</span>; &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.loader</span> &gt; <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">9</span>) &#123; --n: <span class="number">9</span>; &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.loader</span> &gt; <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">10</span>) &#123; --n: <span class="number">10</span>; &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="keyword">@keyframes</span> loader-animate&#123;</span></span><br><span class="line"><span class="css">            <span class="number">45%</span>,<span class="number">55%</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.05</span>);</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="keyword">@keyframes</span> span-animate &#123;</span></span><br><span class="line"><span class="css">            <span class="number">0%</span>,<span class="number">100%</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.<span class="number">05</span>) <span class="built_in">translateX</span>(-.<span class="number">5em</span>);</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="number">15%</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1.2</span>) <span class="built_in">translateX</span>(<span class="number">1em</span>);</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="number">90%</span>,<span class="number">100%</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">background-color</span>: hotpink;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;loader&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考文章<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016543472">打开</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/30/96-%E3%80%90CSS%E3%80%91%E4%B8%80%E4%B8%AA%E5%BF%83%E8%B7%B3%E5%8A%A8%E7%94%BB%E7%9A%84loading%E6%95%88%E6%9E%9C/" data-id="ckts3ejwf00bj4d9kac6ydkru" data-title="96-【CSS】一个心跳动画的loading效果" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS%E5%8A%A8%E7%94%BB/" rel="tag">CSS动画</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-95-【JavaScript】原型继承的原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/28/95-%E3%80%90JavaScript%E3%80%91%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2018-09-28T14:28:58.000Z" itemprop="datePublished">2018-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/28/95-%E3%80%90JavaScript%E3%80%91%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8E%9F%E7%90%86/">95-【JavaScript】原型继承的原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#112;&#x69;&#x6e;&#103;&#x61;&#x6e;&#56;&#x37;&#x38;&#55;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;">&#112;&#x69;&#x6e;&#103;&#x61;&#x6e;&#56;&#x37;&#x38;&#55;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章</td>
<td><a target="_blank" rel="noopener" href="https://0x9.me/KMrv3">https://0x9.me/KMrv3</a></td>
</tr>
</tbody></table>
<hr>
<p>在JavaScript当中，对象A如果要继承对象B的属性和方法，那么只要将对象B放到对象A的原型链上即可。而某个对象的原型链，就是由该对象开始，通过<code>__proto__</code>属性连接起来的一串对象。<code>__proto__</code>属性是JavaScript对象中的内部属性，任何JavaScript对象，包括我们自己构建的对象，JavaScript的<code>built-in</code>对象，任何函数(在JavaScript当中，函数也是对象)都具有这个属性。如下图就是一个原型链的例子:<br><img src="http://images.pingan8787.com/20180927_01.png" alt="图片1"></p>
<p>上图中，A,B,C分别代表3个对象，<strong>蓝色箭头</strong>串接起来的所有对象就构成了<strong>对象C的原型链</strong>，其中C的<code>_proto__</code>属性指向B，B的<code>__proto__</code>属性指向A，A的<code>__proto__</code>属性可能指向更高层的对象，也可能指向<code>null</code>(表示<strong>A不继承任何对象的属性和方法</strong>)。</p>
<p>如果我们引用了C的某个属性或者方法，那么JavaScript就会顺着C的原型链进行查找，即首先查找对象C本身，看所引用的属性名或者方法名是否存在，如果存在就停止查找直接返回，如果不存在，就通过C的<code>__proto__</code>属性找到原型链中的B对象，继续在B对象中查找，如果B对象中找到所引用的属性名或者方法名，那么就停止查找直接返回，如果B对象中也不存在，就通过对象B的<code>__proto__</code>属性找到原型链中的A对象，继续重复上述查找过程，直到找到所引用的属性或者方法为止(同时也可能查找完对象C的整个原型链也没有找到所引用的属性或者方法，那么该属性或者方法就是<code>undefined</code>的)。</p>
<p>因此，只要能够成功的为某一个对象构造出我们需要的原型链，那么就能让该对象继承我们想要它继承的方法或者属性。而想要成功构造对象的原型链，就还必须理解<code>prototype</code>属性，JavaScript当中已经存在的原型链，以及当我们创建对象时，原型链被构造的过程。   </p>
<h3 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性</h3><p>prototype属性存在于JavaScript的任何函数当中，这个属性指向的对象就是所谓的原型对象，在构造原型链时需要原型对象。</p>
<h3 id="JavaScript当中已经存在的原型链"><a href="#JavaScript当中已经存在的原型链" class="headerlink" title="JavaScript当中已经存在的原型链"></a>JavaScript当中已经存在的原型链</h3><p>在JavaScript当中存在<code>Object</code>，<code>Function</code>，<code>Array</code>，<code>String</code>，<code>Boolean</code>，<code>Number</code>，<code>Date</code>，<code>Error</code>，<code>RegExp</code>这9个<strong>built-in函数</strong>，一个<code>built-in</code>的<code>Math对象</code>，通过这上述9个<code>built-in函数</code>我们可以创建相应的对象，同时，这9个<code>built-in函数</code>的<code>prototype</code>属性所指向的原型对象也是<code>built-in</code>的。下面的图示解释了这几个函数以及各自<code>prototype</code>属性所指向的原型对象之间的关系。<br><img src="http://images.pingan8787.com/20180927_02.png" alt="图片2"></p>
<p>（如果此图看不清，可点击 <a target="_blank" rel="noopener" href="http://images.pingan8787.com/20180927_02.png">此处下载</a>）</p>
<p>　　上面的图示中，<strong>黄色方框</strong>代表<code>built-in函数对象</code>，<strong>深绿色方框</strong>代表<code>built-in函数</code>的<code>prototype属性</code>指向的原型对象，名字都叫<code>xx prototype object</code>，<strong>浅绿色方框</strong>(即<strong>Math对象</strong>)代表<strong>普通对象</strong>，蓝色箭头连接非built-in函数对象(无论是普通对象如Math，还是原型对象)的<code>__proto__</code>属性，而土黄色箭头连接函数对象的<code>__proto__</code>属性。  </p>
<p>　　通过上图可以发现，所有<strong>built-in函数对象</strong>的原型链最终都指向<code>Function prototype object</code>，所有<strong>非函数对象的原型链</strong>最终都指向<code>Object prototype object</code>，并且<code>Function prototype object</code>的<code>__proto__</code>属性也指向<code>Object prototype object</code>，<code>Object prototype object</code>的<code>__proto__</code>属性指向为<code>null</code>。</p>
<p>因此，<code>Object prototype object</code>是所有原型链的顶端，通过原型链查找规则可知，所有<code>built-in</code>函数对象同时继承了<code>Object prototype object</code>和<code>Function prototype object</code>上的属性和方法，而所有非built-in函数对象只继承了<code>Object prototype object</code>上的方法。<code>Function prototype object</code>包含了所有函数共享的属性和方法，而<code>Object prototype object</code>包含了所有对象都共享额属性和方法。</p>
<p>对于上图中原型对象包含的constructor属性，下文当中有解释。</p>
<h3 id="创建对象时，原型链的构造过程"><a href="#创建对象时，原型链的构造过程" class="headerlink" title="创建对象时，原型链的构造过程"></a>创建对象时，原型链的构造过程</h3><p>在JavaScript当中创建对象有2中方式，一种是通过定义函数使用<strong>new方法</strong>来构造，另一种是使用<strong>对象字面量</strong>的方式，即:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jim Green&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用这两种方式创建对象时，对象的原型链构造过程有所不同。</p>
<ul>
<li><strong>1. 使用函数的方式构造对象</strong></li>
</ul>
<p>使用函数的方式构造对象分为两步:首先需要<strong>定义一个函数</strong>作为构造函数，然后使用<strong>new方法构造对象</strong>。接下来就来看一下这两个步骤会发生什么。   </p>
<p>假设我们定义了一个函数名为<code>F</code>，此时JavaScript会为我们做两件事，第一:根据我们定义的函数创建一个函数对象，第二，设置这个函数的<code>__proto__</code>属性和<code>prototype</code>属性。其中<code>__proto__</code>属性指向<code>built-in</code>的<code>Function prototype object</code>，而<code>prototype</code>属性指向一个为函数对象F新创建的原型对象，这个新创建的原型对象通过调用<code>new Object()</code>构造出来，并且为这个新创建的对象添加<code>constructor</code>属性，该属性指向函数对象<code>F</code>。最后的结果如下图所示:   </p>
<p><img src="http://images.pingan8787.com/20180927_03.png" alt="图3"></p>
<p>上图中为了方便，没有画出<code>Function prototype object</code>和<code>Object prototype object</code>的<code>constructor</code>属性。而<code>F</code> <code>prototype object</code>的<code>__proto__</code>属性为何指向<code>Object prototype object</code>，下文介绍<strong>new操作符</strong>时有解释。</p>
<p>当我们使用<strong>new方法</strong>调用F函数的时候，JavaScript也会为我们做两件事，第一，分配内存作为新创建的对象，第二，将新创建的对象的__proto__属性指向函数F的原型对象，结果如下图:<br><img src="http://images.pingan8787.com/20180927_04.png" alt="图4"></p>
<p>上图中，<code>obj</code>就是调用<strong>new方法</strong>通过<code>函数F</code>创建出来的对象，我们可以看到对象obj的原型链包含了<code>函数F</code>的原型对象，以及<code>Object prototype object</code>，这样，对象<code>obj</code>通过原型链查找规则，就能继承<code>函数F</code>的原型对象，以及<code>Object prototype object</code>上面定义的属性和方法了。并且如果我们想知道一个对象是由哪个方法构建的，只需要访问这个对象的<code>constructor</code>属性即可，上例中，只要我们访问<code>obj.constructor</code>，那么就知道obj是由<code>函数F</code>创建的。同时，由于<code>F</code> <code>prototype object</code>上文中介绍是由<code>new Object</code>函数创建的，根据此处介绍，F <code>prototype object</code>的<code>__proto__</code>属性应该指向<code>Object函数</code>的原型对象，即<code>Object prototype object</code>。</p>
<ul>
<li><strong>2. 使用对象字面量定义对象</strong></li>
</ul>
<p>当使用对象字面量创建对象时，JavaScript会为我们做两件事:</p>
<blockquote>
<p> 1 分配内存作为新创建的对象。<br> 2 将新创建对象的<code>__proto__</code>属性指向<code>Object prototype object</code>。  </p>
</blockquote>
<p>结果如下图所示:<br><img src="http://images.pingan8787.com/20180927_05.png" alt="图5"></p>
<p>上图为了简化，同样没有画出<code>Object prototype object</code>的<code>constructor</code>属性</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>理解了上面所讲的原理之后，假设目前有一个对象<code>A</code>(这个对象可以是任意的，包括JavaScript built-in的对象，任何函数对象，任何原型对象,以及我们自己new出来的对象),现在想创建一个对象<code>obj</code>，让<code>obj</code>继承<code>A</code>的属性和方法。</p>
<p>通过上面的介绍，我们知道创建对象有两种方式，但是使用对象字面量创建的对象其原型链总是只包含两个对象，一个是其自己，一个是<code>Object prototype object</code>，根本不可能包含对象<code>A</code>，无法达到让对象<code>obj</code>继承对象<code>A</code>属性和方法的效果。因此，只能使用函数的方式创建对象，让对象A包含在新创建对象obj的原型链中即可。</p>
<p>根据上面的讲解，如果是用函数的方式创建对象，那么在调用<code>new</code>方法时，新创建对象的<code>__proto__</code>属性会指向函数的原型对象。因此，只要在调用函数之前，将函数的原型对象换成<code>A</code>，然后再调用<code>new</code>方法，就可以将对象A包含在新创建的对象<code>obj</code>的原型链中，这样通过原型链查找规则，<code>obj</code>就继承了A的属性和方法。假设用来创建对象<code>obj</code>的函数为<code>B</code>，则相关代码为:  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.prototype = A;</span><br><span class="line">B.prototype.constructor = B;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> B(传入的参数)</span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>B.prototype.constructor = B</code>，是因为对象A中可能没有<code>constructor</code>属性，或者<code>constructor</code>属性不指向<code>B</code>，而为了方便通过访问任何由<code>B</code>函数创建的对象的<code>constructor</code>属性，就可以正确的知道该对象是使用函数<code>B</code>构造出来的。相关图示如下图:</p>
<p><img src="http://images.pingan8787.com/20180927_06.png" alt="图6"></p>
<p>上图中虚线框所包围的<code>B prototype object</code>就是定义函数<code>B</code>时，JavaScript为函数B生成的原型对象，但是该对象被我们用代码替换成了对象A。由于这个被替换的<code>B prototype object</code>没有其他地方再用到，因此会被回收掉。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/28/95-%E3%80%90JavaScript%E3%80%91%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8E%9F%E7%90%86/" data-id="ckts3ejwe00bh4d9k1w5rby7z" data-title="95-【JavaScript】原型继承的原理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-94-【JavaScript】js中attribute和property区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/26/94-%E3%80%90JavaScript%E3%80%91js%E4%B8%ADattribute%E5%92%8Cproperty%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2018-09-26T15:04:18.000Z" itemprop="datePublished">2018-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/26/94-%E3%80%90JavaScript%E3%80%91js%E4%B8%ADattribute%E5%92%8Cproperty%E5%8C%BA%E5%88%AB/">94-【JavaScript】js中attribute和property区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#112;&#x69;&#110;&#x67;&#x61;&#x6e;&#x38;&#x37;&#56;&#x37;&#64;&#113;&#113;&#46;&#x63;&#x6f;&#x6d;">&#112;&#x69;&#110;&#x67;&#x61;&#x6e;&#x38;&#x37;&#56;&#x37;&#64;&#113;&#113;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章</td>
<td><a target="_blank" rel="noopener" href="https://0x9.me/KMrv3">https://0x9.me/KMrv3</a></td>
</tr>
</tbody></table>
<hr>
<h2 id="1、Attribute"><a href="#1、Attribute" class="headerlink" title="1、Attribute"></a>1、Attribute</h2><p><code>Attribute</code>是<code>HTML</code>上设置的属性，在<code>HTML</code>中<strong>显式</strong>地设置，或者通过<code>setAttribute()</code>方法设置。   </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;txt&#x27;</span> <span class="attr">a</span>=<span class="string">b</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>比如这样一段<code>HTML</code>代码，实际上它有三个<code>attribute</code>属性，我们可以打印出来看看：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;txt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.attributes);</span><br></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/675542/201509/675542-20150906164922029-2117616374.png" alt="img1"></p>
<p>对于<code>Attribute</code>而言，它有三个常用的方法<code>setAttribute()</code>、<code>getAttribute()</code>以及<code>removeAttribute()</code>：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;txt&#x27;</span>);</span><br><span class="line">a.setAttribute(<span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.getAttribute(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">// b</span></span><br><span class="line">a.removeAttribute(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.getAttribute(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>对于用<code>setAttribute()</code>和<code>removeAttribute()</code>方法设置和删除的属性来说，会实时地反映在<code>html</code>页面的代码上。<code>Attribute</code>的属性值只能是字符串，属性键大小写不敏感，比如：   </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;txt&#x27;</span> <span class="attr">a</span>=<span class="string">b</span> <span class="attr">A</span>=<span class="string">&#x27;c&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以打开控制台看看代码的html结构（A被自动隐去了）。   </p>
<p>可以说，如果想要获取一个DOM元素的<code>attribute</code>属性值，只要打开控制台看看该DOM标签的<code>html</code>代码，任何时候<code>attribute</code>值和<code>html</code>标签内设置的属性值都是同步的。     </p>
<h2 id="2、Property"><a href="#2、Property" class="headerlink" title="2、Property"></a>2、Property</h2><p><code>Property</code>则比<code>Attribute</code>复杂一点。  </p>
<p>DOM是<code>JavaScrip</code>t里的对象，<code>Property</code>是DOM中的属性，它的属性值主要通过点运算符来获取和改变。这个对象实现了很多属性（<code>property</code>）：’<code>value</code>‘，’<code>className</code>‘等，以及一些方法<code>getAttribute</code>，<code>setAttribute</code>等，它也可以和其他的JavaScript对象一样<strong>添加自定义的属性以及方法</strong>。<code>property</code>的值可以是<strong>任何的数据类型</strong>，对大小写敏感，自定义的<code>property</code>不会出现在html代码中，只存在js中。      </p>
<p>还是示例代码，他的property属性值有哪些？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;txt&#x27;</span> <span class="attr">a</span>=<span class="string">b</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;txt&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(a.type); <span class="comment">// text</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(a.id); <span class="comment">// txt</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(a.a); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(a.title); <span class="comment">// &#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们在html页面的input元素中设置了a属性，但是在<code>property</code>中却是访问不到的；相反我们没有在html页面中设置的<code>title</code>，访问它却没有反映<code>undefined</code>！</p>
<p>这是怎么回事？   </p>
<p>因为所有的HTML元素都由<code>HTMLElement</code>类型表示，<code>HTMLElement</code>类型直接继承自<code>Element</code>并添加了一些属性，每个HTML元素都有下面的这5个标准特性：<code>id</code>，<code>title</code>，<code>lang</code>，<code>dir</code>，<code>className</code>（在DOM中以<code>property</code>方式操作这几个特性会同步到html标签中）。</p>
<p>所以即使在html中没有指定<code>id</code>、<code>title</code>等，也会默认赋予一个空串，通过property属性（点操作符）可以访问。而除此之外在html中设置的其他属性是不能通过<code>Property</code>访问到的（<code>attribute</code>特有的属性）。</p>
<p>如果把DOM元素看成是一个普通的Object对象，那么property就是一个以名值对(<code>name=&#39;value&#39;</code>)的形式存放在Object中的属性。要添加和删除<code>property</code>也简单多了，和普通的对象没啥分别：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;txt&#x27;</span>);</span><br><span class="line">a.age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.age); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">delete</span> a.age;</span><br><span class="line"><span class="built_in">console</span>.log(a.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>除了<code>id</code>、<code>title</code>等5个属性（<code>property</code>）外（每个element元素都有），个别的元素还有特别的属性，比如input元素有<code>name</code>，a元素有<code>href</code>等等。   </p>
<h2 id="3、Attribute-vs-Property"><a href="#3、Attribute-vs-Property" class="headerlink" title="3、Attribute vs Property"></a>3、Attribute vs Property</h2><p>既然说有些属性既能通过<code>attribute</code>访问修改，也能通过<code>property</code>，那么有什么值得注意的地方呢？  </p>
<p>之所以<code>attribute</code>和<code>property</code>容易混倄在一起的原因是，很多<code>attribute</code>节点还有一个相对应的<code>property</code>属性，比如div元素的<code>id</code>和<code>class</code>既是<code>attribute</code>，也有对应的<code>property</code>（id和className），不管使用哪种方法都可以<strong>访问和修改</strong>，如果在TAG对这些属性进行赋值，那么这些值就会作为初始值赋给DOM的同名property。</p>
<ul>
<li><strong>input元素的value</strong></li>
</ul>
<p>input元素的<code>value</code>属性是一大坑爹处，看下面代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;txt&#x27;</span>);</span><br><span class="line">a.setAttribute(<span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.value); <span class="comment">// test</span></span><br><span class="line"></span><br><span class="line">a.value = <span class="string">&#x27;change&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.getAttribute(<span class="string">&#x27;value&#x27;</span>)); <span class="comment">// test</span></span><br></pre></td></tr></table></figure>

<p>用<strong>点操作符</strong>改变<code>value</code>值，并不会更新<code>attribute</code>的<code>value</code>值；而相反用<code>attribute</code>更新<code>value</code>值，却会反映到<code>property</code>上…坑吧，谁规定的！</p>
<ul>
<li><strong>表单元素</strong>  </li>
</ul>
<p>DOM元素一些默认常见的<code>attribute</code>节点都有与之对应的<code>property</code>属性，比较特殊的是一些值为<code>Boolean类型</code>的<code>property</code>，如一些表单元素。对于这些特殊的<code>attribute</code>节点，只要存在该节点，对应的<code>property</code>的值就为<code>true</code>，如：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;radio&#x27;</span> <span class="attr">checked</span>=<span class="string">&#x27;checked&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;radio&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> radio = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;radio&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(radio.getAttribute(<span class="string">&#x27;checked&#x27;</span>)); <span class="comment">// &#x27;check&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(radio.checked); <span class="comment">// true</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>disabled类似。</p>
<ul>
<li><strong>href</strong></li>
</ul>
<p>两者对于<code>href</code>的获取也有不同之处，<code>attribute</code>取到的是实际设置的值（相对路径），而<code>property</code>取得的是绝对路径：   </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;a.html&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;web&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> radio = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;web&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(web.getAttribute(<span class="string">&#x27;href&#x27;</span>)); <span class="comment">// &#x27;a.html&#x27; </span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(web.href); <span class="comment">// 绝度路径</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p><code>Attribute</code>属性在<code>html</code>上设置，会反应在<code>html</code>代码上，两者<strong>同步</strong>；而<code>Property</code>属性则可以看做是DOM对象的键值对，用<strong>点操作符</strong>对它们进行操作。   </p>
<p>实际编程中，基本上的DOM操作都是使用<code>property</code>的点操作符。</p>
<p>只有两种情况不得不使用<code>attribute</code>：  </p>
<ul>
<li><p>1.自定义HTML Attribute，因为它不能同步到DOM property上</p>
</li>
<li><p>2.访问内置的HTML标签的<code>Attribute</code>，这些<code>attribute</code>不能从<code>property</code>上同步过来，比如<code>input标签</code>的<code>value</code>值（可以用来检验input值是否变化）</p>
</li>
</ul>
<h2 id="5、参考"><a href="#5、参考" class="headerlink" title="5、参考"></a>5、参考</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/rRssiL">JavaScript中的property和attribute的区别</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dojo-lzz/p/4781563.html">返本求源——DOM元素的特性与属性</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/26/94-%E3%80%90JavaScript%E3%80%91js%E4%B8%ADattribute%E5%92%8Cproperty%E5%8C%BA%E5%88%AB/" data-id="ckts3ejwd00be4d9kh9ughzfj" data-title="94-【JavaScript】js中attribute和property区别" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-93-【JavaScript】ajax的工作原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/24/93-%E3%80%90JavaScript%E3%80%91ajax%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2018-09-24T14:24:27.000Z" itemprop="datePublished">2018-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/24/93-%E3%80%90JavaScript%E3%80%91ajax%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">93-【JavaScript】ajax的工作原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#112;&#x69;&#x6e;&#103;&#x61;&#110;&#x38;&#55;&#56;&#55;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;">&#112;&#x69;&#x6e;&#103;&#x61;&#110;&#x38;&#55;&#56;&#55;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章</td>
<td><a target="_blank" rel="noopener" href="https://0x9.me/KMrv3">https://0x9.me/KMrv3</a></td>
</tr>
</tbody></table>
<hr>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>Ajax</strong>指<code>Asynchronous JavaScript and XML</code>（异步的 JavaScript 和 XML），最大的优点是在<strong>不重新加载整个页面</strong>的情况下，可以与服务器交换数据并更新部分网页内容。   </p>
<p>而实现的<strong>原理基础</strong>就是：网页DOM对象可以精确地对网页中的部分内容进行操作、XML作为单纯的数据存储载体使得客户端与服务器交换的只是网页内容的数据而没有网页样式等等的附属信息、<code>XMLHttpRequest</code>是与浏览器本身内置的<code>request</code>相互独立的与服务器交互的请求对象。  </p>
<p>网页应用Ajax与服务器交互的抽象过程如下图：<br><img src="http://images.pingan8787.com/20180924_01.png" alt="原理">  </p>
<h3 id="过程详解："><a href="#过程详解：" class="headerlink" title="过程详解："></a>过程详解：</h3><h4 id="步骤1："><a href="#步骤1：" class="headerlink" title="步骤1："></a>步骤1：</h4><p>要使用<strong>Ajax技术</strong>，基础中的基础，就是要创建一个<code>XMLHttpRequest对象</code>，无它就没有异步传输的可能：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="comment">//检查浏览器的XMLHttpRequest属性，如果为真则支持XMLHttpRequest</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123; </span><br><span class="line">	<span class="comment">// IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span><br><span class="line">	xmlhttp=<span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// IE6, IE5 浏览器执行代码</span></span><br><span class="line">	xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤2："><a href="#步骤2：" class="headerlink" title="步骤2："></a>步骤2：</h4><p>在网页中为某些事件的响应绑定<strong>异步操作</strong>：通过上面创建的<code>xmlhttp对象</code>传输请求、携带数据。在发出请求前要先定义请求对象的method、要提交给服务器中哪个文件进行请求的处理、要携带哪些数据、是否异步。   </p>
<p>其中，与普通的request提交数据一样，这里也分两种方法：<code>GET</code>/<code>POST</code>  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/demo_get2.php?fname=Henry&amp;lname=Ford&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">xmlhttp.open(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;/try/ajax/demo_post2.php&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">xmlhttp.send(<span class="string">&quot;fname=Henry&amp;lname=Ford&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="步骤3："><a href="#步骤3：" class="headerlink" title="步骤3："></a>步骤3：</h4><p>服务器收到请求后，把附带的数据作为输入传给处理请求的文件，例如这里：把<code>fname=Henry&amp;lname=Ford</code>作为输入，传给 <code>/try/ajax/demo_get2.php</code> 这个文件。<br>然后文件根据传入的数据做出处理，最终<strong>返回结果</strong>，通过<code>response对象</code>发回去。客户端根据<code>xmlhttp对象</code>来获取<code>response</code>内容，然后调用DOM对象根据<code>response</code>内容来局部修改网页内容。   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//请求处理完毕且状态为成功</span></span><br><span class="line">  <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)&#123;</span><br><span class="line">    <span class="comment">//用response内容来修改DOM中的元素的内容</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>response的类型</code>有两种：<strong>字符串类型</strong>和<strong>XML文本</strong>。两种回应的不同提取如下：</p>
<p><code>responseText 属性</code>返回字符串形式的响应：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br></pre></td></tr></table></figure>

<p>如果来自服务器的响应是 <code>XML</code>，需要作为<code>XML</code>对象进行解析，使用 <code>responseXML</code> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlDoc=xmlhttp.responseXML; <span class="comment">//获取服务器响应的XML文本并转换得到XMLDOM对象</span></span><br><span class="line"><span class="keyword">var</span> txt=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> x=xmlDoc.getElementsByTagName(<span class="string">&quot;ARTIST&quot;</span>);<span class="comment">//通过XMLDOM对象调用方法来获取XML对象中的内容</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;x.length;i++) &#123;</span><br><span class="line">  txt=txt + x[i].childNodes[<span class="number">0</span>].nodeValue + <span class="string">&quot;&lt;br&gt;&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=txt;<span class="comment">//把获取到的内容通过document对象更新到网页内容去</span></span><br></pre></td></tr></table></figure>


<p><strong>XMLHttpRequest对象的属性如下：</strong>  </p>
<ul>
<li><strong>onreadystatechange</strong>  每次状态改变所触发事件的事件处理程序。</li>
<li><strong>responseText</strong>     从服务器进程返回数据的字符串形式。</li>
<li><strong>responseXML</strong>    从服务器进程返回的DOM兼容的文档数据对象。</li>
<li>**status **          从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）</li>
<li><strong>status Text</strong>       伴随状态码的字符串信息</li>
<li><strong>readyState</strong>       对象状态值<br>0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）<br>1 (初始化) 对象已建立，尚未调用send方法<br>2 (发送数据) send方法已调用，但是当前的状态及http头未知<br>3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过<code>responseBody</code>和<code>responseText</code>获取部分数据会出现错误，<br>4 (完成) 数据接收完毕,此时可以通过通过<code>responseXml</code>和<code>responseText</code>获取完整的回应数据</li>
</ul>
<p>但是，由于各浏览器之间存在差异，所以创建一个<code>XMLHttpRequest对象</code>可能需要不同的方法。这个差异主要体现在IE和其它浏览器之间。下面是一个比较标准的创建<code>XMLHttpRequest对象</code>的方法。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateXmlHttp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//非IE浏览器创建XmlHttpRequest对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.XmlHttpRequest) &#123;</span><br><span class="line">    xmlhttp = <span class="keyword">new</span> XmlHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//IE浏览器创建XmlHttpRequest对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;msxml2.XMLHTTP&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ex) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ustbwuyi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="built_in">document</span>.getElementById(<span class="string">&quot;username&quot;</span>).value;</span><br><span class="line">  CreateXmlHttp();</span><br><span class="line">  <span class="keyword">if</span> (!xmlhttp) &#123;</span><br><span class="line">    alert(<span class="string">&quot;创建xmlhttp对象异常！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  xmlhttp.open(<span class="string">&quot;POST&quot;</span>, url, <span class="literal">false</span>);</span><br><span class="line">  xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">&quot;user1&quot;</span>).innerHTML = <span class="string">&quot;数据正在加载...&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (xmlhttp.status == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">document</span>.write(xmlhttp.responseText);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xmlhttp.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，函数首先检查<code>XMLHttpRequest</code>的整体状态并且保证它已经完成（<code>readyStatus=4</code>），即数据已经发送完毕。然后根据服务器的设定询问请求状态，如果一切已经就绪（<code>status=200</code>），那么就执行下面需要的操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/24/93-%E3%80%90JavaScript%E3%80%91ajax%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" data-id="ckts3ejwa00bc4d9k7lkgfcps" data-title="93-【JavaScript】ajax的工作原理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-92-【JavaScript】js中call和apply和bind方法介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/21/92-%E3%80%90JavaScript%E3%80%91js%E4%B8%ADcall%E5%92%8Capply%E5%92%8Cbind%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2018-09-21T13:18:29.000Z" itemprop="datePublished">2018-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/21/92-%E3%80%90JavaScript%E3%80%91js%E4%B8%ADcall%E5%92%8Capply%E5%92%8Cbind%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/">92-【JavaScript】js中call和apply和bind方法介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#x69;&#x6e;&#x67;&#x61;&#110;&#56;&#x37;&#56;&#x37;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;">&#x70;&#x69;&#x6e;&#x67;&#x61;&#110;&#56;&#x37;&#56;&#x37;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章</td>
<td><a target="_blank" rel="noopener" href="https://0x9.me/KMrv3">https://0x9.me/KMrv3</a></td>
</tr>
</tbody></table>
<hr>
<p>在js中，所有的函数再被调用的时候都会默认传入两个参数，一个是<code>this</code>，还有一个是<code>arguments</code>。</p>
<p>在默认情况下this都是指<strong>当前的调用函数的对象</strong>。但是有时候我们需要<strong>改变this的指向</strong>，也就是说使函数可以被其他对象来调用，那么我们应该怎样做呢？这时候我们就可以使用<code>call</code>,<code>apply</code>和<code>bind</code>方法了。</p>
<h2 id="1-call，apply和bind方法的由来"><a href="#1-call，apply和bind方法的由来" class="headerlink" title="1.call，apply和bind方法的由来"></a>1.call，apply和bind方法的由来</h2><p>在js中所有的函数都是<code>Function</code>的实例，而且对于<code>Function</code>来说，它的原型即<code>Function.prototype</code>中含有很多东西，其中<code>call</code>,<code>apply</code>和<code>bind</code>方法就是<code>Function原型</code>中的方法，所以根据原型的规则，所有的函数都可以使用原型中属性和方法，所以来说，<strong>对于所有的函数都可以使用call，apply和bind方法</strong>。</p>
<p>简单一句话：<code>call</code>，<code>apply</code>和<code>bind</code>都是<code>Function原型</code>中的方法，而所有的函数都是<code>Function</code>的实例。</p>
<h2 id="2-call，apply和bind方法的作用"><a href="#2-call，apply和bind方法的作用" class="headerlink" title="2.call，apply和bind方法的作用"></a>2.call，apply和bind方法的作用</h2><p>简单描述：就是<strong>改变this的指向</strong>。对于这句话的解释，我们可以结合代码来理解。  </p>
<h2 id="3-理解改变this的指向的含义"><a href="#3-理解改变this的指向的含义" class="headerlink" title="3.理解改变this的指向的含义"></a>3.理解改变this的指向的含义</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">sex</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;普通函数&quot;</span>+sex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;aa&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">14</span></span><br><span class="line">&#125;;</span><br><span class="line">show.call(person,<span class="string">&quot;男&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在上面的代码块中，我们可以看到<code>person</code>对象并没有<code>show</code>方法，但是我们可以通过<code>call</code>方法来实现<code>person对象</code>来调用<code>show方法</code>。所以这种情况我认为就是<strong>改变了this的指向</strong>。</p>
<p>同样的，<code>apply</code>和<code>bind</code>方法也可以实现上述的功能，那么它们三个有什么区别呢？</p>
<h2 id="4-call-apply和bind的区别"><a href="#4-call-apply和bind的区别" class="headerlink" title="4.call,apply和bind的区别"></a>4.call,apply和bind的区别</h2><p>它们在<strong>功能上是没有区别</strong>的，都是改变this的指向，它们的区别主要是在于方法的实现形式和参数传递上的不同  </p>
<ul>
<li>1：<code>函数.call(对象,arg1,arg2....)</code></li>
<li>2：<code>函数.apply(对象，[arg1,arg2,...])</code></li>
<li>3：<code>var ss=函数.bind(对象,arg1,arg2,....)</code></li>
</ul>
<p>我们通过代码来更加明显的区别一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">sex</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;普通函数&quot;</span>+sex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;aa&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">14</span></span><br><span class="line">&#125;;</span><br><span class="line">show.call(person,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">show.apply(person,[<span class="string">&quot;女&quot;</span>]);</span><br><span class="line"><span class="comment">//对于bind来说，用法更加的灵活</span></span><br><span class="line"><span class="keyword">var</span> ss=show.bind(person,<span class="string">&quot;不明&quot;</span>);</span><br><span class="line">ss();</span><br></pre></td></tr></table></figure>

<p>通过观察上面的代码，很明显的就可以得出它们三者的区别，仅仅是函数传递的不同以及bind方法可以更加的方便的使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/21/92-%E3%80%90JavaScript%E3%80%91js%E4%B8%ADcall%E5%92%8Capply%E5%92%8Cbind%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/" data-id="ckts3ejw900b94d9kh8u920qg" data-title="92-【JavaScript】js中call和apply和bind方法介绍" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-91-【JavaScript】前端模块化（Commonjs，AMD，CMD区别）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/20/91-%E3%80%90JavaScript%E3%80%91%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88Commonjs%EF%BC%8CAMD%EF%BC%8CCMD%E5%8C%BA%E5%88%AB%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2018-09-20T14:45:47.000Z" itemprop="datePublished">2018-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/20/91-%E3%80%90JavaScript%E3%80%91%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88Commonjs%EF%BC%8CAMD%EF%BC%8CCMD%E5%8C%BA%E5%88%AB%EF%BC%89/">91-【JavaScript】前端模块化（Commonjs，AMD，CMD区别）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#x69;&#110;&#x67;&#97;&#110;&#x38;&#x37;&#x38;&#55;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#109;">&#x70;&#x69;&#110;&#x67;&#97;&#110;&#x38;&#x37;&#x38;&#55;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章</td>
<td><a target="_blank" rel="noopener" href="https://0x9.me/KMrv3">https://0x9.me/KMrv3</a></td>
</tr>
</tbody></table>
<hr>
<p>前端模块规范有三种：<strong>CommonJs</strong>,<strong>AMD</strong>和<strong>CMD</strong>。  </p>
<ul>
<li><p>CommonJs用在<strong>服务器端</strong>，AMD和CMD用在<strong>浏览器环境</strong>。  </p>
</li>
<li><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>
</li>
<li><p>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>
</li>
<li><p>AMD:<strong>提前执行</strong>（异步加载：依赖先执行）+<strong>延迟执行</strong>。</p>
</li>
<li><p>CMD:<strong>延迟执行</strong>（运行到需加载，根据顺序执行）。</p>
</li>
</ul>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul>
<li><strong>函数写法</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>模块就是实现特定功能的文件，把几个函数放在一个文件里就构成了一个模块。需要的时候加载这个文件，调用其中的函数即可。<br>但这样做会污染全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。</p>
<ul>
<li><strong>对象写法</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">　　<span class="attr">star</span> : <span class="number">0</span>,</span><br><span class="line">　　<span class="attr">f1</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="comment">//...</span></span><br><span class="line">　　&#125;,</span><br><span class="line">　　<span class="attr">f2</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="comment">//...</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.f1();</span><br><span class="line"><span class="built_in">module</span>.star = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>模块写成一个对象，模块成员都封装在对象里，通过调用对象属性，访问使用模块成员。但同时也暴露了模块成员，外部可以修改模块内部状态。</p>
<ul>
<li><strong>立即执行函数</strong> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> star = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">　　&#125;;</span><br><span class="line">　　<span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="comment">//...</span></span><br><span class="line">　　&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">f1</span>:f1,</span><br><span class="line">        <span class="attr">f2</span>:f2</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">module</span>.f1();  <span class="comment">//ok</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.star)  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>外部无法访问内部私有变量</p>
<h2 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h2><p>CommonJS是服务器端模块的规范，由Node推广使用。由于服务端编程的复杂性，如果没有模块很难与操作系统及其他应用程序互动。使用方法如下：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="built_in">exports</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>, i = <span class="number">0</span>, args = <span class="built_in">arguments</span>, l = args.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">      sum += args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// increment.js</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>).add;</span><br><span class="line"><span class="built_in">exports</span>.increment = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(val, <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> increment = <span class="built_in">require</span>(<span class="string">&#x27;increment&#x27;</span>).increment;</span><br><span class="line"><span class="keyword">var</span> a = increment(<span class="number">1</span>); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>根据<strong>CommonJS</strong>规范:</p>
<ul>
<li><p>一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为<code>global对象</code>的属性。</p>
</li>
<li><p>输出模块变量的最好方法是使用<code>module.exports</code>对象。</p>
</li>
<li><p>加载模块使用<code>require</code>方法，该方法读取一个文件并执行，返回文件内部的<code>module.exports</code>对象</p>
</li>
</ul>
<p>仔细看上面的代码，您会注意到 <code>require</code> 是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。<br>然而， 这在浏览器端问题多多。  </p>
<p>浏览器端，加载 JavaScript 最佳、最容易的方式是在 <code>document</code> 中插入<code>&lt;script&gt;</code>标签。但脚本标签天生异步，传统 <code>CommonJS</code> 模块在浏览器环境中无法正常加载。</p>
<p>解决思路之一是，开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。</p>
<p>另一种解决思路是，用一套标准模板来封装模块定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The module code goes here</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这套模板代码为模块加载器提供了机会，使其能在模块代码执行之前，对模块代码进行静态分析，并动态生成依赖列表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">exports</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>, i = <span class="number">0</span>, args = <span class="built_in">arguments</span>, l = args.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">      sum += args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// increment.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>).add;</span><br><span class="line">  <span class="built_in">exports</span>.increment = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(val, <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> inc = <span class="built_in">require</span>(<span class="string">&#x27;increment&#x27;</span>).increment;</span><br><span class="line">  inc(<span class="number">1</span>); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD是<code>&quot;Asynchronous Module Definition&quot;</code>的缩写，意思就是”<strong>异步模块定义</strong>“。由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎<code>RequireJS</code>，实际上AMD 是 <code>RequireJS</code> 在推广过程中对模块定义的规范化的产出。 </p>
<p>它采用<strong>异步方式加载模块</strong>，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p><strong>RequireJS主要解决两个问题</strong></p>
<ul>
<li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。  </li>
<li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长。  </li>
</ul>
<p><code>RequireJs</code>也采用<code>require()</code>语句加载模块，但是不同于<code>CommonJS</code>，它要求两个参数:</p>
<p>第一个参数<code>[module]</code>，是一个数组，里面的成员就是要加载的模块；第二个参数<code>callback</code>，则是加载成功之后的回调函数。<code>math.add()</code>与<code>math模块</code>加载不是同步的，浏览器不会发生假死。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;increment&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">increment</span>) </span>&#123;</span><br><span class="line">　   increment.add(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="define-函数"><a href="#define-函数" class="headerlink" title="define()函数"></a>define()函数</h3><p><code>RequireJS</code>定义了一个函数 <code>define</code>，它是<strong>全局变量</strong>，用来定义模块:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><p><code>id</code>：指定义中<strong>模块的名字</strong>，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。</p>
</li>
<li><p><code>依赖dependencies</code>：是一个<strong>当前模块依赖的，已被模块定义的模块标识的数组字面量</strong>。<br>依赖参数是可选的，如果忽略此参数，它应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的长度属性小于3，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。</p>
</li>
<li><p><code>工厂方法factory</code>，<strong>模块初始化要执行的函数或对象</strong>。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。</p>
</li>
</ul>
<p>来举个🌰看看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">&quot;alpha&quot;</span>, [<span class="string">&quot;require&quot;</span>, <span class="string">&quot;exports&quot;</span>, <span class="string">&quot;beta&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, beta</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">exports</span>.verb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> beta.verb();</span><br><span class="line">          <span class="comment">//Or:</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&quot;beta&quot;</span>).verb();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="RequireJs使用例子"><a href="#RequireJs使用例子" class="headerlink" title="RequireJs使用例子"></a>RequireJs使用例子</h3><p><code>require.config</code>是用来定义别名的，在<code>paths</code>属性下配置别名。然后通过<code>requirejs</code>(参数一，参数二)；参数一是数组，传入我们需要引用的模块名，第二个参数是个回调函数，回调函数传入一个变量，代替刚才所引入的模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="comment">//别名配置</span></span><br><span class="line">requirejs.config(&#123;</span><br><span class="line">    <span class="attr">paths</span>: &#123;</span><br><span class="line">        <span class="attr">jquery</span>: <span class="string">&#x27;jquery.min&#x27;</span> <span class="comment">//可以省略.js</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//引入模块，用变量$表示jquery模块</span></span><br><span class="line">requirejs([<span class="string">&#x27;jquery&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).css(<span class="string">&#x27;background-color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>引入模块也可以只写<code>require()</code>。<code>requirejs</code>通过<code>define()</code>定义模块，定义的参数上同。在此模块内的方法和变量外部是无法访问的，只有通过<code>return</code>返回才行.  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define(<span class="string">&#x27;math&#x27;</span>,[<span class="string">&#x27;jquery&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;<span class="comment">//引入jQuery模块</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>将该模块命名为<code>math.js</code>保存。</p>
<h3 id="main-js引入模块方法"><a href="#main-js引入模块方法" class="headerlink" title="main.js引入模块方法"></a>main.js引入模块方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;jquery&#x27;</span>,<span class="string">&#x27;math&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$,math</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(math.add(<span class="number">10</span>,<span class="number">100</span>));<span class="comment">//110</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p><strong>CMD</strong> 即<code>Common Module Definition</code>通用模块定义，CMD规范是国内发展出来的，就像AMD有个<code>requireJS</code>，CMD有个浏览器的实现<code>SeaJS</code>，<code>SeaJS</code>要解决的问题和<code>requireJS</code>一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。  </p>
<p>在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模块代码</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>require</code>是可以把其他模块导入进来的一个参数;而<code>exports</code>是可以把模块内的一些属性和方法导出的;<code>module</code> 是一个对象，上面存储了与当前模块相关联的一些属性和方法。</p>
<p><code>AMD</code>是<strong>依赖关系前置</strong>,在定义模块的时候就要声明其依赖的模块;<br><code>CMD</code>是<strong>按需加载依赖就近</strong>,只有在用到某个模块的时候再去require：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>) <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐的是</span></span><br><span class="line">define([<span class="string">&#x27;./a&#x27;</span>, <span class="string">&#x27;./b&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  ...</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
<h3 id="seajs使用例子"><a href="#seajs使用例子" class="headerlink" title="seajs使用例子"></a>seajs使用例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块  myModule.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery.js&#x27;</span>)</span><br><span class="line">  $(<span class="string">&#x27;div&#x27;</span>).addClass(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">  <span class="built_in">exports</span>.data = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">&#x27;myModule.js&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> star= my.data;</span><br><span class="line">    <span class="built_in">console</span>.log(star);  <span class="comment">//1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>这篇《前端模块化：CommonJs,AMD和CDM》主要是个人对以下文章的总结，感谢这些老司机们的分享。<br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphinX/p/4381855.html">前端模块化</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000000733959#articleHeader3">详解JavaScript模块化开发</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html">Javascript模块化编程</a><br><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/seajs/seajs/issues/269">从 CommonJS 到 Sea.js</a>  </p>
<p>打开<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d67bc79976e6">原文</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/20/91-%E3%80%90JavaScript%E3%80%91%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88Commonjs%EF%BC%8CAMD%EF%BC%8CCMD%E5%8C%BA%E5%88%AB%EF%BC%89/" data-id="ckts3ejw800b74d9k8znp3ut9" data-title="91-【JavaScript】前端模块化（Commonjs，AMD，CMD区别）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-90-【HTTP协议】Apache之HTTP协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/19/90-%E3%80%90HTTP%E5%8D%8F%E8%AE%AE%E3%80%91Apache%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2018-09-19T14:30:02.000Z" itemprop="datePublished">2018-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/19/90-%E3%80%90HTTP%E5%8D%8F%E8%AE%AE%E3%80%91Apache%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE/">90-【HTTP】Apache之HTTP协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#x69;&#110;&#x67;&#x61;&#x6e;&#56;&#55;&#x38;&#x37;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;">&#x70;&#x69;&#110;&#x67;&#x61;&#x6e;&#56;&#55;&#x38;&#x37;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章</td>
<td><a target="_blank" rel="noopener" href="https://0x9.me/KMrv3">https://0x9.me/KMrv3</a></td>
</tr>
</tbody></table>
<hr>
<p><strong><code>HTTP</code>(Hypertext Transfer Protocol)超文本传输协议</strong>。是一种详细规定了客户端浏览器和万维网服务器之间相互通讯的规则，通过因特网传送万维网文档的数据传送协议。  </p>
<h2 id="一、HTTP的前世今生"><a href="#一、HTTP的前世今生" class="headerlink" title="一、HTTP的前世今生"></a>一、HTTP的前世今生</h2><p><strong>超文本传输协议</strong>的前身是Xanadu项目，超文本的概念是泰德.纳尔森在1960年提出的。而HTTP在1989年诞生在CERN(欧洲量子物理实验室)。1990年12月，超文本协议在CERN首次上线。1991年夏天，继Telnet等协议之后，超文本传输协议正式成为互联网诸多协议的一份子。</p>
<p><strong>HTTP诞生的原因</strong>：为了实现从一台计算机上获取并显示存放在多台计算机里的文件、数据、图片和其他类型的文件而诞生HTTP协议。因为在当时其他诸多已经诞生的协议解决不了这个问题。例如：Telnet、SMTP、POP3、IAMP4、FTP等。所以HTTP协议应运而生。</p>
<h2 id="二、HTTP协议的版本"><a href="#二、HTTP协议的版本" class="headerlink" title="二、HTTP协议的版本"></a>二、HTTP协议的版本</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h3><p><strong>HTTP 0.9</strong>作为HTTP协议的第一个成熟版本。此版本功能非常薄弱。  </p>
<ul>
<li> 1.请求只有一行</li>
<li> 2.没有HTTP头部信息和错误代码信息</li>
<li> 3.只能接收一种类型的数据：纯文本</li>
<li> 4.只有一种方法：GET</li>
</ul>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>随着互联网的发展，<strong>HTTP 0.9</strong>已经不能满足互联网发展的需求。因此<strong>HTTP 1.0</strong>就这样诞生了。<strong>HTTP 1.0</strong>的最大改变是引入了<code>POST</code>方法，使得客户端通过<code>HTML表单</code>向服务器发送数据成为可能。从而实现了客户端和服务器端的数据交互。这是WEB应用程序的一个基础。另一个巨大的改变是引入了<code>HTTP头</code>，使得HTTP协议不仅能返回错误代码，并且借助于MIME技术能够传输更为丰富的文件类型，不再局限于纯文本。还可以是图片、动画等其他文件格式。</p>
<p>除此之外，还允许保持连接，即一次TCP连接，可以实现多次通讯。<code>HTTP 1.0</code>默认是<strong>传输一次数据后就关闭连接</strong>。</p>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><p>2000年5月，<code>HTTP 1.1</code>诞生。<code>HTTP 1.1</code>并不像<code>HTTP 1.0</code>对<code>HTTP 0.9</code>那样的革命性。但是对<code>HTTP 1.0</code>做了很多功能性的增强。  </p>
<ul>
<li>1.增加了<code>Host头</code><br>使得GET后面只需使用相对路径；<br>使得一台主机可以使用多个域名；  </li>
<li>2.引入了<code>Range头 使得客户端通过</code>HTTP`下载时只下载内容的一部分，使得多线程下载成为可能；  </li>
</ul>
<h2 id="三、HTTP协议的特点"><a href="#三、HTTP协议的特点" class="headerlink" title="三、HTTP协议的特点"></a>三、HTTP协议的特点</h2><ul>
<li><p><strong>1.支持C/S模式</strong><br>支持基本认证和安全认证。 </p>
</li>
<li><p><strong>2.简单快速</strong><br>客户端向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有<code>GET</code>、<code>HEAD</code>、<code>POST</code>。每种方法规定了客户端与服务器端联系的不同类型。由于<code>HTTP协议</code>简单，使得HTTP服务器的程序规模小，因而通讯速度快。 </p>
</li>
<li><p><strong>3.灵活</strong><br>HTTP协议允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>
</li>
<li><p><strong>4.HTTP 0.9和HTTP 1.0使用非持续连接</strong><br>限制每次连接只处理一个请求，服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。采用这种方式可以节省传输时间。<br>HTTP 1.1使用持续连接：不必为每个Web对象创建一个新的连接，一个连接可以传送多个对象。     </p>
</li>
<li><p><strong>5.无状态：</strong><br>HTTP协议是无状态协议。<br>无状态是指协议对于事物处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。</p>
</li>
</ul>
<h2 id="四、HTTP实现原理"><a href="#四、HTTP实现原理" class="headerlink" title="四、HTTP实现原理"></a>四、HTTP实现原理</h2><p><strong>在TCP/IP协议栈中的位置</strong>：<br>  HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：<br><img src="http://s3.51cto.com/wyfs02/M02/38/15/wKioL1OybmbgvkXfAABJlqiTUPM914.jpg" alt="HTTPS"></p>
<p>  默认HTTP的端口号为80，HTTPS的端口号为443。</p>
<p><strong>HTTP的请求响应模型</strong>：<br>  HTTP协议永远都是客户端发起请求，服务器回送响应。如下图所示：<br><img src="http://s3.51cto.com/wyfs02/M00/38/15/wKiom1OybujR2rlWAABZ59w_LlM241.jpg" alt="发起请求"> </p>
<p>  这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。</p>
<p>  HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。</p>
<p><strong>工作流程：</strong><br>一次HTTP操作称为一个事务，其工作过程可分为四步：  </p>
<ul>
<li><p>1.首先客户机与服务器需要<strong>建立连接</strong>。只要单击某个超级链接，HTTP的工作开始。  </p>
</li>
<li><p>2.建立连接后，客户机发送一个请求给服务器，请求方式的格式为：<strong>统一资源标识符（URL）、协议版本号</strong>，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p>
</li>
<li><p>3.服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括<strong>信息的协议版本号</strong>、<strong>一个成功或错误的代码</strong>，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p>
</li>
<li><p>4.客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器<strong>断开连接</strong>。</p>
</li>
</ul>
<p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。  </p>
<p><strong>简化版</strong>：</p>
<ul>
<li>1.建立连接</li>
<li>2.接收请求</li>
<li>3.处理请求</li>
<li>4.获取资源</li>
<li>5.构建响应</li>
<li>6.回送响应</li>
<li>7.记录日志</li>
</ul>
<h2 id="五、HTTP的几个重要概念"><a href="#五、HTTP的几个重要概念" class="headerlink" title="五、HTTP的几个重要概念"></a>五、HTTP的几个重要概念</h2><h3 id="URI、URL、URN："><a href="#URI、URL、URN：" class="headerlink" title="URI、URL、URN："></a>URI、URL、URN：</h3><ul>
<li><strong>URI</strong>： Uniform Resource Identifier，统一资源标识符；</li>
<li><strong>URL</strong>： Uniform Resource Locator，统一资源定位符；</li>
<li><strong>URN</strong>： Uniform Resource Name，统一资源命名符；</li>
</ul>
<p>其中，URL,URN是URI的<strong>子集</strong>。  </p>
<p>Web上地址的<strong>基本形式</strong>是URI,它代表<strong>通用资源标识符</strong>。有两种形式：  </p>
<ul>
<li><strong>URL</strong>：目前URI的最普遍形式就是无处不在的URL或统一资源定位器。  </li>
<li><strong>URN</strong>：URL的一种更新形式，统一资源名称(URN, Uniform Resource Name)不依赖于位置，并且有可能减少失效连接的个数。但是其流行还需假以时日，因为它需要更精密软件的支持。  </li>
</ul>
<p><strong>URI格式</strong>：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://[username:password@]HOST:port/path/to/source </span><br></pre></td></tr></table></figure>

<h3 id="连接-Connection-："><a href="#连接-Connection-：" class="headerlink" title="连接(Connection)："></a>连接(Connection)：</h3><p>一个传输层的实际环流，它是建立在<strong>两个相互通讯的应用程序之间</strong>。  </p>
<p>在<strong>http1.1</strong>，<code>request</code>和<code>reponse</code>头中都有可能出现一个<code>connection</code>的头，此<code>header</code>的含义是当<code>client</code>和<code>serve</code>r通信时对于长链接如何进行处理。  </p>
<p>在<strong>http1.1</strong>中，<code>client</code>和<code>server</code>都是默认<strong>对方支持长链接</strong>的， 如果<code>client</code>使用<strong>http1.1协议</strong>，但又不希望使用长链接，则需要在<code>header</code>中指明<code>connection</code>的值为<code>close</code>；如果<code>server</code>方也不想支持长链接，则在<code>response</code>中也需要明确说明<code>connection</code>的值为<code>close</code>。不论<code>request</code>还是<code>response</code>的<code>header</code>中包含了值为<code>close</code>的<code>connection</code>，都表明当前正在使用的tcp链接在<strong>当天请求处理完毕后会被断掉</strong>。以后client再进行新的请求时就必须<strong>创建新的tcp链接</strong>了。</p>
<h3 id="消息-Message"><a href="#消息-Message" class="headerlink" title="消息(Message):"></a>消息(Message):</h3><p>  HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。  </p>
<h3 id="请求-Request"><a href="#请求-Request" class="headerlink" title="请求(Request):"></a>请求(Request):</h3><p>  一个从客户端到服务器的请求信息包括<strong>应用于资源的方法</strong>、<strong>资源的标识符</strong>和<strong>协议的版本号</strong>。  </p>
<h3 id="响应-Response"><a href="#响应-Response" class="headerlink" title="响应(Response):"></a>响应(Response):</h3><p>  一个从服务器返回的信息包括<strong>HTTP协议的版本号</strong>、<strong>请求的状态</strong>(例如“成功”或“没找到”)和<strong>文档的MIME类型</strong>。</p>
<h3 id="资源-Resource"><a href="#资源-Resource" class="headerlink" title="资源(Resource):"></a>资源(Resource):</h3><p>  由<strong>URI</strong>标识的网络数据对象或服务。</p>
<h3 id="实体-Entity"><a href="#实体-Entity" class="headerlink" title="实体(Entity):"></a>实体(Entity):</h3><p>  数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括<strong>实体头信息</strong>和<strong>实体的本身内容</strong>。</p>
<h3 id="客户机-Client"><a href="#客户机-Client" class="headerlink" title="客户机(Client):"></a>客户机(Client):</h3><p>  一个为发送请求目的而建立连接的应用程序。</p>
<h3 id="用户代理-UserAgent"><a href="#用户代理-UserAgent" class="headerlink" title="用户代理(UserAgent):"></a>用户代理(UserAgent):</h3><p>  初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。</p>
<h3 id="服务器-Server"><a href="#服务器-Server" class="headerlink" title="服务器(Server):"></a>服务器(Server):</h3><p>  一个接受连接并对请求返回信息的应用程序。</p>
<h3 id="源服务器-OriginServer"><a href="#源服务器-OriginServer" class="headerlink" title="源服务器(OriginServer):"></a>源服务器(OriginServer):</h3><p>  是一个给定资源可以在其上驻留或被创建的服务器。</p>
<h3 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理(Proxy):"></a>代理(Proxy):</h3><p>  一个中间程序，它可以充当一个<strong>服务器</strong>，也可以充当一个<strong>客户机</strong>，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。</p>
<p>  代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。</p>
<h3 id="网关-Gateway"><a href="#网关-Gateway" class="headerlink" title="网关(Gateway):"></a>网关(Gateway):</h3><p>  一个作为<strong>其它服务器中间媒介的服务器</strong>。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。</p>
<p>  网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。</p>
<h3 id="通道-Tunnel"><a href="#通道-Tunnel" class="headerlink" title="通道(Tunnel):"></a>通道(Tunnel):</h3><p>  是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</p>
<h3 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存(Cache):"></a>缓存(Cache):</h3><p>  反应信息的局域存储。</p>
<h2 id="六、HTTP协议头"><a href="#六、HTTP协议头" class="headerlink" title="六、HTTP协议头"></a>六、HTTP协议头</h2><p>HTTP头按照其不同的作用，分为四类：  </p>
<h3 id="1-通用头-General-Header"><a href="#1-通用头-General-Header" class="headerlink" title="1.通用头(General Header)"></a>1.通用头(General Header)</h3><p>  通用头<strong>即可以包含在HTTP请求中，也可以包含在HTTP响应中</strong>。<br>  通用头的作用是描叙HTTP协议本身。比如<strong>描叙HTTP是否持续连接</strong>的<code>Connection头</code>，<strong>HTTP发送日期</strong>的<code>Date头</code>，<strong>描述HTTP所在的TCP连接时间</strong>的<code>Keep-Alive头</code>，用于<strong>缓存控制</strong>的<code>Cache-Control头</code>等。</p>
<h3 id="2-实体头-Entity-Header"><a href="#2-实体头-Entity-Header" class="headerlink" title="2.实体头(Entity Header)"></a>2.实体头(Entity Header)</h3><p>  实体头是那些<strong>描叙HTTP信息的头</strong>。即可出现在HTTP POST方法的请求中，也可以出现在HTTP响应中。<br>  例如<code>Content-Type</code>和<code>Content-length</code>都是描述实体的类型和大小的头都属于实体头。其它还有用于描述实体的<code>Content-Language</code>,<code>Content-MD5</code>,<code>Content-Encoding</code>以及控制实体缓存的<code>Expires</code>和<code>Last-Modifies头</code>等。</p>
<p><strong>常见的实体头</strong>如下：</p>
<blockquote>
<ul>
<li><strong>Allow</strong>：服务器支持哪些请求方法（如GET、POST等）；  </li>
<li><strong>Content-Encoding</strong>：文档的编码（Encode）方法，例如：gzip，见“2.5 响应头”；  </li>
<li><strong>Content-Language</strong>：内容的语言类型，例如：zh-cn；  </li>
<li><strong>Content-Length</strong>：表示内容长度，eg：80，可参考“2.5响应头”；  </li>
<li><strong>Content-Location</strong>：表示客户应当到哪里去提取文档；  </li>
<li><strong>Content-MD5</strong>：MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。Eg1：Content-MD5: &lt;base64 of 128 MD5 digest&gt;。<code>Eg2：dfdfdfdfdfdfdff==</code>；  </li>
<li><strong>Content-Range</strong>：随部分实体一同发送；标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。Eg1：<code>Content-Range: 1001-2000/5000，eg2：bytes 2543-4532/7898</code>；  </li>
<li><strong>Content-Type</strong>：标明发送或者接收的实体的MIME类型。Eg：<code>text/html</code>; <code>charset=GB2312</code>主类型/子类型；  </li>
<li><strong>Expires</strong>：为0证明不缓存；  </li>
<li><strong>Last-Modified</strong>：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：<code>Last-Modified：Tue, 06 May 2008 02:42:43 GMT</code>；  </li>
</ul>
</blockquote>
<h3 id="3-请求头-HTTP-Request-Header"><a href="#3-请求头-HTTP-Request-Header" class="headerlink" title="3.请求头(HTTP Request Header)"></a>3.请求头(HTTP Request Header)</h3><p>  请求头是那些由客户端发往服务器端以便帮助服务器端更好的满足客户端请求的头。<br>  请求头只能出现在HTTP请求中。比如告诉服务器<strong>只接收某种响应内容</strong>的<code>Accept头</code>，<strong>发送Cookies</strong>的<code>Cookie头</code>，<strong>显示请求主机域</strong>的<code>HOST头</code>，<strong>用于缓存</strong>的<code>If-Match</code>,<code>If-Match-Since</code>,<code>If-None-Match头</code>，<strong>用于只取HTTP响应信息中部分信息</strong>的<code>Range头</code>，<strong>用于附属HTML相关请求引用</strong>的<code>Referee头</code>等。  </p>
<p><strong>常见请求头如下：</strong>   </p>
<blockquote>
<ul>
<li><strong>Accept</strong>：浏览器可接受的MIME类型；  </li>
<li><strong>Accept-Charse</strong>t：浏览器可接受的字符集；  </li>
<li><strong>Accept-Encoding</strong>：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间；</li>
<li><strong>Accept-Language</strong>：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到；</li>
<li><strong>Authorization</strong>：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中；</li>
<li><strong>Connection</strong>：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”  ，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小；</li>
<li><strong>Content-Length</strong>：表示请求消息正文的长度；  </li>
<li><strong>Cookie</strong>：这是最重要的请求头信息之一；  </li>
<li><strong>From</strong>：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它；</li>
<li><strong>Host</strong>：初始URL中的主机和端口；  </li>
<li><strong>If-Modified-Since</strong>：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答；</li>
<li><strong>Pragma</strong>：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；</li>
<li><strong>Referer</strong>：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。  </li>
<li><strong>User-Agent</strong>：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用；</li>
<li><strong>UA-Pixels，UA-Color，UA-OS，UA-CPU</strong>：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</li>
</ul>
</blockquote>
<h3 id="4-响应头-HTTP-Response-Header"><a href="#4-响应头-HTTP-Response-Header" class="headerlink" title="4.响应头(HTTP Response Header)"></a>4.响应头(HTTP Response Header)</h3><p>HTTP响应头是那些描述HTTP响应本身的头，这里并不包含描述HTTP响应中第三部分也就是HTTP信息的头（这部分由实体头负责）。<br>比如说定时刷新的Refresh头，当遇到503错误时自动重试的Retry-After头，显示服务器信息的Server头，设置COOKIE的Set-Cookie头，告诉客户端可以部分请求的Accept-Ranges头等。  </p>
<p><strong>常见响应头如下：</strong></p>
<blockquote>
<ul>
<li><strong>Allow</strong>服务器支持哪些请求方法（如<code>GET</code>、<code>POST</code>等）；  </li>
<li><strong>Content-Encoding</strong>文档的编码（Encode）方法。<br>只有在解码之后才可以得到<code>  Content-Type头</code>指定的内容类型。利用<code>gzip压缩文档</code>能够显著地减少HTML文档的下载时间。Java的<code>GZIPOutputStream</code>可以很方便地进行<code>gzip压缩</code>，但只有<code>Unix</code>上的<code>Netscape</code>和<code>Windows</code>上的<code>IE 4</code>、<code>IE 5</code>才支持它。因此，<code>Servlet</code>应该通过查看<code>Accept-Encoding头</code>（即<code>request.getHeader</code>(“<code>Accept-Encoding</code>“)）检查浏览器是否支持<code>gzip</code>，为支持<code>gzip</code>的浏览器返回经<code>gzip</code>压缩的HTML页面，为其他浏览器返回普通页面；</li>
<li><strong>Content-Length</strong>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入<code>ByteArrayOutputStram</code>，完成后查看其大小，然后把该值放入<code>Content-Length头</code>，最后通过<code>byteArrayStream.writeTo(response.getOutputStream())</code>发送内容；</li>
<li><strong>Content-Type</strong> 表示后面的文档属于什么<code>MIME类</code>型。<code>Servlet</code>默认为<code>text/plain</code>，但通常需要显式地指定为<code>text/html</code>。由于经常要设置<code>Content-Type</code>，因此<code>HttpServletResponse</code>提供了一个专用的方法<code>setContentTyep</code>。 可在web.xml文件中配置扩展名和MIME类型的对应关系；</li>
<li><strong>Date</strong>当前的GMT时间。你可以用<code>setDateHeader</code>来设置这个头以避免转换时间格式  的麻烦；</li>
<li><strong>Server</strong>服务器软件名称及版本。  </li>
<li><strong>Age</strong>响应给客户端的文档可以缓存多长时间  </li>
<li><strong>Public</strong>  </li>
<li><strong>Vary</strong>  </li>
<li><strong>Set-Cookie</strong>  </li>
<li><strong>Set-Cookie2</strong>  </li>
<li><strong>Expires</strong>指明应该在什么时候认为文档已经过期，从而不再缓存它。  </li>
<li><strong>Last-Modified</strong>文档的最后改动时间。客户可以通过<code>If-Modified-Since</code>请求头提供一个日期，该请求将被视为一个条件<code>GET</code>，只有改动时间迟于指定时间的文档才会返回，否则返回一个<strong>304</strong>（<code>Not Modified</code>）状态。<code>Last-Modified</code>也可用<code>setDateHeader</code>方法来设置；</li>
<li><strong>Location</strong>表示客户应当到哪里去提取文档。<br><code>Location</code>通常不是直接设置的，而是通过<code>HttpServletResponse</code>的<code>sendRedirect</code>方法，该方法同时设置状态代码为<strong>302</strong>；</li>
<li><strong>Refresh</strong>表示浏览器应该在多少时间之后刷新文档，以秒计。<br>除了刷新当前文档之外，你还可以通过<code>setHeader(&quot;Refresh&quot;, &quot;5; URL=http://host/path&quot;)</code>让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的<code>&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;5;URL=http://host/path&quot;&gt;</code>实现，这是因为，自动刷新或重定向对于那些不能使用CGI或<code>Servle</code>t的HTML编写者十分重要。但是，对于<code>Servlet</code>来说，直接设置<code>Refresh头</code>更加方便。注意<code>Refres</code>h的意义是“<strong>N秒之后刷新本页面或访问指定页面</strong>”，而不是“<strong>每隔N秒刷新本页面或访问指定页面</strong>”。因此，连续刷新要求每次都发送一个<code>Refresh头</code>，而发送<strong>204</strong>状态代码则可以阻止浏览器继续刷新，不管是使用<code>Refresh头</code>还是<code>&lt;META HTTP-EQUIV=&quot;Refresh&quot; ...&gt;</code>。注意<code>Refresh头</code>不属于<strong>HTTP 1.1正式规范</strong>的一部分，而是一个扩展，但<code>Netscape</code>和<code>IE</code>都支持它。</li>
</ul>
</blockquote>
<h2 id="七、HTTP请求"><a href="#七、HTTP请求" class="headerlink" title="七、HTTP请求"></a>七、HTTP请求</h2><p>HTTP请求由三部分组成，分别是：<strong>请求行</strong>、<strong>消息报头</strong>、<strong>请求正文</strong><br>请求行以一个方法符开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method  Request-URI  HTTP-Version CRLF</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Method</strong> 表示请求方法；  </li>
<li><strong>Request-URI</strong> 是一个统一资源标识符，也就是资源路径；  </li>
<li><strong>HTTP-Version</strong> 表示HTTP协议版本；  </li>
<li><strong>CRLF</strong> 表示回车和换行。  </li>
</ul>
<p><strong>请求方法：</strong>  </p>
<blockquote>
<ul>
<li><strong>GET</strong>        请求获取Request-URI所标识的资源</li>
<li><strong>POST</strong>       在Request-URI所标识的资源后附加新的数据,常用于提交表单</li>
<li><strong>HEAD</strong>       请求获取由Request-URI所标识的资源的响应消息报头</li>
<li><strong>PUT</strong>        请求服务器存储一个资源，并用Request-URI作为其标识</li>
<li><strong>DELETE</strong>     请求服务器删除Request-URI所标识的资源</li>
<li><strong>TRACE</strong>      请求服务器回送收到的请求信息，主要用于测试或诊断<br>可以追踪一次请求中间所经过的代理服务器有哪些</li>
<li><strong>CONNECT</strong>    保留将来使用</li>
<li><strong>OPTIONS</strong>    请求查询服务器的性能，或者查询与资源相关的选项和需求<br>可以用来获取服务器端资源支持的方法</li>
</ul>
</blockquote>
<h2 id="八、HTTP响应"><a href="#八、HTTP响应" class="headerlink" title="八、HTTP响应"></a>八、HTTP响应</h2><p>在接收和解释请求消息后，服务器返回一个HTTP响应消息。</p>
<p>HTTP响应也是由三个部分组成，分别是：<strong>状态行</strong>、<strong>消息报头</strong>、<strong>响应正文</strong></p>
<p><strong>状态行格式如下</strong>：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP-Version  Status-Code  Reason-Phrase  CRLF</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>HTTP-Version</strong> 表示服务器HTTP协议的版本；</li>
<li><strong>Status-Code</strong> 表示服务器发回的响应状态代码；</li>
<li><strong>Reason-Phrase</strong> 表示状态代码的文本描述。</li>
</ul>
</blockquote>
<p>状态代码有<strong>三位数字</strong>组成，第一个数字定义了响应的类别，且有五种可能取值：  </p>
<blockquote>
<ul>
<li><strong>1xx</strong>：指示信息–表示请求已接收，继续处理</li>
<li><strong>2xx</strong>：成功–表示请求已被成功接收、理解、接受</li>
<li><strong>3xx</strong>：重定向–信息不完整需要进一步补充</li>
<li><strong>4xx</strong>：客户端错误–请求有语法错误或请求无法实现</li>
<li><strong>5xx</strong>：服务器端错误–服务器未能实现合法的请求</li>
</ul>
</blockquote>
<p><strong>常见http响应状态码</strong>：  </p>
<h4 id="请求收到，继续处理："><a href="#请求收到，继续处理：" class="headerlink" title="请求收到，继续处理："></a>请求收到，继续处理：</h4><blockquote>
<ul>
<li><strong>100</strong>：客户端必须继续发出请求</li>
<li><strong>101</strong>：客户端要求服务器根据请求转换HTTP协议版本</li>
</ul>
</blockquote>
<h4 id="操作成功收到，分析，接受："><a href="#操作成功收到，分析，接受：" class="headerlink" title="操作成功收到，分析，接受："></a>操作成功收到，分析，接受：</h4><blockquote>
<ul>
<li><strong>200</strong>：交易成功</li>
<li><strong>201</strong>：提示知道新文件的URL</li>
<li><strong>202</strong>：接受和处理、但处理未完成</li>
<li><strong>203</strong>：返回信息不确定或不完整</li>
<li><strong>204</strong>：请求收到，但返回信息为空</li>
<li><strong>205</strong>：服务器完成了请求，用户代理必须复位当前已经浏览过的文件</li>
<li><strong>206</strong>：服务器已经完成了部分用户的GET请求</li>
</ul>
</blockquote>
<h4 id="重定向："><a href="#重定向：" class="headerlink" title="重定向："></a>重定向：</h4><blockquote>
<ul>
<li><strong>300</strong>：请求的资源可在多处得到</li>
<li><strong>301</strong>：永久重定向，在Location响应首部的值仍为当前URL(隐式重定向)</li>
<li><strong>302</strong>：临时重定向，在Location响应首部的值仍为新的URL(显示重定向)</li>
<li><strong>303</strong>：建议客户端访问其他URL或访问方式</li>
<li><strong>304</strong>：Not Modified 请求的资源没有改变 可以继续使用缓存</li>
<li><strong>305</strong>：请求的资源必须从服务器指定的地址得到</li>
<li><strong>306</strong>：前一版本HTTP中使用的代码，现行版本中不再使用</li>
<li><strong>307</strong>：声明请求的资源临时性删除</li>
</ul>
</blockquote>
<h4 id="客户端错误："><a href="#客户端错误：" class="headerlink" title="客户端错误："></a>客户端错误：</h4><blockquote>
<ul>
<li><strong>400</strong>：错误请求，如语法错误</li>
<li><strong>401</strong>：未授权<br><strong>HTTP 401.1</strong> - 未授权，登录失败<br><strong>HTTP 401.2</strong> - 未授权，服务器配置问题导致登录失败<br><strong>HTTP 401.3</strong> - ACL  禁止访问资源<br><strong>HTTP 401.4</strong> - 未授权  授权被筛选器拒绝<br><strong>HTTP 401.5</strong> - 未授权  ISAPI或CGI授权失败</li>
<li><strong>402</strong>：保留有效ChargeTo头响应</li>
<li><strong>403</strong>：禁止访问<br><strong>HTTP 403.1</strong> - 禁止访问  禁止可执行访问<br><strong>HTTP 403.2</strong> - 禁止访问  禁止读访问<br><strong>HTTP 403.3</strong> - 禁止访问  禁止写访问<br><strong>HTTP 403.4</strong> - 禁止访问  要求SSL<br><strong>HTTP 403.5</strong> - 禁止访问  要求SSL 128<br><strong>HTTP 403.6</strong> - 禁止访问  IP地址被拒绝<br><strong>HTTP 403.7</strong> - 禁止访问  要求客户端证书<br><strong>HTTP 403.8</strong> - 禁止访问  禁止站点访问<br><strong>HTTP 403.9</strong> - 禁止访问  连接的用户过多<br><strong>HTTP 403.10</strong> - 禁止访问  配置无效<br><strong>HTTP 403.11</strong> - 禁止访问  密码更改<br><strong>HTTP 403.12</strong> - 禁止访问  映射器拒绝访问<br><strong>HTTP 403.13</strong> - 禁止访问  客户端证书已被吊销<br><strong>HTTP 403.15</strong> - 禁止访问  客户端访问许可过多<br><strong>HTTP 403.16</strong> - 禁止访问  客户端证书不可信或者无效<br><strong>HTTP 403.17</strong> - 禁止访问  客户端证书已经到期或者尚未生效</li>
<li><strong>404</strong>：没有发现文件、查询或URL</li>
<li><strong>405</strong>：用户在Request-Line字段定义的方法不允许</li>
<li><strong>406</strong>：根据用户发送的Accept拖，请求资源不可访问</li>
<li><strong>407</strong>：类似401，用户必须首先在代理服务器上得到授权</li>
<li><strong>408</strong>：客户端没有在用户指定的饿时间内完成请求</li>
<li><strong>409</strong>：对当前资源状态，请求不能完成</li>
<li><strong>410</strong>：服务器上不再有此资源且无进一步的参考地址</li>
<li><strong>411</strong>：服务器拒绝用户定义的Content-Length属性请求   </li>
<li><strong>412</strong>：一个或多个请求头字段在当前请求中错误</li>
<li><strong>413</strong>：请求的资源大于服务器允许的大小</li>
<li><strong>414</strong>：请求的资源URL长于服务器允许的长度</li>
<li><strong>415</strong>：请求资源不支持请求项目格式</li>
<li><strong>416</strong>：请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，       请求也不包含If-Range请求头字段</li>
<li><strong>417</strong>   服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长</li>
</ul>
</blockquote>
<h4 id="服务器端错误"><a href="#服务器端错误" class="headerlink" title="服务器端错误:"></a>服务器端错误:</h4><blockquote>
<ul>
<li><strong>500</strong>部服务器错误<br><strong>HTTP 500.100</strong> - 内部服务器错误<br><strong>HTTP 500-11</strong> 服务器关闭<br><strong>HTTP 500-12</strong> 应用程序重新启动<br><strong>HTTP 500-13</strong> - 服务器太忙<br><strong>HTTP 500-14</strong> - 应用程序无效<br><strong>HTTP 500-15</strong> - 不允许请求 </li>
<li><strong>501</strong>实现</li>
<li><strong>502</strong>关错误</li>
<li><strong>503</strong>务不可用</li>
<li><strong>504</strong>关超时</li>
</ul>
</blockquote>
<h2 id="九、HTTP状态保持"><a href="#九、HTTP状态保持" class="headerlink" title="九、HTTP状态保持"></a>九、HTTP状态保持</h2><p>   HTTP 协议本身是无状态的，这与HTTP协议本来的目的是相符的，客户端只需要简单的向服务器请求下载某些文件，无论是客户端还是服务器都没有必要纪录彼此过去的行为，每一次请求之间都是独立的，好比一个顾客和一个自动售货机或者一个普通的（非会员制）大卖场之间的关系一样。</p>
<p>   然而聪明（或者贪心？）的人们很快发现如果能够提供一些按需生成的动态信息会使web变得更加有用，就像给有线电视加上点播功能一样。这种需求一方面迫使HTML逐步添加了表单、脚本、DOM等客户端行为，另一方面在服务器端则出现了CGI规范以响应客户端的动态请求，作为传输载体的HTTP协议也添加了文件上载、 cookie这些特性。其中cookie的作用就是为了解决HTTP协议无状态的缺陷所作出的努力。至于后来出现的session机制则是又一种在客户端与服务器之间保持状态的解决方案。</p>
<p>Cookie和Session都为了用来保存状态信息，都是保存客户端状态的机制，它们都是为了解决HTTP无状态的问题而所做的努力。</p>
<p>Session可以用Cookie来实现，也可以用URL回写的机制来实现。用Cookie来实现的Session可以认为是对Cookie更高级的应用。</p>
<h3 id="Cookie和Session区别"><a href="#Cookie和Session区别" class="headerlink" title="Cookie和Session区别"></a>Cookie和Session区别</h3><ul>
<li><p>1.Cookie将状态保存在客户端，Session将状态保存在服务器端；</p>
</li>
<li><p>2.Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。Cookie最早在RFC2109中实现，后续RFC2965做了增强。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies。Session并没有在HTTP的协议中定义；</p>
</li>
<li><p>3.Session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器；</p>
</li>
<li><p>4.就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的SESSION机制更安全些.因为它不会任意读取客户存储的信息。</p>
</li>
</ul>
<h3 id="Session机制"><a href="#Session机制" class="headerlink" title="Session机制"></a>Session机制</h3><p>Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p>
<p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为 session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个 session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 session id将被在本次响应中返回给客户端保存。</p>
<h3 id="Session的实现方式"><a href="#Session的实现方式" class="headerlink" title="Session的实现方式"></a>Session的实现方式</h3><p><strong>使用Cookie来实现：</strong><br>服务器给每个Session分配一个唯一的JSESSIONID，并通过Cookie发送给客户端。</p>
<p>当客户端发起新的请求的时候，将在Cookie头中携带这个JSESSIONID。这样服务器能够找到这个客户端对应的Session。</p>
<p>流程如下图所示：<br><img src="http://s3.51cto.com/wyfs02/M00/38/13/wKiom1OyXoHjWI2aAABsbAEnTIs272.jpg" alt="session"><br><strong>使用URL回显来实现</strong><br>URL回写是指服务器在发送给浏览器页面的所有链接中都携带JSESSIONID的参数，这样客户端点击任何一个链接都会把JSESSIONID带会服务器。</p>
<p>如果直接在浏览器输入服务端资源的url来请求该资源，那么Session是匹配不到的。</p>
<p>Tomcat对Session的实现，是一开始同时使用Cookie和URL回写机制，如果发现客户端支持Cookie，就继续使用Cookie，停止使用URL回写。如果发现Cookie被禁用，就一直使用URL回写。jsp开发处理到Session的时候，对页面中的链接记得使用response.encodeURL()。 </p>
<h3 id="与Cookie相关的HTTP扩展头"><a href="#与Cookie相关的HTTP扩展头" class="headerlink" title="与Cookie相关的HTTP扩展头"></a>与Cookie相关的HTTP扩展头</h3><ul>
<li>1.<strong>Cookie</strong>：客户端将服务器设置的Cookie返回到服务器；</li>
<li>2.<strong>Set-Cookie</strong>：服务器向客户端设置Cookie；</li>
<li>3.<strong>Cookie2 (RFC2965)）</strong>：客户端指示服务器支持Cookie的版本；</li>
<li>4.**Set-Cookie2 (RFC2965)**：服务器向客户端设置Cookie。</li>
</ul>
<h3 id="Cookie的流程"><a href="#Cookie的流程" class="headerlink" title="Cookie的流程"></a>Cookie的流程</h3><p>服务器在响应消息中用Set-Cookie头将Cookie的内容回送给客户端，客户端在新的请求中将相同的内容携带在Cookie头中发送给服务器。从而实现会话的保持。</p>
<p>   流程如下图所示：<br><img src="http://s3.51cto.com/wyfs02/M00/38/13/wKioL1OyX1-jc2HfAABcl6JnHeo234.jpg" alt="cookie">   </p>
<h2 id="十、Web缓存"><a href="#十、Web缓存" class="headerlink" title="十、Web缓存"></a>十、Web缓存</h2><h3 id="什么是Web缓存"><a href="#什么是Web缓存" class="headerlink" title="什么是Web缓存"></a>什么是Web缓存</h3><p>  WEB缓存(cache)位于Web服务器和客户端之间。</p>
<p>  缓存会根据请求保存输出内容的副本，例如html页面，图片，文件，当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。</p>
<p>  HTTP协议定义了相关的消息头来使WEB缓存尽可能好的工作。</p>
<h3 id="Web缓存的优点"><a href="#Web缓存的优点" class="headerlink" title="Web缓存的优点"></a>Web缓存的优点</h3><ul>
<li><ol>
<li><strong>减少相应延迟</strong>：因为请求从缓存服务器（离客户端更近）而不是源服务器被相应，这个过程耗时更少，让web服务器看上去相应更快。</li>
</ol>
</li>
<li><ol start="2">
<li><strong>减少网络带宽消耗</strong>：当副本被重用时会减低客户端的带宽消耗；客户可以节省带宽费用，控制带宽的需求的增长并更易于管理。</li>
</ol>
</li>
</ul>
<h3 id="与缓存相关的HTTP消息头"><a href="#与缓存相关的HTTP消息头" class="headerlink" title="与缓存相关的HTTP消息头"></a>与缓存相关的HTTP消息头</h3><blockquote>
<ul>
<li><strong>Expires</strong>：指示响应内容过期的时间，格林威治时间GMT</li>
<li><strong>Cache-Control</strong>：更细致的控制缓存的内容</li>
<li><strong>Last-Modified</strong>：响应中资源最后一次修改的时间</li>
<li><strong>ETag</strong>：响应中资源的校验值，在服务器上某个时段是唯一标识的。</li>
<li><strong>Date</strong>：服务器的时间</li>
<li><strong>If-Modified-Since</strong>：客户端存取的该资源最后一次修改的时间，同Last-Modified。</li>
<li><strong>If-None-Match</strong>：客户端存取的该资源的检验值，同ETag。</li>
</ul>
</blockquote>
<h3 id="客户端缓存生效的常见流程"><a href="#客户端缓存生效的常见流程" class="headerlink" title="客户端缓存生效的常见流程"></a>客户端缓存生效的常见流程</h3><p>服务器收到请求时，会在200 OK中回送该资源的Last-Modified和ETag头，客户端将该资源保存在cache中，并记录这两个属性。当客户端需要发送相同的请求时，会在请求中携带If-Modified-Since和If-None-Match两个头。两个头的值分别是响应中Last-Modified和ETag头的值。服务器通过这两个头判断本地资源未发生变化，客户端不需要重新下载，返回304响应。</p>
<p>常见流程如下图所示：<br><img src="http://s3.51cto.com/wyfs02/M02/38/13/wKioL1OyYpTBYuovAABlmj5y42w797.jpg" alt="缓存">   </p>
<h3 id="Web缓存机制"><a href="#Web缓存机制" class="headerlink" title="Web缓存机制"></a>Web缓存机制</h3><p>HTTP/1.1中缓存的目的是为了在很多情况下减少发送请求，同时在许多情况下可以不需要发送完整响应。前者减少了网络回路的数量；HTTP利用一个“过期（expiration）”机制来为此目的。后者减少了网络应用的带宽；HTTP用“验证（validation）”机制来为此目的。</p>
<p><strong>HTTP定义了3种缓存机制</strong>：</p>
<blockquote>
<ul>
<li>1.<strong>Freshness</strong>：允许一个回应消息可以在源服务器不被重新检查，并且可以由服务器和客户端来控制。例如，Expires回应头给了一个文档不可用的时间。Cache-Control中的max-age标识指明了缓存的最长时间；</li>
<li>2.<strong>Validation</strong>：用来检查以一个缓存的回应是否仍然可用。例如，如果一个回应有一个Last-Modified回应头，缓存能够使用If-Modified-Since来判断是否已改变，以便判断根据情况发送请求；</li>
<li>3.<strong>Invalidation</strong>： 在另一个请求通过缓存的时候，常常有一个副作用。例如，如果一个URL关联到一个缓存回应，但是其后跟着POST、PUT和DELETE的请求的话，缓存就会过期。</li>
</ul>
</blockquote>
<h2 id="十一、HTTP代理服务器"><a href="#十一、HTTP代理服务器" class="headerlink" title="十一、HTTP代理服务器"></a>十一、HTTP代理服务器</h2><p>代理服务器英文全称是Proxy Server，其功能就是代理网络用户去取得网络信息。形象的说：它是网络信息的中转站。</p>
<p>代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。</p>
<p>而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。</p>
<p>更重要的是：Proxy Server(代理服务器)是Internet链路级网关所提供的一种重要的安全功能，它的工作主要在开放系统互联(OSI)模型的对话层。</p>
<h3 id="HTTP代理服务器的主要功能"><a href="#HTTP代理服务器的主要功能" class="headerlink" title="HTTP代理服务器的主要功能"></a>HTTP代理服务器的主要功能</h3><ul>
<li><p>1.突破自身IP访问限制，访问国外站点。如：教育网、169网等网络用户可以通过代理访问国外网站；</p>
</li>
<li><p>2.访问一些单位或团体内部资源，如某大学FTP(前提是该代理地址在该资源的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育 网开放的各类FTP下载上传，以及各类资料查询共享等服务；</p>
</li>
<li><p>3.突破中国电信的IP封锁：中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。所以不能访问时可以换一个国 外的代理服务器试试；</p>
</li>
<li><p>4.提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度；</p>
</li>
<li><p>5.隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。</p>
</li>
</ul>
<p>HTTP代理图示：<br><img src="http://s3.51cto.com/wyfs02/M01/38/14/wKioL1OyZMLCGz4sAABIrUX08kc751.jpg" alt="代理"><br>对于客户端浏览器而言，http代理服务器相当于服务器。<br>而对于Web服务器而言，http代理服务器又担当了客户端的角色。</p>
<h2 id="十二、虚拟主机的实现"><a href="#十二、虚拟主机的实现" class="headerlink" title="十二、虚拟主机的实现"></a>十二、虚拟主机的实现</h2><h3 id="什么是虚拟主机"><a href="#什么是虚拟主机" class="headerlink" title="什么是虚拟主机"></a>什么是虚拟主机</h3><p>  虚拟主机：是在网络服务器上划分出一定的磁盘空间供用户放置站点、应用组件等，提供必要的站点功能与数据存放、传输功能。  </p>
<p>  所谓虚拟主机，也叫“网站空间”就是把一台运行在互联网上的服务器划分成多个“虚拟”的服务器，每一个虚拟主机都具有独立的域名和完整的Internet服务器（支持WWW、FTP、E-mail等）功能。一台服务器上的不同虚拟主机是各自独立的，并由用户自行管理。但一台服务器主机只能够支持一定数量的虚拟主机，当超过这个数量时，用户将会感到性能急剧下降。</p>
<h3 id="虚拟主机的实现原理"><a href="#虚拟主机的实现原理" class="headerlink" title="虚拟主机的实现原理"></a>虚拟主机的实现原理</h3><p>  虚拟主机是用同一个WEB服务器，为不同域名网站提供服务的技术。Apache、Tomcat等均可通过配置实现这个功能。<br>  相关的HTTP消息头：Host。<br>  例如：Host: <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a><br>  客户端发送HTTP请求的时候，会携带Host头，Host头记录的是客户端输入的域名。这样服务器可以根据Host头确认客户要访问的是哪一个域名。</p>
<p>节选自 <a target="_blank" rel="noopener" href="http://blog.51cto.com/shjia/1432670">Apache之HTTP协议</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/19/90-%E3%80%90HTTP%E5%8D%8F%E8%AE%AE%E3%80%91Apache%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE/" data-id="ckts3ejzt00r84d9k7pvs7xr2" data-title="90-【HTTP】Apache之HTTP协议" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP%E5%8D%8F%E8%AE%AE/" rel="tag">HTTP协议</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-89-【JavaScript】js中GET和POST区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/18/89-%E3%80%90JavaScript%E3%80%91js%E4%B8%ADGET%E5%92%8CPOST%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2018-09-18T13:41:17.000Z" itemprop="datePublished">2018-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/18/89-%E3%80%90JavaScript%E3%80%91js%E4%B8%ADGET%E5%92%8CPOST%E5%8C%BA%E5%88%AB/">89-【JavaScript】js中GET和POST区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#105;&#110;&#103;&#x61;&#110;&#56;&#x37;&#x38;&#55;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;">&#x70;&#105;&#110;&#103;&#x61;&#110;&#56;&#x37;&#x38;&#55;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章</td>
<td><a target="_blank" rel="noopener" href="https://0x9.me/KMrv3">https://0x9.me/KMrv3</a></td>
</tr>
</tbody></table>
<hr>
<p>在常见的客户端传递参数的方式有<code>GET</code>和<code>POST</code>两种：  </p>
<ul>
<li><strong>浏览器地址栏直接输入</strong>：一定是<code>GET</code>请求；</li>
<li><strong>超链接</strong>：一定是<code>GET</code>请求；</li>
<li><strong>表单</strong>：可以是<code>GET</code>，也可以是<code>POST</code>，这取决与<code>&lt;form&gt;</code>的<code>method</code>属性值；</li>
</ul>
<h3 id="两者区别："><a href="#两者区别：" class="headerlink" title="两者区别："></a>两者区别：</h3><h4 id="1-效率"><a href="#1-效率" class="headerlink" title="1.效率"></a>1.效率</h4><ul>
<li><code>GET</code>的意思是 <code>得</code> ，从服务器获取数据（也可以上传数据，参数就是），效率较高；  </li>
<li><code>POST</code>的意思是 <code>给</code> ，但可以向服务器发送数据和下载数据，效率不如<code>GET</code>；    </li>
</ul>
<h4 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2.缓存"></a>2.缓存</h4><ul>
<li><code>GET</code> 请求能够被缓存，默认的请求方式也是有缓存的；  </li>
<li><code>POST</code> 请求默认不会缓存；  </li>
</ul>
<blockquote>
<ul>
<li>缓存是针对<code>URL</code>来进行缓存的，<code>GET</code>请求由于其参数是直接加在<code>URL</code>上的，一种参数组合就有一种URL的缓存，可以根据参数来进行一一对应，重复请求是幂等的（不论请求多少次，结果都一样）;    </li>
<li>而POST请求的URL没有参数,每次请求的URL都相同，数据体（HTTPBody）可能不同，无法一一对应，所以缓存没有意义；  </li>
</ul>
</blockquote>
<h4 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3.安全性"></a>3.安全性</h4><ul>
<li><code>GET</code> 的所有参数全部包装在<code>URL</code>中，明文显示，且服务器的访问日志会记录，非常不安全；  </li>
<li><code>POST</code> 的<code>URL</code>中只有资源路径，不包含参数，参数封装在二进制的数据体中，服务器也不会记录参数，相对安全。所有涉及用户隐私的数据都要用 <code>POST</code> 传输；  </li>
</ul>
<blockquote>
<p><code>POST</code>的安全是<strong>相对的</strong>，对于普通用户来说他们看不到明文，数据封装对他们来说就是屏障。但是对于专业人士，它们会抓包会分析，没有加密的数据包对他们来说也是小case。所以POST仅仅是相对安全，唯有对数据进行加密才会更安全。当然加密也有被破解的可能性，<strong>理论上所有的加密方式都可以破解</strong>，只是时间长短的问题。而加密算法要做的就是使得破解需要的时间尽量长，越长越安全。由于我们也需要解密，加密算法太过复杂也并非好事，这就要结合使用情况进行折中或者足够实际使用即可。绕的有点远，具体的话，我将在后续的文章之中介提及，并介绍一些常用的加密算法。   </p>
</blockquote>
<h4 id="4-数据量"><a href="#4-数据量" class="headerlink" title="4.数据量"></a>4.数据量</h4><p><code>HTTP</code>协议中均没有对<code>GET</code>和<code>POST</code>请求的<strong>数据大小</strong>进行限制，但是实际应用中它们通常受限于软硬件平台的设计和性能。  </p>
<ul>
<li><code>GET</code>：不同的浏览器和服务器不同，一般限制在<code>2~8K</code>之间，更加常见的是<code>1k</code>以内；   </li>
<li><code>POST</code>：提交的数据较大，大小靠服务器的设定值限制，PHP默认是<code>2M</code>（具体的话大家以后看后端给的开发文档就行了）；    </li>
</ul>
<h4 id="5-数据获取方式"><a href="#5-数据获取方式" class="headerlink" title="5.数据获取方式"></a>5.数据获取方式</h4><ul>
<li><code>GET</code> 需要使用<code>Request.QueryString</code>来取得变量的值；  </li>
<li><code>POST</code> 通过 <code>Request.Form</code> 来获取变量的值；  </li>
</ul>
<p>也就是说 <code>Get</code> 是通过<strong>地址栏</strong>来传值，而 <code>Post</code> 是通过<strong>提交表单</strong>来传值。  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/18/89-%E3%80%90JavaScript%E3%80%91js%E4%B8%ADGET%E5%92%8CPOST%E5%8C%BA%E5%88%AB/" data-id="ckts3ejw700b44d9k51v7dj7j" data-title="89-【JavaScript】js中GET和POST区别" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-88-【Vuejs】Vuejs面试中常问知识点整理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/17/88-%E3%80%90Vuejs%E3%80%91Vuejs%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E9%97%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2018-09-17T11:19:10.000Z" itemprop="datePublished">2018-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/17/88-%E3%80%90Vuejs%E3%80%91Vuejs%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E9%97%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">88-【Vuejs】Vuejs面试中常问知识点整理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#112;&#x69;&#110;&#103;&#x61;&#x6e;&#x38;&#55;&#56;&#55;&#64;&#113;&#x71;&#x2e;&#99;&#111;&#109;">&#112;&#x69;&#110;&#103;&#x61;&#x6e;&#x38;&#55;&#56;&#55;&#64;&#113;&#x71;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章</td>
<td><a target="_blank" rel="noopener" href="https://0x9.me/KMrv3">https://0x9.me/KMrv3</a></td>
</tr>
</tbody></table>
<hr>
<p>看看面试题，只是为了查漏补缺，看看自己那些方面还不懂。切记不要以为背了面试题，就万事大吉了，最好是理解背后的原理，这样面试的时候才能侃侃而谈。不然，稍微有水平的面试官一看就能看出，是否有真才实学还是刚好背中了这道面试题（有空再把例子中代码补上）。  </p>
<h2 id="一、对于MVVM的理解？"><a href="#一、对于MVVM的理解？" class="headerlink" title="一、对于MVVM的理解？"></a>一、对于MVVM的理解？</h2><p>MVVM 是 Model-View-ViewModel 的缩写。  </p>
<ul>
<li><strong>Model</strong> 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。</li>
<li><strong>View</strong> 代表UI 组件，它负责将数据模型转化成UI 展现出来。</li>
<li><strong>ViewModel</strong> 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。  </li>
</ul>
<p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。  </p>
<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。  </p>
<h2 id="二、Vue的生命周期"><a href="#二、Vue的生命周期" class="headerlink" title="二、Vue的生命周期"></a>二、Vue的生命周期</h2><p>**<code>beforeCreate</code>**（创建前），在数据观测和初始化事件还未开始</p>
<p>**<code>created</code>**（创建后），完成数据观测，属性和方法的运算，初始化事件， <code>$el</code> 属性还没有显示出来</p>
<p>**<code>beforeMount</code>**（载入前），在挂载开始之前被调用，相关的<code>render</code>函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</p>
<p>**<code>mounted</code>**（载入后），在 <code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换<code>el</code>属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</p>
<p>**<code>beforeUpdate</code>**（更新前），在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</p>
<p>**<code>updated</code>**（更新后），在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</p>
<p>**<code>beforeDestroy</code>**（销毁前），在实例销毁之前调用。实例仍然完全可用。</p>
<p>**<code>destroyed</code>**（销毁后），在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p>
<h3 id="1、什么是vue生命周期？"><a href="#1、什么是vue生命周期？" class="headerlink" title="1、什么是vue生命周期？"></a>1、什么是vue生命周期？</h3><p>答： Vue 实例从创建到销毁的过程，就是生命周期。从<code>开始创建</code>、<code>初始化数据</code>、<code>编译模板</code>、<code>挂载Dom→渲染</code>、<code>更新→渲染</code>、<code>销毁</code>等一系列过程，称之为 Vue 的<strong>生命周期</strong>。</p>
<h3 id="2、vue生命周期的作用是什么？"><a href="#2、vue生命周期的作用是什么？" class="headerlink" title="2、vue生命周期的作用是什么？"></a>2、vue生命周期的作用是什么？</h3><p>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p>
<h3 id="3、vue生命周期总共有几个阶段？"><a href="#3、vue生命周期总共有几个阶段？" class="headerlink" title="3、vue生命周期总共有几个阶段？"></a>3、vue生命周期总共有几个阶段？</h3><p>答：它可以总共分为8个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。</p>
<h3 id="4、第一次页面加载会触发哪几个钩子？"><a href="#4、第一次页面加载会触发哪几个钩子？" class="headerlink" title="4、第一次页面加载会触发哪几个钩子？"></a>4、第一次页面加载会触发哪几个钩子？</h3><p>答：会触发下面这几个<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code> 。</p>
<h3 id="5、DOM-渲染在哪个周期中就已经完成？"><a href="#5、DOM-渲染在哪个周期中就已经完成？" class="headerlink" title="5、DOM 渲染在哪个周期中就已经完成？"></a>5、DOM 渲染在哪个周期中就已经完成？</h3><p>答：DOM 渲染在 <code>mounted</code> 中就已经完成了。  </p>
<h2 id="三、-Vue实现数据双向绑定的原理："><a href="#三、-Vue实现数据双向绑定的原理：" class="headerlink" title="三、 Vue实现数据双向绑定的原理："></a>三、 Vue实现数据双向绑定的原理：</h2><p>原理：**<code>Object.defineProperty()</code>**<br>vue实现数据双向绑定主要是：<br>采用 <strong>数据劫持</strong> 结合 <strong>发布者-订阅者模式</strong> 的方式，通过 <strong><code>Object.defineProperty()</code></strong> 来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 <strong><code>Object.defineProperty()</code></strong> 将它们转为 <code>getter/setter</code>。用户看不到 <code>getter/setter</code>，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。  </p>
<p>vue的数据双向绑定:<br>将MVVM作为数据绑定的入口，整合<code>Observer</code>，<code>Compile</code>和<code>Watcher</code>三者，通过<code>Observer</code>来监听自己的<code>model</code>的数据变化，通过<code>Compile</code>来解析编译模板指令（vue中是用来解析 <strong><code>双花括号</code></strong> ），最终利用<code>watcher</code>搭起<code>observer</code>和<code>Compile</code>之间的通信桥梁，达到<strong>数据变化 —&gt;视图更新</strong>；视图交互变化（input）—&gt;数据model变更双向绑定效果。    </p>
<p>js实现简单的双向绑定：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> obj = &#123;&#125;</span></span><br><span class="line"><span class="javascript">   <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;txt&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">       <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">           <span class="keyword">return</span> obj</span></span><br><span class="line"><span class="javascript">       &#125;,</span></span><br><span class="line"><span class="javascript">       <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">           <span class="built_in">document</span>.getElementById(<span class="string">&#x27;txt&#x27;</span>).value = newValue</span></span><br><span class="line"><span class="javascript">           <span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>).innerHTML = newValue</span></span><br><span class="line"><span class="javascript">       &#125;</span></span><br><span class="line"><span class="javascript">   &#125;)</span></span><br><span class="line"><span class="javascript">   <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">       obj.txt = e.target.value</span></span><br><span class="line"><span class="javascript">   &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="四、Vue组件间的参数传递"><a href="#四、Vue组件间的参数传递" class="headerlink" title="四、Vue组件间的参数传递"></a>四、Vue组件间的参数传递</h2><h3 id="1、父组件与子组件传值"><a href="#1、父组件与子组件传值" class="headerlink" title="1、父组件与子组件传值"></a>1、父组件与子组件传值</h3><p>父组件传给子组件：子组件通过<code>props</code>方法接受数据；</p>
<p>子组件传给父组件： <code>$emit</code> 方法传递参数；</p>
<h3 id="2、非父子组件间的数据传递，兄弟组件传值"><a href="#2、非父子组件间的数据传递，兄弟组件传值" class="headerlink" title="2、非父子组件间的数据传递，兄弟组件传值"></a>2、非父子组件间的数据传递，兄弟组件传值</h3><p><code>eventBus</code>，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道）。  </p>
<h2 id="五、Vue的路由实现：hash模式-和-history模式"><a href="#五、Vue的路由实现：hash模式-和-history模式" class="headerlink" title="五、Vue的路由实现：hash模式 和 history模式"></a>五、Vue的路由实现：hash模式 和 history模式</h2><p><strong>hash模式</strong>：在浏览器中符号 <code>#</code>，#以及#后面的字符称之为<code>hash</code>，用 <code>window.location.hash</code> 读取。<br>特点：<code>hash</code>虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，<code>hash</code>不会重加载页面。  </p>
<p><strong>history模式</strong>：<code>history</code>采用HTML5的新特性；且提供了两个新方法： <code>pushState()</code>， <code>replaceState()</code>可以对浏览器历史记录栈进行修改，以及<code>popState</code>事件的监听到状态变更。  </p>
<h2 id="六、Vue与Angular以及React的区别？"><a href="#六、Vue与Angular以及React的区别？" class="headerlink" title="六、Vue与Angular以及React的区别？"></a>六、Vue与Angular以及React的区别？</h2><p>版本在不断更新，以下的区别有可能不是很正确。我工作中只用到vue，对angular和react不怎么熟。  </p>
<h3 id="1、与AngularJS的区别"><a href="#1、与AngularJS的区别" class="headerlink" title="1、与AngularJS的区别"></a>1、与AngularJS的区别</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><ul>
<li>都支持指令：内置指令和自定义指令；</li>
<li>都支持过滤器：内置过滤器和自定义过滤器；</li>
<li>都支持双向数据绑定；</li>
<li>都不支持低端浏览器。</li>
</ul>
<h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><ul>
<li>AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；</li>
<li>在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；</li>
<li>Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。</li>
</ul>
<h3 id="2、与React的区别"><a href="#2、与React的区别" class="headerlink" title="2、与React的区别"></a>2、与React的区别</h3><h4 id="相同点：-1"><a href="#相同点：-1" class="headerlink" title="相同点："></a>相同点：</h4><ul>
<li>React采用特殊的<code>JSX</code>语法，Vue.js在组件开发中也推崇编写<code>.vue</code>特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；   </li>
<li>中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；   </li>
<li>都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；  </li>
<li>在组件开发中都支持<code>mixins</code>的特性。   </li>
</ul>
<h4 id="不同点：-1"><a href="#不同点：-1" class="headerlink" title="不同点："></a>不同点：</h4><ul>
<li>React采用的Virtual DOM会对渲染出来的结果做脏检查；  </li>
<li>Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。  </li>
</ul>
<h2 id="七、vue路由的钩子函数"><a href="#七、vue路由的钩子函数" class="headerlink" title="七、vue路由的钩子函数"></a>七、vue路由的钩子函数</h2><p>首页可以控制导航跳转，<code>beforeEach</code>，<code>afterEach</code>等，一般用于页面<code>title</code>的修改。一些需要登录才能调整页面的重定向功能。  </p>
<p><strong>beforeEach</strong>主要有3个参数<code>to</code>，<code>from</code>，<code>next</code>。<br>**<code>to</code>**：route即将进入的目标路由对象。<br>**<code>from</code>**：route当前导航正要离开的路由。<br>**<code>next</code>**：function一定要调用该方法<code>resolve</code>这个钩子。执行效果依赖<code>next</code>方法的调用参数。可以控制网页的跳转。  </p>
<h2 id="八、vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#八、vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="八、vuex是什么？怎么使用？哪种功能场景使用它？"></a>八、vuex是什么？怎么使用？哪种功能场景使用它？</h2><p>只用来读取的状态集中放在<code>store</code>中；<br>改变状态的方式是提交<code>mutations</code>，这是个同步的事物；<br>异步逻辑应该封装在<code>action</code>中。  </p>
<p>在<code>main.js</code>引入<code>store</code>，注入。新建了一个目录<code>store</code>，<code>… export</code> 。  </p>
<p>场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车。<br><img src="http://images.pingan8787.com/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="vue生命周期">   </p>
<p><strong>state</strong>：Vuex 使用单一状态树,即每个应用将仅仅包含一个<code>store</code> 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</p>
<p><strong>mutations</strong>：<code>mutations</code>定义的方法动态修改<code>Vuex </code>的 <code>store</code> 中的状态或数据。</p>
<p><strong>getters</strong>：类似<code>vue</code>的计算属性，主要用来过滤一些数据。</p>
<p><strong>action</strong>：<code>actions</code>可以理解为通过将<code>mutations</code>里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。<code>view</code> 层通过<code> store.dispath</code> 来分发 <code>action</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">onst store = <span class="keyword">new</span> Vuex.Store(&#123; <span class="comment">//store实例</span></span><br><span class="line">     <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">     <span class="attr">mutations</span>: &#123;                </span><br><span class="line">        increment (state) &#123;</span><br><span class="line">         state.count++</span><br><span class="line">        &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">     <span class="attr">actions</span>: &#123; </span><br><span class="line">        increment (context) &#123;</span><br><span class="line">         context.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>modules</strong>：项目特别复杂的时候，可以让每一个模块拥有自己的<code>state</code>、<code>mutation</code>、<code>action</code>、<code>getters</code>，使得结构非常清晰，方便管理。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line"> <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line"> <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line"> <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line"> <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line"> <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line"> <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line"> <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"> <span class="attr">modules</span>: &#123;</span><br><span class="line">   <span class="attr">a</span>: moduleA,</span><br><span class="line">   <span class="attr">b</span>: moduleB</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="九、其它小知识点"><a href="#九、其它小知识点" class="headerlink" title="九、其它小知识点"></a>九、其它小知识点</h2><h3 id="1、css只在当前组件起作用"><a href="#1、css只在当前组件起作用" class="headerlink" title="1、css只在当前组件起作用"></a>1、css只在当前组件起作用</h3><p>答：在<code>style</code>标签中写入<code>scoped</code>即可 例如： <code>&lt;style scoped&gt;&lt;/style&gt;</code></p>
<h3 id="2、v-if-和-v-show-区别"><a href="#2、v-if-和-v-show-区别" class="headerlink" title="2、v-if 和 v-show 区别"></a>2、<code>v-if</code> 和 <code>v-show</code> 区别</h3><p>答：<code>v-if</code>按照条件是否渲染，<code>v-show</code>是<code>display</code>的<code>block</code>或<code>none</code>；</p>
<h3 id="3、-route和-router的区别"><a href="#3、-route和-router的区别" class="headerlink" title="3、$route和$router的区别"></a>3、<code>$route</code>和<code>$router</code>的区别</h3><p>答：<code>$route</code>是 <code>路由信息对象</code>，包括<code>path</code>，<code>params</code>，<code>hash</code>，<code>query</code>，<code>fullPath</code>，<code>matched</code>，<code>name</code>等路由信息参数。而<code>$router</code>是 <code>路由实例</code> 对象包括了路由的跳转方法，钩子函数等。  </p>
<p>PS：缺少的案例代码，这几天再补上去。有些地方可能描述的不够清楚，如果有歧义，可能是我理解错了。  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/17/88-%E3%80%90Vuejs%E3%80%91Vuejs%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E9%97%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" data-id="ckts3ejw700b24d9k3eno06nb" data-title="88-【Vuejs】Vuejs面试中常问知识点整理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vuejs/" rel="tag">Vuejs</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/13/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/15/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/" rel="tag">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS%E5%8A%A8%E7%94%BB/" rel="tag">CSS动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome/" rel="tag">Chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6-ES7-ES8/" rel="tag">ES6/ES7/ES8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eslint/" rel="tag">Eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Express/" rel="tag">Express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GraphQL/" rel="tag">GraphQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/H5/" rel="tag">H5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP%E5%8D%8F%E8%AE%AE/" rel="tag">HTTP协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hybrid/" rel="tag">Hybrid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NPM/" rel="tag">NPM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Numpy/" rel="tag">Numpy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/" rel="tag">Tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TyeScript/" rel="tag">TyeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vuejs/" rel="tag">Vuejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/" rel="tag">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/demo/" rel="tag">demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" rel="tag">人工智能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/" rel="tag">全栈开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2/" rel="tag">前端探索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97/" rel="tag">前端知乎系列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/" rel="tag">常用技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" rel="tag">微前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" rel="tag">构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB/" rel="tag">源码精读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%83%AD%E9%97%A8/" rel="tag">热门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/" rel="tag">生活杂记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" rel="tag">网络请求</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E6%B8%A9%E5%9F%BA%E7%A1%80/" rel="tag">重温基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Angular/" style="font-size: 11.88px;">Angular</a> <a href="/tags/CSS/" style="font-size: 18.13px;">CSS</a> <a href="/tags/CSS%E5%8A%A8%E7%94%BB/" style="font-size: 12.5px;">CSS动画</a> <a href="/tags/Chrome/" style="font-size: 10px;">Chrome</a> <a href="/tags/ES6-ES7-ES8/" style="font-size: 10.63px;">ES6/ES7/ES8</a> <a href="/tags/Eslint/" style="font-size: 10px;">Eslint</a> <a href="/tags/Express/" style="font-size: 10px;">Express</a> <a href="/tags/GraphQL/" style="font-size: 10px;">GraphQL</a> <a href="/tags/H5/" style="font-size: 10px;">H5</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/HTTP/" style="font-size: 11.88px;">HTTP</a> <a href="/tags/HTTP%E5%8D%8F%E8%AE%AE/" style="font-size: 11.25px;">HTTP协议</a> <a href="/tags/Hybrid/" style="font-size: 10.63px;">Hybrid</a> <a href="/tags/JavaScript/" style="font-size: 19.38px;">JavaScript</a> <a href="/tags/NPM/" style="font-size: 10px;">NPM</a> <a href="/tags/Nodejs/" style="font-size: 11.25px;">Nodejs</a> <a href="/tags/Numpy/" style="font-size: 10.63px;">Numpy</a> <a href="/tags/Python/" style="font-size: 17.5px;">Python</a> <a href="/tags/React/" style="font-size: 12.5px;">React</a> <a href="/tags/Tensorflow/" style="font-size: 10.63px;">Tensorflow</a> <a href="/tags/TyeScript/" style="font-size: 10px;">TyeScript</a> <a href="/tags/TypeScript/" style="font-size: 11.25px;">TypeScript</a> <a href="/tags/Vuejs/" style="font-size: 14.38px;">Vuejs</a> <a href="/tags/WebSocket/" style="font-size: 10px;">WebSocket</a> <a href="/tags/Webpack/" style="font-size: 15.63px;">Webpack</a> <a href="/tags/demo/" style="font-size: 10.63px;">demo</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">中间件</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 16.25px;">人工智能</a> <a href="/tags/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/" style="font-size: 11.25px;">全栈开发</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 20px;">前端开发</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2/" style="font-size: 11.25px;">前端探索</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97/" style="font-size: 10.63px;">前端知乎系列</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 18.75px;">原创</a> <a href="/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/" style="font-size: 10.63px;">常用技术</a> <a href="/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">微前端</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 13.75px;">总结</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">机器学习</a> <a href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" style="font-size: 10.63px;">构建工具</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10.63px;">正则表达式</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 10px;">源码</a> <a href="/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB/" style="font-size: 10px;">源码精读</a> <a href="/tags/%E7%83%AD%E9%97%A8/" style="font-size: 10px;">热门</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/" style="font-size: 10px;">生活杂记</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.13px;">算法</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 10px;">编译原理</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" style="font-size: 10px;">网络请求</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.38px;">读书笔记</a> <a href="/tags/%E9%87%8D%E6%B8%A9%E5%9F%BA%E7%A1%80/" style="font-size: 16.88px;">重温基础</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 10px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/28/227-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8SVG%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/">227-【总结】如何优雅的在微信小程序使用SVG字体图标</a>
          </li>
        
          <li>
            <a href="/2021/07/28/226-%E3%80%90HTTP%E3%80%91%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9F/">226-【HTTP】如何优雅的管理HTTP请求和响应拦截器？</a>
          </li>
        
          <li>
            <a href="/2021/07/28/225-%E3%80%90Vue%E3%80%91%E4%BB%8E%E6%89%8B%E5%86%99Vue3%E7%9A%84Reactivity%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%85%A5Vue3%E6%BA%90%E7%A0%81/">225-【Vue】从手写Vue3的Reactivity开始深入Vue3源码</a>
          </li>
        
          <li>
            <a href="/2021/05/30/224-%E3%80%90Chrome%E3%80%915%E4%B8%AAChrome%E8%B0%83%E8%AF%95%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7/">224-【Chrome】5个Chrome调试混合应用的技巧</a>
          </li>
        
          <li>
            <a href="/2021/03/19/223-%E3%80%90%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2%E3%80%91%E6%8E%A2%E7%B4%A2Snabbdom%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">223-【前端探索】探索Snabbdom模块系统原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>