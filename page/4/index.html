<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-197-【JavaScript】JS自定义事件如此简单！" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/22/197-%E3%80%90JavaScript%E3%80%91JS%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95%EF%BC%81/" class="article-date">
  <time class="dt-published" datetime="2020-02-22T07:02:09.000Z" itemprop="datePublished">2020-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/22/197-%E3%80%90JavaScript%E3%80%91JS%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95%EF%BC%81/">197-【JavaScript】JS自定义事件如此简单！</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在前端开发世界中，JavaScript 和 HTML 之间往往通过 <strong>事件</strong> 来实现交互。其中多数为内置事件，本文主要介绍 JS<strong>自定义事件概念和实现方式</strong>，并结合案例详细分析自定义事件的原理、功能、应用及注意事项。</p>
<h1 id="📚一、什么是自定义事件"><a href="#📚一、什么是自定义事件" class="headerlink" title="📚一、什么是自定义事件"></a>📚一、什么是自定义事件</h1><p>在日常开发中，我们习惯监听页面许多事件，诸如：点击事件（ <code>click</code> ）、鼠标移动事件（ <code>mousemove</code> ）、元素失去焦点事件（ <code>blur</code> ）等等。<br /><br><br />事件本质是一种通信方式，是一种消息，只有在多对象多模块时，才有可能需要使用事件进行通信。在多模块化开发时，可以使用<strong>自定义事件</strong>进行模块间通信。<br /><br><br />当某些基础事件无法满足我们业务，就可以尝试 <strong>自定义事件</strong>来解决。</p>
<h1 id="📚二、实现方式介绍"><a href="#📚二、实现方式介绍" class="headerlink" title="📚二、实现方式介绍"></a>📚二、实现方式介绍</h1><p>目前实现<strong>自定义事件</strong>的两种主要方式是 JS 原生的 <code>Event()</code> 构造函数和 <code>CustomEvent()</code> 构造函数来创建。<br /></p>
<h2 id="1-Event"><a href="#1-Event" class="headerlink" title="1. Event()"></a>1. Event()</h2><p><code>Event()</code> 构造函数, 创建一个新的事件对象 <code>Event</code>。</p>
<h3 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myEvent = <span class="keyword">new</span> Event(typeArg, eventInit);</span><br></pre></td></tr></table></figure>

<h3 id="1-2-参数"><a href="#1-2-参数" class="headerlink" title="1.2 参数"></a>1.2 参数</h3><p><code>typeArg</code>  ： <code>DOMString</code> 类型，表示创建事件的名称；<br /><code>eventInit</code> ：可选配置项，包括：</p>
<table>
<thead>
<tr>
<th align="center">字段名称</th>
<th align="center">说明</th>
<th align="center">是否可选</th>
<th align="center">类型</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>bubbles</code></td>
<td align="center">表示该事件<strong>是否冒泡</strong>。</td>
<td align="center">可选</td>
<td align="center"><code>Boolean</code></td>
<td align="center">false</td>
</tr>
<tr>
<td align="center"><code>cancelable</code></td>
<td align="center">表示该事件<strong>能否被取消</strong>。</td>
<td align="center">可选</td>
<td align="center"><code>Boolean</code></td>
<td align="center">false</td>
</tr>
<tr>
<td align="center"><code>composed</code></td>
<td align="center">指示事件是否会在<strong>影子DOM根节点之外</strong>触发侦听器。</td>
<td align="center">可选</td>
<td align="center"><code>Boolean</code></td>
<td align="center">false</td>
</tr>
</tbody></table>
<h3 id="1-3-演示示例"><a href="#1-3-演示示例" class="headerlink" title="1.3 演示示例"></a>1.3 演示示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个支持冒泡且不能被取消的 pingan 事件</span></span><br><span class="line"><span class="keyword">let</span> myEvent = <span class="keyword">new</span> Event(<span class="string">&quot;pingan&quot;</span>, &#123;<span class="string">&quot;bubbles&quot;</span>:<span class="literal">true</span>, <span class="string">&quot;cancelable&quot;</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(myEvent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件可以在任何元素触发，不仅仅是document</span></span><br><span class="line">testDOM.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure>

<h3 id="1-4-兼容性"><a href="#1-4-兼容性" class="headerlink" title="1.4 兼容性"></a>1.4 兼容性</h3><p><img src="https://user-gold-cdn.xitu.io/2020/2/22/1706b7199abd2e9e?w=1265&h=326&f=png&s=50137" alt="image.png"><br />图片来源：<a target="_blank" rel="noopener" href="https://caniuse.com/">https://caniuse.com/</a></p>
<h2 id="2-CustomEvent"><a href="#2-CustomEvent" class="headerlink" title="2. CustomEvent()"></a>2. CustomEvent()</h2><p><code>CustomEvent()</code> 构造函数, 创建一个新的事件对象 <code>CustomEvent</code>。</p>
<h3 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myEvent = <span class="keyword">new</span> CustomEvent(typeArg, eventInit);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-参数"><a href="#2-2-参数" class="headerlink" title="2.2 参数"></a>2.2 参数</h3><p><code>typeArg</code>  ： <code>DOMString</code> 类型，表示创建事件的名称；<br /><code>eventInit</code> ：可选配置项，包括：</p>
<table>
<thead>
<tr>
<th align="center">字段名称</th>
<th align="center">说明</th>
<th align="center">是否可选</th>
<th align="center">类型</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>detail</code></td>
<td align="center">表示该事件中需要被传递的数据，在 <code>EventListener</code> 获取。</td>
<td align="center">可选</td>
<td align="center"><code>Any</code></td>
<td align="center">null</td>
</tr>
<tr>
<td align="center"><code>bubbles</code></td>
<td align="center">表示该事件<strong>是否冒泡</strong>。</td>
<td align="center">可选</td>
<td align="center"><code>Boolean</code></td>
<td align="center">false</td>
</tr>
<tr>
<td align="center"><code>cancelable</code></td>
<td align="center">表示该事件<strong>能否被取消</strong>。</td>
<td align="center">可选</td>
<td align="center"><code>Boolean</code></td>
<td align="center">false</td>
</tr>
</tbody></table>
<h3 id="2-3-演示示例"><a href="#2-3-演示示例" class="headerlink" title="2.3 演示示例"></a>2.3 演示示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建事件</span></span><br><span class="line"><span class="keyword">let</span> myEvent = <span class="keyword">new</span> CustomEvent(<span class="string">&quot;pingan&quot;</span>, &#123;</span><br><span class="line">	<span class="attr">detail</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;wangpingan&quot;</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加适当的事件监听器</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;pingan&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">	alert(<span class="string">`pingan事件触发，是 <span class="subst">$&#123;e.detail.name&#125;</span> 触发。`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;leo2&quot;</span>).addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 派发事件</span></span><br><span class="line">		<span class="built_in">window</span>.dispatchEvent(pingan2Event);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/22/1706b7199ae8f81e?w=457&h=140&f=png&s=7499" alt="image.png"><br /><br><br />我们也可以给自定义事件添加属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myEvent.age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-兼容性"><a href="#2-4-兼容性" class="headerlink" title="2.4 兼容性"></a>2.4 兼容性</h3><p><img src="https://user-gold-cdn.xitu.io/2020/2/22/1706b7199af32342?w=1261&h=331&f=png&s=54279" alt="image.png"><br />图片来源：<a target="_blank" rel="noopener" href="https://caniuse.com/">https://caniuse.com/</a></p>
<h3 id="2-5-IE8-兼容"><a href="#2-5-IE8-兼容" class="headerlink" title="2.5 IE8 兼容"></a>2.5 IE8 兼容</h3><p>分发事件时，需要使用 <code>dispatchEvent</code> 事件触发，它在 IE8 及以下版本中需要进行使用 <code>fireEvent</code> 方法兼容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.dispatchEvent) &#123;  </span><br><span class="line">    <span class="built_in">window</span>.dispatchEvent(myEvent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.fireEvent(myEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Event-与-CustomEvent-区别"><a href="#3-Event-与-CustomEvent-区别" class="headerlink" title="3. Event() 与 CustomEvent() 区别"></a>3. Event() 与 CustomEvent() 区别</h2><p>从两者支持的参数中，可以看出：<br /><code>Event()</code> 适合创建简单的自定义事件，而 <code>CustomEvent()</code> 支持参数传递的自定义事件，它支持 <code>detail</code> 参数，作为事件中<strong>需要被传递的数据</strong>，并在 <code>EventListener</code> 获取。</p>
<p><strong>注意:</strong><br />当一个事件触发时，若相应的元素及其上级元素没有进行事件监听，则不会有回调操作执行。 <br />当需要对于子元素进行监听，可以在其父元素进行事件托管，让事件在事件冒泡阶段被监听器捕获并执行。此时可以使用 <code>event.target</code> 获取到具体触发事件的元素。</p>
<h1 id="📚三、使用场景"><a href="#📚三、使用场景" class="headerlink" title="📚三、使用场景"></a>📚三、使用场景</h1><p><strong>事件本质是一种消息</strong>，事件模式本质上是<strong>观察者模式</strong>的实现，即能用<strong>观察者模式</strong>的地方，自然也能用<strong>事件模式</strong>。<br /></p>
<h2 id="1-场景介绍"><a href="#1-场景介绍" class="headerlink" title="1.场景介绍"></a>1.场景介绍</h2><p>比如这两种场景：<br /></p>
<ul>
<li><strong>场景1：单个目标对象发生改变，需要通知多个观察者一同改变。</strong></li>
</ul>
<p>如：当微博列表中点击“关注”，此时会同时发生很多事：推荐更多类似微博，个人关注数增加…<br /><img src="https://user-gold-cdn.xitu.io/2020/2/22/1706b7199d02caa1?w=1394&h=550&f=png&s=329270" alt="image.png"></p>
<ul>
<li><strong>场景2：解耦多模块开协作。</strong></li>
</ul>
<p>如：小王负责A模块开发，小陈负责B模块开发，模块B需要模块A正常运行之后才能执行。</p>
<h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h2><h3 id="2-1-场景1实现"><a href="#2-1-场景1实现" class="headerlink" title="2.1 场景1实现"></a>2.1 场景1实现</h3><p><strong>场景1：单个目标对象发生改变，需要通知多个观察者一同改变。</strong><br />本例子模拟三个页面进行演示：<br />1.微博列表页（Weibo.js）<br />2.粉丝列表页（User.js）<br />3.微博首页（Home.js）</p>
<p>在<strong>微博列表页（Weibo.js）</strong>中，我们导入其他两个页面，并且监听【关注微博】按钮的点击事件，在回调事件中，创建一个自定义事件 <code>focusUser</code>，并在 <code>document</code> 上使用 <code>dispatchEvent</code> 方法派发自定义事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Weibo.js</span></span><br><span class="line"><span class="keyword">import</span> UserModule <span class="keyword">from</span> <span class="string">&quot;./User.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> HomeModule <span class="keyword">from</span> <span class="string">&quot;./Home.js&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> eventButton = <span class="built_in">document</span>.getElementById(<span class="string">&quot;eventButton&quot;</span>);</span><br><span class="line">eventButton.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> focusUser = <span class="keyword">new</span> Event(<span class="string">&quot;focusUser&quot;</span>);</span><br><span class="line">  <span class="built_in">document</span>.dispatchEvent(focusUser);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接下来两个页面实现的代码基本一致，这里为了方便观察，设置了两者不同输出日志。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.js</span></span><br><span class="line"><span class="keyword">const</span> eventButton = <span class="built_in">document</span>.getElementById(<span class="string">&quot;eventButton&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;focusUser&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;【粉丝列表页】监听到自定义事件触发，event：&quot;</span>,event);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Home.js</span></span><br><span class="line"><span class="keyword">const</span> eventButton = <span class="built_in">document</span>.getElementById(<span class="string">&quot;eventButton&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;focusUser&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;【微博首页】监听到自定义事件触发，event：&quot;</span>,event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>点击【关注微博】按钮后，看到控制台输出如下日志信息：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/22/1706b7199d2f7350?w=715&h=267&f=png&s=29435" alt="image.png"></p>
<p>最终实现了，在 <strong>微博列表页（Weibo.js）</strong>组件负责派发事件，其他组价负责监听事件，这样三个组件之间耦合度非常低，完全不用关系对方，互相不影响。<br /><strong>其实这也是实现了观察者模式。</strong></p>
<h3 id="2-2-场景2实现"><a href="#2-2-场景2实现" class="headerlink" title="2.2 场景2实现"></a>2.2 场景2实现</h3><p><strong>场景2：解耦多模块开协作。</strong><br />举个更直观的例子，当微博需要加入【<strong>一键三连</strong>】新功能，需要产品原型和UI设计完后，程序员才能开发。<br />本例子模拟四个模块：<br />1.流程控制（Index.js）<br />2.产品设计（Production.js）<br />3.UI设计（Design.js）<br />4.程序员开发（Develop.js）</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/22/1706b7199d71549f?w=1031&h=336&f=png&s=46607" alt="image.png"></p>
<p>在<strong>流程控制（Index.js）模块</strong>中，我们需要将其他三个流程的模块都导入进来，然后监听【开始任务】按钮的点击事件，在回调事件中，创建一个自定义事件 <code>startTask</code>，并在 <code>document</code> 上使用 <code>dispatchEvent</code> 方法派发自定义事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Index.js</span></span><br><span class="line"><span class="keyword">import</span> ProductionModule <span class="keyword">from</span> <span class="string">&quot;./Production.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> DesignModule <span class="keyword">from</span> <span class="string">&quot;./Design.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> DevelopModule <span class="keyword">from</span> <span class="string">&quot;./Develop.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="built_in">document</span>.getElementById(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">start.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始执行任务&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> startTask = <span class="keyword">new</span> Event(<span class="string">&quot;startTask&quot;</span>);</span><br><span class="line">    <span class="built_in">document</span>.dispatchEvent(startTask);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 Production 产品设计模块中，监听任务开始事件 <code>startTask</code> 后，模拟1秒后原型设计完成，并派发一个新的事件 <code>productionSuccess</code> ，开始接下来的UI稿设计。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Production.js</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;startTask&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;产品开始设计...&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;产品原型设计完成&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="built_in">document</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&quot;productionSuccess&quot;</span>));</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在UI稿设计和程序开发模块，其实也类似，代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dedign.js</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;productionSuccess&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;UI稿开始设计...&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;UI稿设计完成&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="built_in">document</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&quot;designSuccess&quot;</span>));</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Production.js</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;designSuccess&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始开发功能...&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;【一键三连】开发完成&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>开发完成后，我们点击【开始任务】按钮后，看到控制台输出如下日志信息：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/22/1706b719c40359b3?w=717&h=268&f=png&s=23968" alt="image.png"></p>
<p>最终实现了在 <strong>流程控制（Index.js）模块</strong>负责派发事件，其他组件负责监听事件，按流程完成其他任务。<br /><strong>可以看出，原型设计、UI稿设计和程序开发任务，互不影响，易于任务拓展。</strong></p>
<h1 id="📚四、总结"><a href="#📚四、总结" class="headerlink" title="📚四、总结"></a>📚四、总结</h1><p>本文详细介绍 JS<strong>自定义事件概念和实现方式</strong>，并结合两个实际场景进行代码演示。细心的小伙伴会发现，这两个实际场景都是用 <code>Event()</code> 构造函数实现，当然也是可以使用 <code>CustomEvent</code> 构造函数来代替。<br />另外本文也详细介绍两种实现方式，包括其区别和兼容性。<br />最后也希望大家能在实际开发中，多思考代码解耦，适当使用<strong>自定义事件</strong>来提高代码质量。</p>
<p>如有错误，欢迎指点。</p>
<h1 id="📚五、参考文章"><a href="#📚五、参考文章" class="headerlink" title="📚五、参考文章"></a>📚五、参考文章</h1><ul>
<li>《<a target="_blank" rel="noopener" href="https://m.jb51.net/article/127776.htm">javascript自定义事件功能与用法实例分析</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/Event">Event - MDN</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent">CustomEvent - MDN</a>》</li>
</ul>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#112;&#x69;&#110;&#103;&#x61;&#110;&#56;&#x37;&#56;&#x37;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;">&#112;&#x69;&#110;&#103;&#x61;&#110;&#56;&#x37;&#56;&#x37;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>ES小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>
<h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><p><img src="http://images.pingan8787.com/2019_07_12guild_page.png" alt="bg">  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/22/197-%E3%80%90JavaScript%E3%80%91JS%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95%EF%BC%81/" data-id="ckts3eju1005g4d9ka2ck5whn" data-title="197-【JavaScript】JS自定义事件如此简单！" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E6%B8%A9%E5%9F%BA%E7%A1%80/" rel="tag">重温基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-196-【JavaScript】一文学会判断变量是否为数组" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/13/196-%E3%80%90JavaScript%E3%80%91%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84/" class="article-date">
  <time class="dt-published" datetime="2020-02-12T16:39:31.000Z" itemprop="datePublished">2020-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/13/196-%E3%80%90JavaScript%E3%80%91%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84/">196-【JavaScript】一文学会判断变量是否为数组</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>日常开发中，我们经常遇到这种情况，需要我们判断变量是否是一个数组类型。</p>
<p>那么今天我把常用的判断<strong>变量是否是数组类型</strong>的方法，整理在这里：</p>
<h2 id="一、常用方法"><a href="#一、常用方法" class="headerlink" title="一、常用方法"></a>一、常用方法</h2><h3 id="1-Object-prototype-toString"><a href="#1-Object-prototype-toString" class="headerlink" title="1. Object.prototype.toString"></a>1. Object.prototype.toString</h3><p>通常我们可以使用 <code>Object.prototype.toString</code> 方法进行判断，详细可以查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString">《Object.prototype.toString() - MDN - Mozilla》</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], obj = &#123;<span class="attr">name</span>: <span class="string">&quot;leo&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(a)===<span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">isArray(arr); <span class="comment">// true</span></span><br><span class="line">isArray(obj); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Array-isArray-arr"><a href="#2-Array-isArray-arr" class="headerlink" title="2. Array.isArray(arr)"></a>2. Array.isArray(arr)</h3><p><code>Array.isArray(arr)</code> 方法使用起来很简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], obj = &#123;<span class="attr">name</span>: <span class="string">&quot;leo&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.isArray(arr); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(obj); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是 <code>Array.isArray(arr)</code> 方法虽然简单，但是存在兼容性问题，<code>Array.isArray</code>是ES 5.1推出的，不支持IE6~8，所以在使用的时候也应注意兼容问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray)&#123;</span><br><span class="line">    <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(a)===<span class="string">&#x27;[object Array]&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、不够准确的方法"><a href="#二、不够准确的方法" class="headerlink" title="二、不够准确的方法"></a>二、不够准确的方法</h2><h3 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1. 原型链"></a>1. 原型链</h3><p>使用原型链判断也比较简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], obj = &#123;<span class="attr">name</span>: <span class="string">&quot;leo&quot;</span>&#125;;</span><br><span class="line">arr.__proto__.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">obj.__proto__.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">arr.constructor === <span class="built_in">Array</span>;  <span class="comment">//true</span></span><br><span class="line">obj.constructor === <span class="built_in">Array</span>;  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>但是之所以说 <code>constructor</code> 不够准确，是因为在不同执行环境下， <code>constructor</code> 判断会不正确。<br />比如下面这种情况，我们重写 <code>constructor</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], obj = &#123;<span class="attr">name</span>: <span class="string">&quot;leo&quot;</span>&#125;;</span><br><span class="line">arr.constructor === <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">obj.constructor === <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">obj.constructor = <span class="built_in">Array</span>;</span><br><span class="line">obj.constructor === <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2. instanceof"></a>2. instanceof</h3><p>简单使用 <code>instanceof</code> 如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], obj = &#123;<span class="attr">name</span>: <span class="string">&quot;leo&quot;</span>&#125;;</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>但是  <code>instanceof</code> 也存在局限性，它必须在<strong>当前页面声明</strong>，如父页面中存在一个 iframe，并且 iframe 中引用了一个子页面，在子页面中声明了一个 <code>arr</code> ，并将其赋值给父页面的一个变量，这时判断该变量，<code>Array == object.constructor;</code> 会返回 false；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">myArray = <span class="built_in">window</span>.frames[<span class="number">0</span>].Array;</span><br><span class="line"><span class="keyword">let</span> myArr = <span class="keyword">new</span> myArray(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">myArr <span class="keyword">instanceof</span> <span class="built_in">Array</span>;    <span class="comment">//false</span></span><br><span class="line">myArr.constructor == <span class="built_in">Array</span>;<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype == myArray.prototype); <span class="comment">//false</span></span><br><span class="line">arr <span class="keyword">instanceof</span> myArray); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">myArr.constructor === <span class="built_in">Array</span>;  <span class="comment">// false</span></span><br><span class="line">arr.constructor === <span class="built_in">Array</span>;    <span class="comment">// true</span></span><br><span class="line">myArr.constructor === myArray;<span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arrx);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="三、错误的方法"><a href="#三、错误的方法" class="headerlink" title="三、错误的方法"></a>三、错误的方法</h2><h3 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1. typeof"></a>1. typeof</h3><p><code>typeof</code> 是无法判断是否是数组的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], obj = &#123;<span class="attr">name</span>: <span class="string">&quot;leo&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">typeof</span> arr; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> obj; <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>所以可以看出， <code>typeof</code> 适合用来判断<strong>基本数据类型</strong>。</p>
<p><code>typeof</code> 的一些判断结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>;   <span class="comment">//number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;leo&quot;</span>; <span class="comment">//string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>;  <span class="comment">//boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>;  <span class="comment">//object</span></span><br><span class="line"><span class="keyword">let</span> leo = <span class="built_in">Symbol</span>;</span><br><span class="line"><span class="keyword">typeof</span> leo;   <span class="comment">//symbol</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;;      <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">//function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Array</span>;   <span class="comment">//function  Array类型的构造函数</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>;  <span class="comment">//function  Object类型的构造函数</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>;  <span class="comment">//function  Symbol类型的构造函数</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Number</span>;  <span class="comment">//function  Number类型的构造函数</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>;  <span class="comment">//function  String类型的构造函数</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Boolean</span>; <span class="comment">//function  Boolean类型的构造函数</span></span><br></pre></td></tr></table></figure>

<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本文主要给大家从三个角度去介绍一些判断变量是否是数组的方法，在日常开发中【一、常见方法】中的 2 个方法，已经足够我们使用了，也建议使用这 2 种方法。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5be52b1ae51d450b3647e766">《判断是否是数组的几种方法》</a></li>
</ul>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#x69;&#x6e;&#103;&#x61;&#110;&#x38;&#55;&#56;&#x37;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;">&#x70;&#x69;&#x6e;&#103;&#x61;&#110;&#x38;&#55;&#56;&#x37;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>JS小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/13/196-%E3%80%90JavaScript%E3%80%91%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84/" data-id="ckts3eju1005e4d9k5wto643n" data-title="196-【JavaScript】一文学会判断变量是否为数组" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E6%B8%A9%E5%9F%BA%E7%A1%80/" rel="tag">重温基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-195-【Webpack】分析Webpack运行机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/12/195-%E3%80%90Webpack%E3%80%91%E5%88%86%E6%9E%90Webpack%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2020-02-12T04:33:56.000Z" itemprop="datePublished">2020-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/12/195-%E3%80%90Webpack%E3%80%91%E5%88%86%E6%9E%90Webpack%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/">195-【Webpack】分析Webpack运行机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/186051/1581480528734-6b482042-4110-4415-b39e-3df70e15a4de.jpeg#align=left&display=inline&height=315&originHeight=460&originWidth=1080&size=0&status=done&style=none&width=740"><br />原文地址：<a target="_blank" rel="noopener" href="https://www.javazhiyin.com/50313.html">【工具篇】2 | Webpack的运行机制</a></p>
<p>作者 | 思语</p>
<p>阅读时间 | <strong>34分钟</strong><br />**</p>
<blockquote>
<p>webpack 是一个 JS 代码模块化的打包工具，藉由它强大的扩展能力，随着社区的发展，逐渐成为一个功能完善的构建工具，目前webpack已更新第五版本。</p>
</blockquote>
<p><a name="lwDAa"></a></p>
<h1 id="webpack的与共不同"><a href="#webpack的与共不同" class="headerlink" title="webpack的与共不同"></a>webpack的与共不同</h1><p>webpack 是前端常用的打包工具，可以看作是模块打包机，它的工作主要是分析项目结构，找到JavaScript模块以及一些浏览器无法直接编译的其它拓展语言（比如sass，ts等等），对项目整体进行解析、加工、打包、优化。<br /><strong>Q：WebPack 和 Grunt 以及 Gulp 相比有什么特性？</strong><br /><strong>A：</strong>同作为前端打包工具，Webpack和另外两个没有太多的可比性，相对而言，Gulp/Grunt更倾向于专业的流程打包工具，而WebPack提供的是一整套模块化的解决方案，webpack所能做的事情更多更完善，至今为止webpack以及发展到了5.x版本，webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。<br /><strong>Grunt、Gulp的工作方式</strong>是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。<br /><strong>Webpack的工作方式</strong>是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1581480529449-fa18cf20-055f-487a-b767-130ee45d202b.png#align=left&display=inline&height=323&originHeight=382&originWidth=874&size=0&status=done&style=none&width=740"><br><a name="nSO7R"></a></p>
<h1 id="webpack-内部工作机制"><a href="#webpack-内部工作机制" class="headerlink" title="webpack 内部工作机制"></a>webpack 内部工作机制</h1><p>以webpack4为例，上篇文章 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU3Mzc2NDY1MQ==&mid=2247484364&idx=1&sn=7e3b9513cc2d71b44c2ccfc5559898ad&chksm=fd3de688ca4a6f9e6c1760a870611d28b3085bfa887d9ef3e0c7bb2c91470c7638f8d7c5cc8e&scene=21#wechat_redirect">【工具篇】1 | Webpack的基本使用</a> 已经详细介绍webpack的基本使用方法，下面将探讨 webpack 内部运行机制和其构建优化。<br />了解 webpack 的内部工作流程，有助于我们解决日常使用 webpack 时遇到的一些问题，也有助于我们更好地理解 webpack loader 和 plugin 的使用。<br />先暂时抛开复杂的 loader 和 plugin 机制（以后将详细介绍），webpack 本质上就是一个 JS Module Bundler，用于将多个代码模块进行打包，首先通过一个相对简单的 JS Module Bunlder 的基础工作流程是如何运行的，在了解了 bundler 如何工作的基础上，再进一步去整理 webpack 整个流程，将 loader 和 plugin 的机制弄明白。</p>
<blockquote>
<p>以下内容将 module bundler 简称为 bundler。</p>
</blockquote>
<p><a name="DL9Z5"></a></p>
<h2 id="1-bundler-的基础流程"><a href="#1-bundler-的基础流程" class="headerlink" title="1.bundler 的基础流程"></a>1.bundler 的基础流程</h2><p>bundler 从构建入口出发，解析代码，分析出代码模块依赖关系，然后将依赖的代码模块组合在一起，在 JavaScript bundler 中，还需要提供一些胶水代码让多个代码模块可以协同工作，相互引用。首先是解析代码、分析依赖关系，对于 ES6 Module 以及 CommonJS Modules 语法定义的模块，例如这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>; <span class="comment">// 依赖 ./bar.js 模块</span></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo.js&#x27;</span>); <span class="comment">// 依赖 ./foo.js 模块</span></span><br></pre></td></tr></table></figure>
<p>bundler 需要从这个入口代码（第一段）中解析出依赖 bar.js，然后再读取 bar.js 这个代码文件，解析出依赖 foo.js 代码文件，继续解析其依赖，递归下去，直至没有更多的依赖模块，最终形成一颗模块依赖树。<br />分析出依赖关系后，bunlder 需要将依赖关系中涉及的所有文件组合到一起，由于依赖代码的执行是有先后顺序以及会引用模块内部不同的内容，不能简单地将代码拼接到一起。webpack 会利用 JavaScript Function 的特性提供一些代码来将各个模块整合到一起，即是将每一个模块包装成一个 JS Function，提供一个引用依赖模块的方法，如下面例子中的 <code>__webpack__require__</code>，这样做，既可以避免变量相互干扰，又能够有效控制执行顺序，简单的代码例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将各个依赖模块的代码用 modules 的方式组织起来打包成一个文件</span></span><br><span class="line"><span class="comment">// entry.js</span></span><br><span class="line">modules[<span class="string">&#x27;./entry.js&#x27;</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; bar &#125; = __webpack__require__(<span class="string">&#x27;./bar.js&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line">modules[<span class="string">&#x27;./bar.js&#x27;</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> foo = __webpack__require__(<span class="string">&#x27;./foo.js&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// foo.js</span></span><br><span class="line">modules[<span class="string">&#x27;./foo.js&#x27;</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 已经执行的代码模块结果会保存在这里</span></span><br><span class="line"><span class="keyword">const</span> installedModules = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack__require__</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  <span class="comment">// 如果 installedModules 中有就直接获取</span></span><br><span class="line">  <span class="comment">// 没有的话从 modules 中获取 function 然后执行，将结果缓存在 installedModules 中然后返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在介绍 bundler 的基础流程时，把各个部分的实现细节简化了，这有利于我们从整体的角度去看清楚整个轮廓，至于某一部分的具体实现，例如解析代码依赖，模块依赖关系管理，胶水代码的生成等，深入细节的话会比较复杂，以后再对其专题分析。</p>
<hr>
<p><a name="slbOI"></a></p>
<h2 id="2-webpack-的结构"><a href="#2-webpack-的结构" class="headerlink" title="2.webpack 的结构"></a>2.webpack 的结构</h2><p>webpack 需要高扩展性，在插件实现方面，webpack 利用了 tapable 库来协助实现对于整个构建流程各个步骤的控制。在基于 tapable 库定义主要构建流程后，并使用 tapable 库添加了各类的钩子方法来拓展 webpack，同时对外提供了相对强大的扩展性，即 plugin 的机制。<br />下面是 webpack 运行过程中的几个重要概念：</p>
<ul>
<li><strong>Compiler</strong><br />webpack 的支柱引擎，实例化时定义 webpack 构建主要流程，同时创建构建时使用的核心对象 compilation；<br /></li>
<li><strong>Compilation</strong><br />由 Compiler 实例化，存储构建过程中各流程使用到的数据，用于控制这些数据的变化；<br /></li>
<li><strong>Chunk</strong><br />即用于表示 chunk 的类，对于构建时需要的 chunk 对象由 Compilation 创建后保存管理；<br /></li>
<li><strong>Module</strong><br />用于表示代码模块的类，衍生出很多子类用于处理不同的情况，关于代码模块的所有信息都会存在 Module 实例中，例如 <code>dependencies</code> 记录代码模块的依赖等；<br /></li>
<li><strong>Parser</strong><br />基于 acorn 来分析 AST 语法树，解析出代码模块的依赖；<br /></li>
<li><strong>Dependency</strong><br />解析时用于保存代码模块对应的依赖使用的对象；<br /></li>
<li><strong>Template</strong><br />生成最终代码要使用到的代码模板；<br /><blockquote>
<p>官方对于 Compiler 和 Compilation 的定义是：<br><strong>compiler</strong> 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。<br><strong>compilation</strong> 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键步骤的回调，以供插件做自定义处理时选择使用。</p>
</blockquote>
</li>
</ul>
<p>下面是 webpack 内部工作流程中比较重要的几个部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.创建 Compiler -&gt; </span><br><span class="line">2.调用 compiler.run 开始构建 -&gt;</span><br><span class="line">3.创建 Compilation -&gt; </span><br><span class="line">4.基于配置开始创建 Chunk -&gt; </span><br><span class="line">5.使用 Parser 从 Chunk 开始解析依赖 -&gt; </span><br><span class="line">6.使用 Module 和 Dependency 管理代码模块相互关系 -&gt; </span><br><span class="line">7.使用 Template 基于 Compilation 的数据生成结果代码</span><br></pre></td></tr></table></figure>
<p>上述只是大概流程，实际流程细节相对复杂，一方面是技术实现的细节有一定复杂度，另一方面是实现的功能逻辑上也有一定复杂度，深入介绍的话，篇幅会很长，并且可能效果不理想，当我们还没到了要去实现具体功能的时候，无须关注那么具体的实现细节，只需要站在更高的层面去分析整体的流程。更细节的部分将在 Node篇 进一步探讨。<br><a name="5PPiP"></a></p>
<h1 id="从源码中探索-webpack"><a href="#从源码中探索-webpack" class="headerlink" title="从源码中探索 webpack"></a>从源码中探索 webpack</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/186051/1581480528723-34663a4f-73a5-4bd0-bb0f-eeda701db965.jpeg#align=left&display=inline&height=1336&originHeight=1175&originWidth=651&size=0&status=done&style=none&width=740"><br />webpack 主要的构建处理方法都在 <code>Compilation</code> 中，按照官网的说法，<code>Compilation</code> 模块会被 <code>Compiler</code> 用来创建新的编译（或新的构建）。<code>compilation</code> 实例能够访问所有的模块和它们的依赖（大部分是循环依赖）。它会对应用程序的依赖图中所有模块进行字面上的编译(literal compilation)。在编译阶段，模块会被加载(loaded)、封存(sealed)、优化(optimized)、分块(chunked)、哈希(hashed)和重新创建(restored)，下面仅对下面几个个关键部分来探讨一下。</p>
<hr>
<p><a name="SKGao"></a></p>
<h2 id="1-Tapable"><a href="#1-Tapable" class="headerlink" title="1.Tapable"></a>1.Tapable</h2><p>webpack4重写了Tapable, 是webpack的插件组织的核心。它提供给各个插件钩子，在事件触发时执行这些挂载的方法。webapck的插件里必须有apply()方法，当其被调用的时候webpack将钩子上的方法挂载到各个事件下面有点像nodejs里EventEmitter的<code>$on</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hooks = &#123;</span><br><span class="line">            <span class="attr">accelerate</span>: <span class="keyword">new</span> SyncHook([<span class="string">&quot;newSpeed&quot;</span>]),</span><br><span class="line">            <span class="attr">brake</span>: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">            <span class="attr">calculateRoutes</span>: <span class="keyword">new</span> AsyncParallelHook([<span class="string">&quot;source&quot;</span>, <span class="string">&quot;target&quot;</span>, <span class="string">&quot;routesList&quot;</span>])</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">setSpeed</span>(<span class="params">newSpeed</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hooks.accelerate.call(newSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码所示先是在实例化的过程中注册了三个钩子函数，在实例上调用方法时触发钩子函数。</p>
<hr>
<p><a name="3ASHj"></a></p>
<h2 id="2-Compiler"><a href="#2-Compiler" class="headerlink" title="2.Compiler"></a>2.Compiler</h2><p>最高层的实例，初始化配置，提供全局性的钩子比如done, compilation。其他的Tapable实例需要通过其访问，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">compiler.hooks.compilation.tap(</span><br><span class="line">      <span class="string">&quot;myFirstWebpackPlugin&quot;</span>,</span><br><span class="line">      <span class="function">(<span class="params">compilation, params</span>) =&gt;</span> &#123;</span><br><span class="line">        compilation.hooks.seal.tap()</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p><a name="mLrk1"></a></p>
<h2 id="3-addEntry-和-addModuleChain"><a href="#3-addEntry-和-addModuleChain" class="headerlink" title="3.addEntry 和 _addModuleChain"></a>3.addEntry 和 _addModuleChain</h2><p><code>addEntry</code> 这个方法顾名思义，用于把配置的入口加入到构建的任务中去，当解析好 webpack 配置，准备好开始构建时，便会执行 <code>addEntry</code> 方法，而 <code>addEntry</code> 会调用 <code>_addModuleChain</code> 来为入口文件（入口文件这个时候等同于第一个依赖）创建一个对应的 <code>Module</code> 实例。<br /><code>_addModuleChain</code> 方法会根据入口文件这第一个依赖的类型创建一个 <code>moduleFactory</code>，然后再使用这个 <code>moduleFactory</code> 给入口文件创建一个 <code>Module</code> 实例，这个 <code>Module</code> 实例用来管理后续这个入口构建的相关数据信息，关于 <code>Module</code> 类的具体实现可以参考这个源码：lib/Module.js，这个是个基础类，大部分我们构建时使用的代码模块的 <code>Module</code> 实例是 lib/NormalModule.js 这个类创建的。<br />我们介绍 <code>addEntry</code> 主要是为了寻找整个构建的起点，让这一切有迹可循，后续的深入可以从这个点出发。</p>
<hr>
<p><a name="naLK9"></a></p>
<h2 id="4-buildModule"><a href="#4-buildModule" class="headerlink" title="4.buildModule"></a>4.buildModule</h2><p>当一个 <code>Module</code> 实例被创建后，比较重要的一步是执行 <code>compilation.buildModule</code> 这个方法，这个方法主要会调用 <code>Module</code> 实例的 <code>build</code> 方法，这个方法主要就是创建 <code>Module</code> 实例需要的一些东西，对我们梳理流程来说，这里边最重要的部分就是调用自身的 runLoaders 方法。<br /><code>runLoaders</code> 这个方法是 webpack 依赖的这个类库实现的：loader-runner，这个方法也比较容易理解，就是执行对应的 loaders，将代码源码内容一一交由配置中指定的 loader 处理后，再把处理的结果保存起来。<br />上面提到的 <code>Module</code> 实例的 <code>build</code> 方法在执行完对应的 loader，处理完模块代码自身的转换后，还有相当重要的一步是调用 Parser 的实例来解析自身依赖的模块，解析后的结果存放在 <code>module.dependencies</code> 中，首先保存的是依赖的路径，后续会经由 <code>compilation.processModuleDependencies</code> 方法，再来处理各个依赖模块，递归地去建立整个依赖关系树。</p>
<hr>
<p><a name="ZieAu"></a></p>
<h2 id="5-Compilation-的钩子"><a href="#5-Compilation-的钩子" class="headerlink" title="5.Compilation 的钩子"></a>5.Compilation 的钩子</h2><p>由Compiler创建，整个构建就在这里完成，进行依赖图构建，优化资源，渲染出runtime时的代码等。下面的4个实例都是发生在这个阶段。webpack 会使用 tapable 库给整个流程的各个步骤拓展钩子方法，便于特定的环节执行时触发相应的事件，注册的事件函数便可以调整构建时的上下文数据，或者做额外的处理工作，这就是 webpack 的 plugin 机制。在 webpack 执行入口处 lib/webpack.js 有这么一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.plugins &amp;&amp; <span class="built_in">Array</span>.isArray(options.plugins)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> options.plugins) &#123;</span><br><span class="line">        plugin.apply(compiler); <span class="comment">// 调用每一个 plugin 的 apply 方法，把 compiler 实例传递过去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>plugin 的 <code>apply</code> 方法就是用来给 <code>compiler</code> 实例注册事件钩子函数的，而 <code>compiler</code> 的一些事件钩子中可以获得 <code>compilation</code> 实例的引用，通过引用又可以给 <code>compilation</code> 实例注册事件函数，以此类推，便可以将 plugin 的能力覆盖到整个 webpack 构建过程。<br><a name="ml0IN"></a></p>
<h2 id="6-Resolver"><a href="#6-Resolver" class="headerlink" title="6.Resolver"></a>6.Resolver</h2><p>当你请求一个模块的时候，你将模块名或者相对地址发给模块解析器，它会去解析出绝对地址去寻找那个模块，看是否存在，如果存在则返回相应的模块信息，包括上下文等。这里的请求可以类似网络请求一样携带上查询参数之类的，Resolver将会返回额外信息。webpack4里将Resolver这个实例抽出来单独发了一个包enhanced-resolve, 抽象出来可以便于用户实现自己的Resolver。<br><a name="aB9wM"></a></p>
<h2 id="7-ModuleFactory"><a href="#7-ModuleFactory" class="headerlink" title="7.ModuleFactory"></a>7.ModuleFactory</h2><p>模块工厂就是负责构造模块的实例，介绍两种NormalModuleFactory和ContextModuleFactory。两者不同的地方在于后者用于解析动态import()，模块工厂主要是用于将Resolver解析成功的请求里的源码从文件中拿出，在内存中创建一个模块对象（NormalModule）。<br><a name="83QcQ"></a></p>
<h2 id="8-Parser"><a href="#8-Parser" class="headerlink" title="8.Parser"></a>8.Parser</h2><p>Parser主要用于将代码解析成AST抽象语法树.可以在ast查看代码转换成AST后的样子。webpack默认采用acorn解析器，babel是babylon。Parser将ModuleFactory返回的对象里的代码字符串转换成AST后进行解析，发现import或者require或者define类似模块引用时会将这些引用信息也就是依赖添加到当前模块的对象里，这样每个模块对象里不但有自己模块的信息还包含它的依赖信息。webpack会在不仅仅会在模块声明处触发事件，它甚至会在解析到变量时也触发事件。如下在webpack/lib/Parser.js里可以看到如下三个钩子函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">varDeclaration: <span class="keyword">new</span> HookMap(<span class="function">() =&gt;</span> <span class="keyword">new</span> SyncBailHook([<span class="string">&quot;declaration&quot;</span>])),</span><br><span class="line">    <span class="attr">varDeclarationLet</span>: <span class="keyword">new</span> HookMap(<span class="function">() =&gt;</span> <span class="keyword">new</span> SyncBailHook([<span class="string">&quot;declaration&quot;</span>])),</span><br><span class="line">    <span class="attr">varDeclarationConst</span>: <span class="keyword">new</span> HookMap(<span class="function">() =&gt;</span> <span class="keyword">new</span> SyncBailHook([<span class="string">&quot;declaration&quot;</span>])),</span><br></pre></td></tr></table></figure>
<p>Template负责生成运行时的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line">    <span class="keyword">var</span> multiply  = <span class="built_in">require</span>(<span class="string">&#x27;./multiply&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">module</span>.exports = sum;</span><br><span class="line"><span class="comment">// multiply.js</span></span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a*b</span><br><span class="line"><span class="comment">// 生成的runtime</span></span><br><span class="line">[</span><br><span class="line"><span class="comment">/* 0 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> multiply  = __webpack_require__(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">module</span>.exports = sum;</span><br><span class="line"><span class="comment">/***/</span> &#125;),</span><br><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a*b</span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>如上面代码所示，里面包含三个模板，分别负责chunk、module、dependency。chunk是包含多个模块的数组，就是外面数组的形式；module就是里面用立即执行函数包围的部分；dependency就是将原先import，require等引用模块部分转换成 <strong>webpack_require。</strong><br><a name="VFhoR"></a></p>
<h1 id="优化webpack构建速度"><a href="#优化webpack构建速度" class="headerlink" title="优化webpack构建速度"></a>优化webpack构建速度</h1><p>刚刚前面我们了解到了 webpack 大致工作流程，在实际工作业务里，我们的前端项目会随着时间推移和业务发展，经过不断的迭代重构，页面可能会越来越多，或者功能和业务代码会越来越多，又或者依赖的外部类库会多而复杂，这个时候原本不足为道的 webpack 构建时间消耗就会慢慢地进入我们的视野。<br />构建消耗的时间变长了，如果是使用 CI 服务来做构建，大部分情况下我们无须等待，其实影响不大。但是本地的 webpack 开发环境服务启动时的速度和我们日常开发工作息息相关，在一些性能不是特别突出的设备上（例如便携式笔记本等等），启动时的长时间等待可能会让你越来越受不了。<br />试想一下，如果你使用 webpack build 的时长可以达到十多分钟左右，这种场景下，就算用 CI 服务，在遇见需要紧急发布修复问题时，也会让人很抓狂。所以不仅要会使用 webpack，还需要掌握如何优化 webpack 的构建性能。</p>
<hr>
<p><a name="Sn2vc"></a></p>
<h2 id="1-让-webpack-少干点活"><a href="#1-让-webpack-少干点活" class="headerlink" title="1.让 webpack 少干点活"></a>1.让 webpack 少干点活</h2><p>提升 webpack 构建速度本质上就是想办法让 webpack 少干点活，活少了速度自然快了，尽量避免 webpack 去做一些不必要的事情。<br><a name="J6gOS"></a></p>
<h2 id="2-减少-resolve-的解析"><a href="#2-减少-resolve-的解析" class="headerlink" title="2.减少 resolve 的解析"></a>2.减少 resolve 的解析</h2><p>在前边第三小节我们详细介绍了 webpack 的 <code>resolve</code> 配置，如果我们可以精简 <code>resolve</code> 配置，让 webpack 在查询模块路径时尽可能快速地定位到需要的模块，不做额外的查询工作，那么 webpack 的构建速度也会快一些，下面举个例子，介绍如何在 <code>resolve</code> 这一块做优化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  <span class="attr">modules</span>: [</span><br><span class="line">    path.resolve(__dirname, <span class="string">&#x27;node_modules&#x27;</span>), <span class="comment">// 使用绝对路径指定 node_modules，不做过多查询</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 删除不必要的后缀自动补全，少了文件后缀的自动匹配，即减少了文件路径查询的工作</span></span><br><span class="line">  <span class="comment">// 其他文件可以在编码时指定后缀，如 import(&#x27;./index.scss&#x27;)</span></span><br><span class="line">  <span class="attr">extensions</span>: [<span class="string">&quot;.js&quot;</span>], </span><br><span class="line">  <span class="comment">// 避免新增默认文件，编码时使用详细的文件路径，代码会更容易解读，也有益于提高构建速度</span></span><br><span class="line">  <span class="attr">mainFiles</span>: [<span class="string">&#x27;index&#x27;</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>上述是可以从配置 <code>resolve</code> 下手提升 webpack 构建速度的配置例子。<br />我们在编码时，如果是使用我们自己本地的代码模块，尽可能编写完整的路径，避免使用目录名，如：<code>import &#39;./lib/slider/index.js&#39;</code>，这样的代码既清晰易懂，webpack 也不用去多次查询来确定使用哪个文件，一步到位。<br><a name="fmcyX"></a></p>
<h2 id="3-把-loader-应用的文件范围缩小"><a href="#3-把-loader-应用的文件范围缩小" class="headerlink" title="3.把 loader 应用的文件范围缩小"></a>3.把 loader 应用的文件范围缩小</h2><p>我们在使用 loader 的时候，尽可能把 loader 应用的文件范围缩小，只在最少数必须的代码模块中去使用必要的 loader，例如 node_modules 目录下的其他依赖类库文件，基本就是直接编译好可用的代码，无须再经过 loader 处理了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules: [ </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.jsx?/</span>,</span><br><span class="line">    include: [ </span><br><span class="line">      path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>), </span><br><span class="line">      <span class="comment">// 限定只在 src 目录下的 js/jsx 文件需要经 babel-loader 处理</span></span><br><span class="line">      <span class="comment">// 通常我们需要 loader 处理的文件都是存放在 src 目录</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>如上边这个例子，如果没有配置 <code>include</code>，所有的外部依赖模块都经过 Babel 处理的话，构建速度也是会收很大影响的。<br><a name="BKETp"></a></p>
<h2 id="4-减少-plugin-的消耗"><a href="#4-减少-plugin-的消耗" class="headerlink" title="4.减少 plugin 的消耗"></a>4.减少 plugin 的消耗</h2><p>webpack 的 plugin 会在构建的过程中加入其它的工作步骤，如果可以的话，适当地移除掉一些没有必要的 plugin。<br />这里再提一下 webpack 4.x 的 mode，区分 mode 会让 webpack 的构建更加有针对性，更加高效。例如当 mode 为 development 时，webpack 会避免使用一些提高应用代码加载性能的配置项，如 UglifyJsPlugin，ExtractTextPlugin 等，这样可以更快地启动开发环境的服务，而当 mode 为 production 时，webpack 会避免使用一些便于 debug 的配置，来提升构建时的速度，例如极其消耗性能的 Source Maps 支持。<br><a name="Gx85G"></a></p>
<h2 id="5-换种方式处理图片"><a href="#5-换种方式处理图片" class="headerlink" title="5.换种方式处理图片"></a>5.换种方式处理图片</h2><p>我们在前边的小节提到图片可以使用 webpack 的 image-webpack-loader 来压缩图片，在对 webpack 构建性能要求不高的时候，这样是一种很简便的处理方式，但是要考虑提高 webpack 构建速度时，这一块的处理就得重新考虑一下了，思考一下是否有必要在 webpack 每次构建时都处理一次图片压缩。<br />这里介绍一种解决思路，我们可以直接使用 imagemin 来做图片压缩，编写简单的命令即可。然后使用 pre-commit 这个类库来配置对应的命令，使其在 <code>git commit</code> 的时候触发，并且将要提交的文件替换为压缩后的文件。<br />这样提交到代码仓库的图片就已经是压缩好的了，以后在项目中再次使用到的这些图片就无需再进行压缩处理了，image-webpack-loader 也就没有必要了。<br><a name="RobGJ"></a></p>
<h2 id="6-使用-DLLPlugin"><a href="#6-使用-DLLPlugin" class="headerlink" title="6.使用 DLLPlugin"></a>6.使用 DLLPlugin</h2><p>DLLPlugin 是 webpack 官方提供的一个插件，也是用来分离代码的，和 <code>optimization.splitChunks</code>（3.x 版本的是 CommonsChunkPlugin）有异曲同工之妙，之所以把 DLLPlugin 放到 webpack 构建性能优化这一部分，是因为它的配置相对繁琐，如果项目不涉及性能优化这一块，基本上使用 <code>optimization.splitChunks</code> 即可。<br />我们来看一下 DLLPlugin 如何使用，使用这个插件时需要额外的一个构建配置，用来打包公共的那一部分代码，举个例子，假设这个额外配置是 <code>webpack.dll.config.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;vendor&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: [<span class="string">&#x27;lodash&#x27;</span>], <span class="comment">// 这个例子我们打包 lodash 作为公共类库</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;vendor.js&quot;</span>,</span><br><span class="line">    <span class="attr">library</span>: <span class="string">&quot;vendor_[hash]&quot;</span> <span class="comment">// 打包后对外暴露的类库名称</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;vendor_[hash]&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist/manifest.json&quot;</span>), <span class="comment">// 使用 DLLPlugin 在打包的时候生成一个 manifest 文件</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是我们正常的应用构建配置，在那个的基础上添加两个一个新的 <code>webpack.DllReferencePlugin</code> 配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      <span class="attr">manifest</span>: path.resolve(__dirname, <span class="string">&#x27;dist/manifest.json&#x27;</span>), </span><br><span class="line">      <span class="comment">// 指定需要用到的 manifest 文件，</span></span><br><span class="line">      <span class="comment">// webpack 会根据这个 manifest 文件的信息，分析出哪些模块无需打包，直接从另外的文件暴露出来的内容中获取</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构建的时候，我们需要优先使用 <code>webpack.dll.config.js</code> 来打包，如 <code>webpack -c webpack.dll.config.js --mode production</code>，构建后生成公共代码模块的文件 <code>vendor.js</code> 和 <code>manifest.json</code>，然后再进行应用代码的构建。<br />你会发现构建结果的应用代码中不包含 lodash 的代码内容，这一部分代码内容会放在 <code>vendor.js</code> 这个文件中，而你的应用要正常使用的话，需要在 HTML 文件中按顺序引用这两个代码文件，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vendor.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其实作用和 <code>optimization.splitChunks</code> 很相似，但是有个区别，DLLPlugin 构建出来的内容无需每次都重新构建，后续应用代码部分变更时，你不用再执行配置为 <code>webpack.dll.config.js</code> 这一部分的构建，沿用原本的构建结果即可，所以相比 <code>optimization.splitChunks</code>，使用 DLLPlugin 时，构建速度是会有显著提高的。<br />但是很显然，DLLPlugin 的配置要麻烦得多，并且需要关心你公共部分代码的变化，当你升级 lodash（即你的公共部分代码的内容变更）时，要重新去执行 <code>webpack.dll.config.js</code> 这一部分的构建，不然沿用的依旧是旧的构建结果，使用上并不如 <code>optimization.splitChunks</code> 来得方便。这是一种取舍，根据项目的实际情况采用合适的做法。<br />还有一点需要注意的是，html-webpack-plugin 并不会自动处理 DLLPlugin 分离出来的那个公共代码文件，我们需要自己处理这一部分的内容，可以考虑使用 add-asset-html-webpack-plugin，关于这一个的使用就不讲解了，详细参考官方的说明文档：使用 add-asset-html-webpack-plugin。<br><a name="YMyUS"></a></p>
<h1 id="webpack-4-x-的构建性能"><a href="#webpack-4-x-的构建性能" class="headerlink" title="webpack 4.x 的构建性能"></a>webpack 4.x 的构建性能</h1><p>从官方发布的 webpack 4.0 更新日志来看，webpack 4.0 版本做了很多关于提升构建性能的工作，我觉得比较重要的改进有这么几个：</p>
<ul>
<li>AST 可以直接从 loader 直接传递给 webpack，避免额外的解析，对这一个优化细节有兴趣的可以查看这个 PR。<br /></li>
<li>使用速度更快的 md4 作为默认的 hash 方法，对于大型项目来说，文件一多，需要 hash 处理的内容就多，webpack 的 hash 处理优化对整体的构建速度提升应该还是有一定的效果的。<br /></li>
<li>Node 语言层面的优化，如用 <code>for of</code> 替换 <code>forEach</code>，用 <code>Map</code> 和 <code>Set</code> 替换普通的对象字面量等等，这一部分就不展开讲了，有兴趣的同学可以去 webpack 的 PRs 寻找更多的内容。<br /></li>
<li>默认开启 uglifyjs-webpack-plugin 的 <code>cache</code> 和 <code>parallel</code>，即缓存和并行处理，这样能大大提高 production mode 下压缩代码的速度。<br /></li>
</ul>
<p>除此之外，还有比较琐碎的一些内容，可以查阅：<strong>webpack release 4.0</strong>，留意 <strong>performance</strong> 关键词。<br />很显然，webpack 的开发者们越来越关心 webpack 构建性能的问题，有一个关于 webpack 4.x 和 3.x 构建性能的简单对比：</p>
<blockquote>
<p>6 entries, dev mode, source maps off, using a bunch of loaders and plugins. dat speed ⚡️</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/186051/1581480528948-c3b63438-8967-4b03-b554-1824739aef9e.jpeg#align=left&display=inline&height=164&originHeight=164&originWidth=498&size=0&status=done&style=none&width=498">speed webpack of 4.x<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/186051/1581480529491-cc4e9bf8-d71c-4d0b-b22b-7f6834dff19a.jpeg#align=left&display=inline&height=154&originHeight=154&originWidth=440&size=0&status=done&style=none&width=440">speed webpack of 3.x<br />从这个对比的例子上看，4.x 的构建性能对比 3.x 是有很显著的提高，而 webpack 官方后续计划加入多核运算，持久化缓存等特性来进一步提升性能所以，及时更新 webpack 版本，也是提升构建性能的一个有效方式。<br><a name="3YB8E"></a></p>
<h1 id="webpack5新特性"><a href="#webpack5新特性" class="headerlink" title="webpack5新特性"></a>webpack5新特性</h1><p><a name="8gZ4A"></a></p>
<h2 id="1-编译器的优化"><a href="#1-编译器的优化" class="headerlink" title="1.编译器的优化"></a>1.编译器的优化</h2><p>如果大家读过Webpack的源码一定知道Compiler的重要性，在Webpack中充斥着大量的钩子和触发事件。<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/186051/1581480529430-df07eeb4-9a33-4ff4-9967-c62f17102e10.jpeg#align=left&display=inline&height=391&originHeight=570&originWidth=1080&size=0&status=done&style=none&width=740"><br />在新的版本中，编译器在使用完毕后应该被关闭，因为它们在进入或退出空闲状态时，拥有这些状态的 hook。 插件可以用这些 hook 来执行不太重要的工作（比如：持久性缓存把缓存慢慢地存储到磁盘上）。同时插件的作者应该预见到某些用户可能会忘记关闭编译器，所以 当编译器关闭所有剩下的工作时应尽快完成。 然后回调将会通知已彻底完成。当你升级到 v5 时，请确保在完成工作后使用 Node.js API 调用 Compiler.close。<br><a name="hoPkR"></a></p>
<h2 id="2-Node-js-polyfills-自动被移除"><a href="#2-Node-js-polyfills-自动被移除" class="headerlink" title="2.Node.js polyfills 自动被移除"></a>2.Node.js polyfills 自动被移除</h2><p>过去，Webpack 4版本附带了大多数 Node.js 核心模块的 polyfills，一旦前端使用了任何核心模块，这些模块就会自动应用，但是其实有些是不必要的。 V5中的尝试是自动停止 polyfilling 这些核心模块，并侧重于前端兼容的模块。当迁移到 v5时，最好尽可能使用前端兼容的模块，并尽可能手动添加核心模块的polyfills。 Webpack鼓励大家多提交自己的意见，因为这个更改可能会也可能不会进入最终的 v5版本。<br><a name="0Qcn7"></a></p>
<h2 id="3-打包大小限制"><a href="#3-打包大小限制" class="headerlink" title="3.打包大小限制"></a>3.打包大小限制</h2><p>在V4版本中默认情况下，仅能处理javascript的大小。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">            <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">                <span class="attr">commons</span>: &#123;</span><br><span class="line">                    <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;commons&quot;</span>,</span><br><span class="line">                    <span class="attr">minChunks</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">minSize</span>: <span class="string">&quot;数值&quot;</span>,</span><br><span class="line">                    <span class="attr">maxSize</span>: <span class="string">&quot;数值&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>V5版本之后，更加自由化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">            <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">                <span class="attr">commons</span>: &#123;</span><br><span class="line">                    <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;commons&quot;</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//最小的文件大小 超过之后将不予打包</span></span><br><span class="line">            <span class="attr">minSize</span>: &#123;</span><br><span class="line">                <span class="attr">javascript</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">style</span>: <span class="number">0</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//最大的文件 超过之后继续拆分</span></span><br><span class="line">            <span class="attr">maxSize</span>: &#123;</span><br><span class="line">                <span class="attr">javascript</span>: <span class="number">1</span>, <span class="comment">//故意写小的效果更明显</span></span><br><span class="line">                <span class="attr">style</span>: <span class="number">3000</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="R2caR"></a></p>
<h2 id="4-按需加载"><a href="#4-按需加载" class="headerlink" title="4.按需加载"></a>4.按需加载</h2><p>以前当我们想在index.js内部 import(./async.js”).then(…)的时候，如果我们什么也不加。V4会默认对这些文件生成一堆0.js,1.js,2.js…是多么的整齐.所以我们需要使用<br />import(/* webpackChunkName: “name” */ “module”) 才能化解这份尴尬。今天V5可以在开发模式中启用了一个新命名的块 id 算法，该算法提供块(以及文件名)可读的引用。 模块 ID 由其相对于上下文的路径确定。 块 ID 是由块的内容决定的，所以你不再需要使用Magic Comments。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src文件夹index.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./async.js&quot;</span>).then(<span class="function">(<span class="params">_</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(_.data);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello Webpack5&quot;</span>)</span><br><span class="line"><span class="comment">//src文件夹async.js</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">&quot;异步数据，测试&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> data;</span><br></pre></td></tr></table></figure>
<p>再次编译之后src_async_js.js 就躺在了dist里。如果这个时候去执行 npm run prod 会在dist里出现一个已数字开头的js文件。<br><a name="ehRbK"></a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面我们介绍了 webpack 打包的工资流程，以及优化 webpack 构建速度的一些方法：</p>
<ul>
<li>减少 <code>resolve</code> 的解析<br /></li>
<li>减少 plugin 的消耗<br /></li>
<li>换种方式处理图片<br /></li>
<li>使用 DLLPlugin<br /></li>
<li>积极更新 webpack 版本<br /></li>
</ul>
<p>当我们面对因项目过大而导致的构建性能问题时，我们也可以换个角度，思考在 webpack 之上的另外一些解决方案，不要过分依赖于 webpack。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/12/195-%E3%80%90Webpack%E3%80%91%E5%88%86%E6%9E%90Webpack%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/" data-id="ckts3ejyj00mr4d9kcjj87l6s" data-title="195-【Webpack】分析Webpack运行机制" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-194-【Web技术】用preload预加载页面资源" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/01/194-%E3%80%90Web%E6%8A%80%E6%9C%AF%E3%80%91%E7%94%A8preload%E9%A2%84%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E8%B5%84%E6%BA%90/" class="article-date">
  <time class="dt-published" datetime="2020-02-01T14:43:33.000Z" itemprop="datePublished">2020-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/01/194-%E3%80%90Web%E6%8A%80%E6%9C%AF%E3%80%91%E7%94%A8preload%E9%A2%84%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E8%B5%84%E6%BA%90/">194-【Web技术】用preload预加载页面资源</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>原文地址：<a target="_blank" rel="noopener" href="https://github.com/ProtoTeam/blog/blob/master/021.%E7%94%A8%20preload%20%E9%A2%84%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E8%B5%84%E6%BA%90.md">点击查看</a></p>
<p><br />作者简介 felix 蚂蚁金服·数据体验技术团队<br />本文主要介绍 preload 的使用，以及与 prefetch 的区别。然后会聊聊浏览器的加载优先级。<br />preload 提供了一种声明式的命令，让浏览器提前加载指定资源(加载后并不执行)，在需要执行的时候再执行。提供的好处主要是</p>
<ul>
<li>将加载和执行分离开，可不阻塞渲染和 document 的 onload 事件</li>
<li>提前加载指定资源，不再出现依赖的 font 字体隔了一段时间才刷出<br><a name="ks6Uq"></a><h2 id="如何使用-preload"><a href="#如何使用-preload" class="headerlink" title="如何使用 preload"></a>如何使用 preload</h2><a name="tsvZn"></a><h3 id="使用-link-标签创建"><a href="#使用-link-标签创建" class="headerlink" title="使用 link 标签创建"></a>使用 link 标签创建</h3></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 link 标签静态标记需要预加载的资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/path/to/style.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或使用脚本动态创建一个 link 标签后插入到 head 头部 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">&#x27;link&#x27;</span>);</span></span><br><span class="line"><span class="javascript">link.rel = <span class="string">&#x27;preload&#x27;</span>;</span></span><br><span class="line"><span class="javascript">link.as = <span class="string">&#x27;style&#x27;</span>;</span></span><br><span class="line"><span class="javascript">link.href = <span class="string">&#x27;/path/to/style.css&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.head.appendChild(link);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a name="tgm88"></a></p>
<h3 id="使用-HTTP-响应头的-Link-字段创建"><a href="#使用-HTTP-响应头的-Link-字段创建" class="headerlink" title="使用 HTTP 响应头的 Link 字段创建"></a>使用 HTTP 响应头的 Link 字段创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Link: &lt;https://example.com/other/styles.css&gt;; rel=preload; as=style</span><br></pre></td></tr></table></figure>
<p>如我们常用到的 antd 会依赖一个 CDN 上的 font.js 字体文件，我们可以设置为提前加载，以及有一些模块虽然是按需异步加载，但在某些场景下知道其必定会加载的，则可以设置 preload 进行预加载，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span>   <span class="attr">href</span>=<span class="string">&quot;https://at.alicdn.com/t/font_zck90zmlh7hf47vi.woff&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://a.xxx.com/xxx/PcCommon.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://a.xxx.com/xxx/TabsPc.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a name="cx8Xy"></a></p>
<h2 id="如何判断浏览器是否支持-preload"><a href="#如何判断浏览器是否支持-preload" class="headerlink" title="如何判断浏览器是否支持 preload"></a>如何判断浏览器是否支持 preload</h2><p>目前我们支持的浏览器主要为高版本 Chrome，所以可放心使用 preload 技术。 其他环境在 caniuse.com 上查到的支持情况如下： <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/a53b19d02cb36222be6055e57c7c5a9e7c6e118b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396366623261393762613f773d39333226683d34313826663d706e6726733d3636343233"><img src="https://camo.githubusercontent.com/a53b19d02cb36222be6055e57c7c5a9e7c6e118b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396366623261393762613f773d39333226683d34313826663d706e6726733d3636343233#align=left&display=inline&height=418&originHeight=418&originWidth=932&status=done&style=none&width=932"></a> 在不支持 preload 的浏览器环境中，会忽略对应的 link 标签，而若需要做特征检测的话，则：<br /></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isPreloadSupported = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">&#x27;link&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> relList = link.relList;</span><br><span class="line">  <span class="keyword">if</span> (!relList || !relList.supports) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> relList.supports(<span class="string">&#x27;preload&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a name="OEzNR"></a></p>
<h2 id="如何区分-preload-和-prefetch"><a href="#如何区分-preload-和-prefetch" class="headerlink" title="如何区分 preload 和 prefetch"></a>如何区分 preload 和 prefetch</h2><ul>
<li>preload   是告诉浏览器页面<strong>必定</strong>需要的资源，浏览器<strong>一定会</strong>加载这些资源；</li>
<li>prefetch 是告诉浏览器页面<strong>可能</strong>需要的资源，浏览器<strong>不一定会</strong>加载这些资源。</li>
</ul>
<p>preload 是确认会加载指定资源，如在我们的场景中，x-report.js 初始化后一定会加载 PcCommon.js 和 TabsPc.js, 则可以预先 preload 这些资源；<br />prefetch 是预测会加载指定资源，如在我们的场景中，我们在页面加载后会初始化首屏组件，当用户滚动页面时，会拉取第二屏的组件，若能预测用户行为，则可以 prefetch 下一屏的组件。<br><a name="M0Eom"></a></p>
<h2 id="preload-将提升资源加载的优先级"><a href="#preload-将提升资源加载的优先级" class="headerlink" title="preload 将提升资源加载的优先级"></a>preload 将提升资源加载的优先级</h2><p>使用 preload 前，在遇到资源依赖时进行加载： <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/32a96d8b852941951a09f21c744b20fcc7181108/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396366633038643333653f773d34383326683d373526663d706e6726733d3133363530"><img src="https://camo.githubusercontent.com/32a96d8b852941951a09f21c744b20fcc7181108/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396366633038643333653f773d34383326683d373526663d706e6726733d3133363530#align=left&display=inline&height=75&originHeight=75&originWidth=483&status=done&style=none&width=483"></a> 使用 preload 后，不管资源是否使用都将提前加载： <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/2325935bfcdde6523177199c977fb369d43629dd/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396366633337393564303f773d34393626683d373526663d706e6726733d3133333737"><img src="https://camo.githubusercontent.com/2325935bfcdde6523177199c977fb369d43629dd/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396366633337393564303f773d34393626683d373526663d706e6726733d3133333737#align=left&display=inline&height=75&originHeight=75&originWidth=496&status=done&style=none&width=496"></a> 可以看到，preload 的资源加载顺序将被提前： <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/16c914616946cbfc8204ae9251d5687ca499df98/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396366643938336261313f773d35323226683d31393326663d706e6726733d3430343832"><img src="https://camo.githubusercontent.com/16c914616946cbfc8204ae9251d5687ca499df98/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396366643938336261313f773d35323226683d31393326663d706e6726733d3430343832#align=left&display=inline&height=193&originHeight=193&originWidth=522&status=done&style=none&width=522"></a><br><a name="OMYMV"></a></p>
<h2 id="避免滥用-preload"><a href="#避免滥用-preload" class="headerlink" title="避免滥用 preload"></a>避免滥用 preload</h2><p>使用 preload 后，Chrome 会有一个警告： <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/8063027c3e5ef347c7de2b90777ad08283cf310b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396430303939666632373f773d37383226683d333426663d706e6726733d3138373537"><img src="https://camo.githubusercontent.com/8063027c3e5ef347c7de2b90777ad08283cf310b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396430303939666632373f773d37383226683d333426663d706e6726733d3138373537#align=left&display=inline&height=34&originHeight=34&originWidth=782&status=done&style=none&width=782"></a><br />如上文所言，若不确定资源是必定会加载的，则不要错误使用 preload，以免本末倒置，给页面带来更沉重的负担。<br />当然，可以在 PC 中使用 preload 来刷新资源的缓存，但在移动端则需要特别慎重，因为可能会浪费用户的带宽。<br><a name="ZhtoH"></a></p>
<h2 id="避免混用-preload-和-prefetch"><a href="#避免混用-preload-和-prefetch" class="headerlink" title="避免混用 preload 和 prefetch"></a>避免混用 preload 和 prefetch</h2><p>preload 和 prefetch 混用的话，并不会复用资源，而是会重复加载。<br /></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;preload&quot;</span>   href=<span class="string">&quot;https://at.alicdn.com/t/font_zck90zmlh7hf47vi.woff&quot;</span> <span class="keyword">as</span>=<span class="string">&quot;font&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span>  <span class="attr">href</span>=<span class="string">&quot;https://at.alicdn.com/t/font_zck90zmlh7hf47vi.woff&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><br />使用 preload 和 prefetch 的逻辑可能不是写到一起，但一旦发生对用一资源 preload 或 prefetch 的话，会带来双倍的网络请求，这点通过 Chrome 控制台的网络面板就能甄别： <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/0bf61a7a7099f6306bd092e76b3ea3d056aa9749/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396430323461383631623f773d36343926683d31313126663d706e6726733d3231353937"><img src="https://camo.githubusercontent.com/0bf61a7a7099f6306bd092e76b3ea3d056aa9749/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396430323461383631623f773d36343926683d31313126663d706e6726733d3231353937#align=left&display=inline&height=111&originHeight=111&originWidth=649&status=done&style=none&width=649"></a><br><a name="9HXj8"></a></p>
<h2 id="避免错用-preload-加载跨域资源"><a href="#避免错用-preload-加载跨域资源" class="headerlink" title="避免错用 preload 加载跨域资源"></a>避免错用 preload 加载跨域资源</h2><p>若 css 中有应用于已渲染到 DOM 树的元素的选择器，且设置了 @font-face 规则时，会触发字体文件的加载。 而字体文件加载中时，DOM 中的这些元素，是处于不可见的状态。对已知必加载的 font 文件进行预加载，除了有性能提升外，更有体验优化的效果。<br />在我们的场景中，已知 antd.css 会依赖 font 文件，所以我们可以对这个字体文件进行 preload:<br /></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://at.alicdn.com/t/font_zck90zmlh7hf47vi.woff&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然而我发现这个文件加载了两次： <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/3b86da05e9f966d783bbb2da79779ccafd1c8a5f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396433396536613335353f773d37313226683d31313126663d706e6726733d3231373938"><img src="https://camo.githubusercontent.com/3b86da05e9f966d783bbb2da79779ccafd1c8a5f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396433396536613335353f773d37313226683d31313126663d706e6726733d3231373938#align=left&display=inline&height=111&originHeight=111&originWidth=712&status=done&style=none&width=712"></a> <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/bb1e8eb2fef3d56d35278677034312b2f1406370/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396433616134613062643f773d3130333926683d373526663d706e6726733d3231343235"><img src="https://camo.githubusercontent.com/bb1e8eb2fef3d56d35278677034312b2f1406370/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396433616134613062643f773d3130333926683d373526663d706e6726733d3231343235#align=left&display=inline&height=75&originHeight=75&originWidth=1039&status=done&style=none&width=1039"></a> <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/05a3695b41e7bfa14ba22f91c8b1e67bf9f34ce3/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396433616262326637653f773d3130343726683d373526663d706e6726733d3230353038"><img src="https://camo.githubusercontent.com/05a3695b41e7bfa14ba22f91c8b1e67bf9f34ce3/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396433616262326637653f773d3130343726683d373526663d706e6726733d3230353038#align=left&display=inline&height=75&originHeight=75&originWidth=1047&status=done&style=none&width=1047"></a><br />原因是对跨域的文件进行 preload 的时候，我们必须加上 crossorigin 属性：<br /></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">crossorigin</span> <span class="attr">href</span>=<span class="string">&quot;https://at.alicdn.com/t/font_zck90zmlh7hf47vi.woff&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再看一下网络请求，就变成一条了。<br />W3 规范是这么解释的：</p>
<blockquote>
<p>Preload links for CORS enabled resources, such as fonts or images with a crossorigin attribute, must also include a crossorigin attribute, in order for the resource to be properly used.</p>
</blockquote>
<p>那为何会有两条请求，且优先级不一致，又没有命中缓存呢？这就得引出下一个话题来解释了。<br><a name="x337C"></a></p>
<h2 id="不同资源加载的优先级规则"><a href="#不同资源加载的优先级规则" class="headerlink" title="不同资源加载的优先级规则"></a>不同资源加载的优先级规则</h2><p>我们先来看一张图： <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/0083c38840fa8d30302642b286aa2a5cedb05515/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396433666639663363323f773d36383726683d36303126663d706e6726733d3639323637"><img src="https://camo.githubusercontent.com/0083c38840fa8d30302642b286aa2a5cedb05515/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396433666639663363323f773d36383726683d36303126663d706e6726733d3639323637#align=left&display=inline&height=601&originHeight=601&originWidth=687&status=done&style=none&width=687"></a></p>
<blockquote>
<p>这张表详见：Chrome Resource Priorities and Scheduling</p>
</blockquote>
<p>这张图表示的是，在 Chrome 46 以后的版本中，不同的资源在浏览器渲染的不同阶段进行加载的优先级。 在这里，我们只需要关注 DevTools Priority 体现的优先级，一共分成五个级别：</p>
<ul>
<li>Highest 最高</li>
<li>Hight 高</li>
<li>Medium 中等</li>
<li>Low 低</li>
<li>Lowest 最低</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/fbc06ea64585e49cd2d55143d5886729e7637550/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396433616463366163343f773d36383926683d31333626663d706e6726733d3232363637"><img src="https://camo.githubusercontent.com/fbc06ea64585e49cd2d55143d5886729e7637550/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396433616463366163343f773d36383926683d31333626663d706e6726733d3232363637#align=left&display=inline&height=136&originHeight=136&originWidth=689&status=done&style=none&width=689"></a><br><a name="UiMyD"></a></p>
<h3 id="html-主要资源，其优先级是最高的"><a href="#html-主要资源，其优先级是最高的" class="headerlink" title="html 主要资源，其优先级是最高的"></a>html 主要资源，其优先级是最高的</h3><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/2dcadd29eedeb192aec8f4f4716909155697b35f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396434383161316435333f773d36383626683d31363526663d706e6726733d3235383035"><img src="https://camo.githubusercontent.com/2dcadd29eedeb192aec8f4f4716909155697b35f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396434383161316435333f773d36383626683d31363526663d706e6726733d3235383035#align=left&display=inline&height=165&originHeight=165&originWidth=686&status=done&style=none&width=686"></a> <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/e8a2a2dd896778cbd12d25db3a5a7d8ca0d295a6/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396436363437356232303f773d35303126683d363926663d706e6726733d3133383735"><img src="https://camo.githubusercontent.com/e8a2a2dd896778cbd12d25db3a5a7d8ca0d295a6/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396436363437356232303f773d35303126683d363926663d706e6726733d3133383735#align=left&display=inline&height=69&originHeight=69&originWidth=501&status=done&style=none&width=501"></a><br><a name="NdM9N"></a></p>
<h3 id="css-样式资源，其优先级也是最高的"><a href="#css-样式资源，其优先级也是最高的" class="headerlink" title="css 样式资源，其优先级也是最高的"></a>css 样式资源，其优先级也是最高的</h3><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/35db8fc2e39befca82df89f1b6ed65b307435e03/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396436363535636139653f773d36383426683d31383226663d706e6726733d3238383132"><img src="https://camo.githubusercontent.com/35db8fc2e39befca82df89f1b6ed65b307435e03/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396436363535636139653f773d36383426683d31383226663d706e6726733d3238383132#align=left&display=inline&height=182&originHeight=182&originWidth=684&status=done&style=none&width=684"></a> CSS(match) 指的是对已有的 DOM 具备规则的有效的样式文件。 <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/f3339d352fb837f443411d81eade8c1830160086/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396436363865326430353f773d34373526683d31393126663d706e6726733d3432303037"><img src="https://camo.githubusercontent.com/f3339d352fb837f443411d81eade8c1830160086/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396436363865326430353f773d34373526683d31393126663d706e6726733d3432303037#align=left&display=inline&height=191&originHeight=191&originWidth=475&status=done&style=none&width=475"></a><br><a name="6nWxH"></a></p>
<h3 id="script-脚本资源，优先级不一"><a href="#script-脚本资源，优先级不一" class="headerlink" title="script 脚本资源，优先级不一"></a>script 脚本资源，优先级不一</h3><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/8d07bf6d105054d9b25a3b37e02b3ed8f3de46f6/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396436643335306364343f773d36383626683d32303026663d706e6726733d3335303937"><img src="https://camo.githubusercontent.com/8d07bf6d105054d9b25a3b37e02b3ed8f3de46f6/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396436643335306364343f773d36383626683d32303026663d706e6726733d3335303937#align=left&display=inline&height=200&originHeight=200&originWidth=686&status=done&style=none&width=686"></a> <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/2cc1b27776179ea995f774fbdeca8853277788c7/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396437313465326235643f773d34373626683d32343726663d706e6726733d3439343232"><img src="https://camo.githubusercontent.com/2cc1b27776179ea995f774fbdeca8853277788c7/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396437313465326235643f773d34373626683d32343726663d706e6726733d3439343232#align=left&display=inline&height=247&originHeight=247&originWidth=476&status=done&style=none&width=476"></a> 前三个 js 文件是写死在 html 中的静态资源依赖，后三个 js 文件是根据首屏按需异步加载的组件资源依赖，这正验证了这个规则。<br><a name="4tXNd"></a></p>
<h3 id="font-字体资源，优先级不一"><a href="#font-字体资源，优先级不一" class="headerlink" title="font 字体资源，优先级不一"></a>font 字体资源，优先级不一</h3><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/72232d2ff945fd1e52f09747a698202d670b2700/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396437356538396261643f773d36383626683d31363426663d706e6726733d3236373231"><img src="https://camo.githubusercontent.com/72232d2ff945fd1e52f09747a698202d670b2700/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396437356538396261643f773d36383626683d31363426663d706e6726733d3236373231#align=left&display=inline&height=164&originHeight=164&originWidth=686&status=done&style=none&width=686"></a> <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/cb3fd05528923ceaea1295d1839bbf1b8d4d3bc2/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396439323838323537393f773d34373226683d31313426663d706e6726733d3230383030"><img src="https://camo.githubusercontent.com/cb3fd05528923ceaea1295d1839bbf1b8d4d3bc2/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396439323838323537393f773d34373226683d31313426663d706e6726733d3230383030#align=left&display=inline&height=114&originHeight=114&originWidth=472&status=done&style=none&width=472"></a> css 样式文件中有一个 @font-face 依赖一个 font 文件，样式文件中依赖的字体文件加载的优先级是 Highest； 在使用 preload 预加载这个 font 文件时，若不指定 crossorigin 属性(即使同源)，则会采用匿名模式的 CORS 去加载，优先级是 High，看下图对比： 第一条 High 优先级也就是 preload 的请求： <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/56687cb66b6fe073c07a1ba3cdf80cb65a8bd39b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396439353964313736653f773d3233393626683d3131383826663d706e6726733d363537373039"><img src="https://camo.githubusercontent.com/56687cb66b6fe073c07a1ba3cdf80cb65a8bd39b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396439353964313736653f773d3233393626683d3131383826663d706e6726733d363537373039#align=left&display=inline&height=1188&originHeight=1188&originWidth=2396&status=done&style=none&width=2396"></a><br />第二条 Highest 也就是样式引入的请求： <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/e90287962e1e99b941d9ac66c6121ad57a457e0f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396439623437616333323f773d3233323226683d3131363226663d706e6726733d363434373738"><img src="https://camo.githubusercontent.com/e90287962e1e99b941d9ac66c6121ad57a457e0f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396439623437616333323f773d3233323226683d3131363226663d706e6726733d363434373738#align=left&display=inline&height=1162&originHeight=1162&originWidth=2322&status=done&style=none&width=2322"></a><br />可以看到，在 preload 的请求中，缺少了一个 origin 的请求头字段，表示这个请求是匿名的请求。 让这两个请求能共用缓存的话，目前的解法是给 preload 加上 crossorigin 属性，这样请求头会带上 origin, 且与样式引入的请求同源，从而做到命中缓存：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">crossorigin</span> <span class="attr">href</span>=<span class="string">&quot;https://at.alicdn.com/t/font_zck90zmlh7hf47vi.woff&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这么请求就只剩一个： <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/2d65a7b5806f1975158bbcc1a406475d66513f5f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396439623433343435353f773d34373526683d383126663d706e6726733d3131393234"><img src="https://camo.githubusercontent.com/2d65a7b5806f1975158bbcc1a406475d66513f5f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396439623433343435353f773d34373526683d383126663d706e6726733d3131393234#align=left&display=inline&height=81&originHeight=81&originWidth=475&status=done&style=none&width=475"></a> <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/01e7a480e8bc1700b211dc8d2b51cc4e4246060d/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396461336436663333303f773d3232393826683d3131373626663d706e6726733d353939353832"><img src="https://camo.githubusercontent.com/01e7a480e8bc1700b211dc8d2b51cc4e4246060d/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396461336436663333303f773d3232393826683d3131373626663d706e6726733d353939353832#align=left&display=inline&height=1176&originHeight=1176&originWidth=2298&status=done&style=none&width=2298"></a> 在网络瀑布流图中，也显示成功预加载且后续命中缓存不再二次加载： <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/eeae7271a728a5b8be46d703fd3ae8e4cbc2d309/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396461623636336332353f773d36363226683d383626663d706e6726733d3131373839"><img src="https://camo.githubusercontent.com/eeae7271a728a5b8be46d703fd3ae8e4cbc2d309/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f322f31312f313631383263396461623636336332353f773d36363226683d383626663d706e6726733d3131373839#align=left&display=inline&height=86&originHeight=86&originWidth=662&status=done&style=none&width=662"></a><br><a name="EwGaK"></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>preload 是个好东西，能告诉浏览器提前加载当前页面必须的资源，将加载与解析执行分离开，做得好可以对首次渲染带来不小的提升，但要避免滥用，区分其与 prefetch 的关系，且需要知道 preload 不同资源时的网络优先级差异。<br />preload 加载页面必需的资源如 CDN 上的字体文件，与 prefetch 预测加载下一屏数据，兴许是个不错的组合。<br />参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.w3.org/TR/preload/">https://www.w3.org/TR/preload/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3.org/TR/resource-hints/">https://www.w3.org/TR/resource-hints/</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/web/updates/2016/03/link-rel-preload">Prioritizing Your Resources with link rel=’preload’</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf">Preload, Prefetch And Priorities in Chrome</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/reloading/a-link-rel-preload-analysis-from-the-chrome-data-saver-team-5edf54b08715">A Link: rel=preload Analysis From the Chrome Data Saver Team</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/01/194-%E3%80%90Web%E6%8A%80%E6%9C%AF%E3%80%91%E7%94%A8preload%E9%A2%84%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E8%B5%84%E6%BA%90/" data-id="ckts3ejyi00mp4d9k8o5icbyw" data-title="194-【Web技术】用preload预加载页面资源" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-193-【中间件】从koa和redux看如何设计中间件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/21/193-%E3%80%90%E4%B8%AD%E9%97%B4%E4%BB%B6%E3%80%91%E4%BB%8Ekoa%E5%92%8Credux%E7%9C%8B%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2020-01-20T16:01:36.000Z" itemprop="datePublished">2020-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/21/193-%E3%80%90%E4%B8%AD%E9%97%B4%E4%BB%B6%E3%80%91%E4%BB%8Ekoa%E5%92%8Credux%E7%9C%8B%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%AD%E9%97%B4%E4%BB%B6/">193-【中间件】从koa和redux看如何设计中间件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>编者按：本文作者林向东，360奇舞团前端工程师。<br />中间件是一种实现「关注点分离」的设计模式，有多种实现方式，本文仅探讨koa/redux是如何设计中间件。该模式有两个特点：</p>
<ul>
<li>中间件middle是一个函数</li>
<li>middle有个next参数，也是函数，代表下个要执行的中间件。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function m1(next) &#123;</span><br><span class="line">  console.log(&quot;m1&quot;);</span><br><span class="line">  next();</span><br><span class="line">  console.log(&quot;v1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function m2(next) &#123;</span><br><span class="line">  console.log(&quot;m2&quot;);</span><br><span class="line">  next();</span><br><span class="line">  console.log(&quot;v2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function m3() &#123;</span><br><span class="line">  console.log(&quot;m3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如上所示：中间件 m1-&gt;m2-&gt;m3执行，打印结果为 m1-&gt;m2-&gt;m3-&gt;v2-&gt;v1。这种模式有个形象的名字，_洋葱模型_。但现在我们暂时忘记这些名字，就想想如何实现中间件（函数）的联动吧。有两种思路，第一是递归；第二是链式调用。<br><a name="5nPjD"></a><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2>设置一个数组按顺序存储函数，根据 index 值，按顺序一个个执行，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  function dispath(index) &#123;</span><br><span class="line">    if (index === arr.length) return;</span><br><span class="line">    const route = arr[index];</span><br><span class="line">    const next = () =&gt; dispath(index + 1); // 递归执行数组中下一个函数</span><br><span class="line">    return route(next);</span><br><span class="line">  &#125;</span><br><span class="line">  dispath(0);</span><br><span class="line">&#125;</span><br><span class="line">compose(middles); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
<a name="l3Vp1"></a><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2>将函数当作成参数传给上一个中间件，这样前一个中间件执行完就可以执行下一个中间件。<br><a name="Cxp1T"></a><h3 id="1、直接调用："><a href="#1、直接调用：" class="headerlink" title="1、直接调用："></a>1、直接调用：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1(() =&gt; m2(() =&gt; m3())); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br><span class="line">// m2的参数next是 () =&gt; m3()</span><br><span class="line">// m1的参数next是 () =&gt; m2(() =&gt; m3())</span><br></pre></td></tr></table></figure>
此种方法虽然可行，但是 m1，m2，m3 都是写死的，不是公共方法。<br><a name="SVJwr"></a><h3 id="2、构建next的函数createFn："><a href="#2、构建next的函数createFn：" class="headerlink" title="2、构建next的函数createFn："></a>2、构建next的函数createFn：</h3>我们观察到在传递参数时，m3 和 m2 都变成函数再传入，那这个变成函数的过程是否能提取：如下，参数 middle 是中间件，参数 next 是接下来要执行的函数。转换后 next 变成 middle 的参数。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createFn(middle, next) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    middle(next);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 需要先将后面的中间件变成我们需要的 next 函数：</span><br><span class="line">const fn3 = createFn(m3, null);</span><br><span class="line">const fn2 = createFn(m2, fn3);</span><br><span class="line">const fn1 = createFn(m1, fn2);</span><br><span class="line">fn1(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
这里 fn3/fn2/fn1 也是固定的，但我们看出这些中间状态变量，可以隐藏掉，统一用 next 代替：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let next = () =&gt; &#123;&#125;;</span><br><span class="line">next = createFn(m3, null);</span><br><span class="line">next = createFn(m2, next);</span><br><span class="line">next = createFn(m1, next);</span><br><span class="line">next(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
优化如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let next = () =&gt; &#123;&#125;;</span><br><span class="line">// 倒序</span><br><span class="line">for (let i = middles.length; i &gt;= 0; i--) &#123;</span><br><span class="line">  next = createFn(middles[i], next);</span><br><span class="line">&#125;</span><br><span class="line">next(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
<a name="iM3ym"></a><h3 id="3、redux-的-reduceRight"><a href="#3、redux-的-reduceRight" class="headerlink" title="3、redux 的 reduceRight"></a>3、redux 的 reduceRight</h3>仔细观察上面这种倒序，且每次拿上次的值进行计算的方法，是不是很像 reduceRight。（好吧，或许我们看不出来，但是早期 redux 就是这么实现的，我们直接拿过来研究）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduceRight(</span><br><span class="line">    (a, b) =&gt; &#123;</span><br><span class="line">      // b是middle，a是next，</span><br><span class="line">      return () =&gt; b(a); // 每次返回的是一个函数，执行这个函数为middle(next)，即b(a)</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; &#123;&#125; // 初始化的a值，空函数</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middles);</span><br><span class="line">mid(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
<a name="q7qBo"></a><h3 id="4、redux-的-reduce"><a href="#4、redux-的-reduce" class="headerlink" title="4、redux 的 reduce"></a>4、redux 的 reduce</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduce((a, b) =&gt; &#123;</span><br><span class="line">    return (...arg) =&gt; a(() =&gt; b(...arg)); // a 是 next函数，b是middle函数</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middles);</span><br><span class="line">mid(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
改成这种正序的方式，反而不好理解。尝试解释一下：a 是 next 函数，b 是 middle 函数。(…arg) =&gt; a(() =&gt; b(…arg)) 这简直就是我们最初这种写法 m1(() =&gt; m2(() =&gt; m3())) 的直接映射。摘抄一下这篇参考一作者的解释，感兴趣的同学可自行推导一下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 第 1 次 reduce 的返回值，下一次将作为 a</span><br><span class="line">arg =&gt; fn1(() =&gt; fn2(arg));</span><br><span class="line">// 第 2 次 reduce 的返回值，下一次将作为 a</span><br><span class="line">arg =&gt; (arg =&gt; fn1(() =&gt; fn2(arg)))(() =&gt; fn3(arg));</span><br><span class="line">// 等价于...</span><br><span class="line">arg =&gt; fn1(() =&gt; fn2(() =&gt; fn3(arg)));</span><br><span class="line">// 执行最后返回的函数连接中间件，返回值等价于...</span><br><span class="line">fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; &#123;&#125;)));</span><br></pre></td></tr></table></figure>
明白reduceRight到reduce转换不是最关键的，关键的是明白上面几种写法让我们能链式调用函数。<br><a name="i1JRO"></a><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2>设计一个中间件模式，怎么能少得了参数的传递。我们先想想<strong>如何组织我们中间件</strong>：很明显，我们通过 next 执行下个中间件，那么传值给下个中间件就是给 next 添加参数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function m1(next) &#123;</span><br><span class="line">  console.log(&quot;m1&quot;);</span><br><span class="line">  next(&quot;v2&quot;); // 将&#x27;v2&#x27;传给下个中间件m2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
那么 m2 该怎么获取这个值呢？因为 next 代表 m2 执行后的值，next 传递参数就是说 m2 需要返回函数，该函数的参数就是传递的值，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function m2(next) &#123;</span><br><span class="line">  return function(action) &#123;</span><br><span class="line">    // 这个action就是上一个函数传来的&#x27;v2&#x27;</span><br><span class="line">    next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这种写法等价于：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const m2 = next =&gt; action =&gt; &#123;</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
所以按照上面这种方式组织我们的中间件，我们就既能链式执行又能传递参数。如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const m1 = next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;m1&quot;, action);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br><span class="line">const m2 = next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;m2&quot;, action);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br><span class="line">const m3 = next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;m3&quot;, action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
那我们如何实现呢？<br><a name="CdlL8"></a><h3 id="1、直接调用：-1"><a href="#1、直接调用：-1" class="headerlink" title="1、直接调用："></a>1、直接调用：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1(arg =&gt; m2(() =&gt; m3()(arg))(arg))(&quot;666&quot;);</span><br><span class="line">// 打印：m1,m2,m3都打印666</span><br></pre></td></tr></table></figure>
<a name="uEuf6"></a><h3 id="2、创建createFn函数："><a href="#2、创建createFn函数：" class="headerlink" title="2、创建createFn函数："></a>2、创建createFn函数：</h3>createFn返回的函数添加了参数action，代表了中间件之间的参数。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 我们给返回的函数加上参数action并执行</span><br><span class="line">function createFn(middle, next) &#123;</span><br><span class="line">  return function (action) &#123;</span><br><span class="line">    middle(next)(action);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">let next = () =&gt; &#123;&#125;;</span><br><span class="line">for (let i = middles.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">  next = createFn(middles[i], next);</span><br><span class="line">&#125;</span><br><span class="line">next(&quot;666&quot;); // 打印：m1,m2,m3都打印666</span><br></pre></td></tr></table></figure>
<a name="MGpsi"></a><h3 id="3、-redux-的-reduceRight-与-reduce："><a href="#3、-redux-的-reduceRight-与-reduce：" class="headerlink" title="3、 redux 的 reduceRight 与 reduce："></a>3、 redux 的 reduceRight 与 reduce：</h3>返回的结果直接执行，因为我们加了一层返回函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduceRight(</span><br><span class="line">    (a, b) =&gt; b(a), // 注意这里，上个版本返回的是函数() =&gt; b(a)；这个版本变成b(a)，直接执行了，原因是我们中间件返回函数，所以这里需要将其执行</span><br><span class="line">    () =&gt; &#123;&#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middles);</span><br><span class="line">mid(&quot;666&quot;); // 打印：m1,m2,m3都打印666</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduce((a, b) =&gt; (...arg) =&gt; a(b(...arg))); // 这边也是，从() =&gt; b(..arg)变成b(..arg)</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middles);</span><br><span class="line">mid(&quot;666&quot;); // 打印：m1,m2,m3都打印666</span><br></pre></td></tr></table></figure>
<a name="7ZAgx"></a><h2 id="共同的属性"><a href="#共同的属性" class="headerlink" title="共同的属性"></a>共同的属性</h2>现在我们完成了中间件的链式调用和参数传递，已完成一个简单的中间件。但是如果我们这里不是普通的中间价，而是 redux 的中间件。我们想要这些中间件都拥有一个初始化的 store，该如何处理呢？熟悉 redux 的朋友肯定知道中间件最后写成这样：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const m1 = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;store1&quot;, store);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br><span class="line">const m2 = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;store2&quot;, store);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br><span class="line">const m3 = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;store3&quot;, store);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
我们还是按照上面几个步骤来实现一下，最后讲讲为什么能这么设计：<br><a name="Rcud0"></a><h3 id="1、-直接调用"><a href="#1、-直接调用" class="headerlink" title="1、 直接调用"></a>1、 直接调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const store = &#123; name: &quot;redux&quot; &#125;;</span><br><span class="line">// 基本写法，我们将参数传给每个中间件</span><br><span class="line">m1(arg =&gt; m2(() =&gt; m3()(arg))(arg))(store);</span><br></pre></td></tr></table></figure>
<a name="EiqgE"></a><h3 id="2-中间件先执行一遍将-store-传入进去"><a href="#2-中间件先执行一遍将-store-传入进去" class="headerlink" title="2. 中间件先执行一遍将 store 传入进去"></a>2. 中间件先执行一遍将 store 传入进去</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const store = &#123; name: &quot;redux&quot; &#125;;</span><br><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">const middlesWithStore = middles.map(middle =&gt; middle(store)); // 这里执行了第一遍，将store传进来</span><br><span class="line">function createFn(middle, next) &#123;</span><br><span class="line">  return action =&gt; middle(next)(action);</span><br><span class="line">&#125;</span><br><span class="line">let next = () =&gt; () =&gt; &#123;&#125;;</span><br><span class="line">for (let i = middlesWithStore.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">  next = createFn(middlesWithStore[i], next);</span><br><span class="line">&#125;</span><br><span class="line">next(store); // 打印：store1,store2,store3 &#123; name: &#x27;redux&#x27; &#125;</span><br></pre></td></tr></table></figure>
<a name="nUik9"></a><h3 id="3、-reduceRight-和-reduce-："><a href="#3、-reduceRight-和-reduce-：" class="headerlink" title="3、 reduceRight 和 reduce ："></a>3、 reduceRight 和 reduce ：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const store = &#123; name: &quot;redux&quot; &#125;;</span><br><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">const middlesWithStore = middles.map(middle =&gt; middle(store)); // 这里执行了第一遍，将store传进来</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middlesWithStore)();</span><br><span class="line">mid(store); // 打印：store1,store2,store3 &#123; name: &#x27;redux&#x27; &#125;</span><br></pre></td></tr></table></figure>
这里看起来简单，就是先执行一遍中间件，<strong>但为什么可以先执行一次函数将数据（store）传进去？而且这个数据在后来的调用中能被访问到</strong>？这背后涉及到的基础知识是函数柯里化和闭包：<br><a name="tXLDh"></a><h2 id="柯里化与闭包"><a href="#柯里化与闭包" class="headerlink" title="柯里化与闭包"></a>柯里化与闭包</h2><a name="Z0jD1"></a><h3 id="1、柯里化"><a href="#1、柯里化" class="headerlink" title="1、柯里化"></a>1、柯里化</h3>柯里化是使用匿名单参数函数来实现多参数函数的方法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const m1 = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;store1&quot;, store);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
上面这种写法，我们说是将中间件 m1 柯里化了，它的特点是每次只传一个参数，返回的是新的函数。<strong>返回新函数这个特点很重要，因为函数可以在其他地方再调用，所以本来一个连续的动作被打断了，变成了可以延迟执行，也可以称为参数前置</strong>。当我们执行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const middlesWithStore = middles.map(middle =&gt; middle(store));</span><br></pre></td></tr></table></figure>
相当于给每个中间件都添加了 store 属性，而且返回的是函数，可以等到你需要用它的时候再去使用。这就是柯里化的好处。<br><a name="fTUee"></a><h3 id="2、闭包"><a href="#2、闭包" class="headerlink" title="2、闭包"></a>2、闭包</h3>闭包：函数与其自由变量组成的环境，自由变量指不存在函数内部的变量。当函数按照值传递的方式在其他地方被调用时，产生了闭包。<br />上面的 m1 可以写成下面这种格式，可以知道柯里化中间函数处于同一闭包，所以尽管我们是在其他地方调用了 next(action)，但还是保存了最开始初始化的作用域，实现了真正的函数分开执行。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function m1(store) &#123;</span><br><span class="line">  return function(next) &#123;</span><br><span class="line">    return function(action) &#123;</span><br><span class="line">      console.log(&quot;store1&quot;, store);</span><br><span class="line">      next(action);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a name="W9wVB"></a><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>可以说我们整个中间件的设计就是建构在返回函数形成闭包这种柯里化特性上。它让我们缓存参数，分开执行，链式传递参数调用。所以 redux 中能提前注入 store，能有效传递 action。可以说koa/redux的中间件机制是闭包/柯里化的经典的实例。寒风卷起，落叶抱冬日，感谢阅读。<br><a name="irPln"></a><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><a target="_blank" rel="noopener" href="https://juejin.im/post/5bbdcf05e51d450e6c750693">https://juejin.im/post/5bbdcf05e51d450e6c750693</a><br /><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35040744">https://zhuanlan.zhihu.com/p/35040744</a><br /><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20597452">https://zhuanlan.zhihu.com/p/20597452</a><br /><a target="_blank" rel="noopener" href="https://github.com/brickspert/blog/issues/22">https://github.com/brickspert/blog/issues/22</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/21/193-%E3%80%90%E4%B8%AD%E9%97%B4%E4%BB%B6%E3%80%91%E4%BB%8Ekoa%E5%92%8Credux%E7%9C%8B%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%AD%E9%97%B4%E4%BB%B6/" data-id="ckts3eju0005b4d9kf2n31dqy" data-title="193-【中间件】从koa和redux看如何设计中间件" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-192-【NPM】剖析npm的包管理机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/20/192-%E3%80%90NPM%E3%80%91%E5%89%96%E6%9E%90npm%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2020-01-20T15:59:55.000Z" itemprop="datePublished">2020-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/20/192-%E3%80%90NPM%E3%80%91%E5%89%96%E6%9E%90npm%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/">192-【NPM】剖析npm的包管理机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a name="532Rf"></a></p>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742526-c9461a33-782f-4d77-ba66-83397e7ed477.webp#align=left&display=inline&height=361&originHeight=594&originWidth=1080&size=0&status=done&style=none&width=657"></p>
<p>本文来自微信公众号【code秘密花园】</p>
<p>现如今，前端开发的同学已经离不开 <code>npm</code> 这个包管理工具，其优秀的包版本管理机制承载了整个繁荣发展的<code>NodeJS</code>社区，理解其内部机制非常有利于加深我们对模块开发的理解、各项前端工程化的配置以加快我们排查问题（相信不少同学收到过各种依赖问题的困扰）的速度。<br />本文从三个角度：<code>package.json</code>、版本管理、依赖安装结合具体实例对 <code>npm</code> 的包管理机制进行了详细分析。<br />我之前发过这三篇文章，实际上下面三篇文章都是围绕包版本管理来写的，把他们串联起来可以更全面的看到整个npm的包管理机制，本篇文章就是三篇文章的集合，另外完善了一些内容，让大家更全面的理解这个问题。<br /><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=Mzg2NDAzMjE5NQ==&mid=2247484994&idx=1&sn=7da1108c3858ad71c42bcb36f8ade9de&chksm=ce6ec2eef9194bf863bb5ddeb9cb5fa7507e3a5f27b6dde0f61946c2c378eb89d8f562424ca7&scene=21#wechat_redirect">package.json 知多少？</a><br /><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=Mzg2NDAzMjE5NQ==&mid=2247484889&idx=1&sn=feacaf4352ae97560ed3afd244618553&chksm=ce6ec175f91948639d0bfc4a0322fb41123d2f56b884453c83f35edad7d9066ca0f080af9f4b&scene=21#wechat_redirect">NPM如何管理依赖包版本？</a><br /><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=Mzg2NDAzMjE5NQ==&mid=2247485074&idx=1&sn=a4b39ef1fcad427e79a8714c41b8eb0b&chksm=ce6ec23ef9194b28cd007f4de1691a27ecb4742a510fb118beb37e611ed4ec211b15f74d16a6&scene=21#wechat_redirect">npm install 原理分析</a><br><a name="rreeF"></a></p>
<h2 id="一、剖析-package-json"><a href="#一、剖析-package-json" class="headerlink" title="一、剖析 package.json"></a>一、剖析 package.json</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742525-2df8cd03-e5c3-4ee3-b636-74f0706824f8.webp#align=left&display=inline&height=370&originHeight=608&originWidth=1080&size=0&status=done&style=none&width=657"><br />在 <code>Node.js</code> 中，模块是一个库或框架，也是一个 <code>Node.js</code> 项目。<code>Node.js</code> 项目遵循模块化的架构，当我们创建了一个 <code>Node.js</code> 项目，意味着创建了一个模块，这个模块必须有一个描述文件，即 <code>package.json</code>。它是我们最常见的配置文件，但是它里面的配置你真的有详细了解过吗？配置一个合理的 <code>package.json</code> 文件直接决定着我们项目的质量，所以首先带大家分析下 <code>package.json</code> 的各项详细配置。<br><a name="SUckN"></a></p>
<h3 id="1-1-必备属性"><a href="#1-1-必备属性" class="headerlink" title="1.1 必备属性"></a>1.1 必备属性</h3><p><code>package.json</code> 中有非常多的属性，其中必须填写的只有两个：<code>name</code> 和 <code>version</code> ，这两个属性组成一个 <code>npm</code> 模块的唯一标识。<br><a name="LISFn"></a></p>
<h4 id="npm包命名规则"><a href="#npm包命名规则" class="headerlink" title="npm包命名规则"></a>npm包命名规则</h4><p><code>name</code> 即模块名称，其命名时需要遵循官方的一些规范和建议：</p>
<ul>
<li>包名会成为模块<code>url</code>、命令行中的一个参数或者一个文件夹名称，任何非<code>url</code>安全的字符在包名中都不能使用，可以使用 <code>validate-npm-package-name</code> 包来检测包名是否合法。<br /></li>
<li>语义化包名，可以帮助开发者更快的找到需要的包，并且避免意外获取错误的包。<br /></li>
<li>若包名称中存在一些符号，将符号去除后不得与现有包名重复<br /></li>
</ul>
<p>例如：由于<code>react-native</code>已经存在，<code>react.native</code>、<code>reactnative</code>都不可以再创建。</p>
<ul>
<li>如果你的包名与现有的包名太相近导致你不能发布这个包，那么推荐将这个包发布到你的作用域下。<br /></li>
</ul>
<p>例如：用户名 <code>conard</code>，那么作用域为 <code>@conard</code>，发布的包可以是<code>@conard/react</code>。<br><a name="THVal"></a></p>
<h4 id="查看包是否被占用"><a href="#查看包是否被占用" class="headerlink" title="查看包是否被占用"></a>查看包是否被占用</h4><p><code>name</code> 是一个包的唯一标识，不得和其他包名重复，我们可以执行 <code>npm view packageName</code> 查看包是否被占用，并可以查看它的一些基本信息：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742554-9a8927af-4e8f-4ca0-9ac6-4238a00fcd49.webp#align=left&display=inline&height=343&originHeight=564&originWidth=1080&size=0&status=done&style=none&width=657"><br />若包名称从未被使用过，则会抛出 <code>404</code> 错误：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742516-442095ad-1a97-42c5-9dde-aa6cd3f5dd1b.webp#align=left&display=inline&height=228&originHeight=375&originWidth=1080&size=0&status=done&style=none&width=657"><br />另外，你还可以去 <code>https://www.npmjs.com/</code> 查询更多更详细的包信息。<br><a name="3W5o8"></a></p>
<h3 id="1-2描述信息"><a href="#1-2描述信息" class="headerlink" title="1.2描述信息"></a>1.2描述信息</h3><p><a name="x7iBS"></a></p>
<h4 id="基本描述"><a href="#基本描述" class="headerlink" title="基本描述"></a>基本描述</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;description&quot;: &quot;An enterprise-class UI design language and React components implementation&quot;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;ant&quot;,</span><br><span class="line">    &quot;component&quot;,</span><br><span class="line">    &quot;components&quot;,</span><br><span class="line">    &quot;design&quot;,</span><br><span class="line">    &quot;framework&quot;,</span><br><span class="line">    &quot;frontend&quot;,</span><br><span class="line">    &quot;react&quot;,</span><br><span class="line">    &quot;react-component&quot;,</span><br><span class="line">    &quot;ui&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>description</code>用于添加模块的的描述信息，方便别人了解你的模块。<br /><code>keywords</code>用于给你的模块添加关键字。<br />当然，他们的还有一个非常重要的作用，就是利于模块检索。当你使用 <code>npm search</code> 检索模块时，会到<code>description</code> 和 <code>keywords</code> 中进行匹配。写好 <code>description</code> 和 <code>keywords</code> 有利于你的模块获得更多更精准的曝光：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742515-eed623f5-4e84-4275-9cb1-d649b555ef01.webp#align=left&display=inline&height=340&originHeight=543&originWidth=1050&size=0&status=done&style=none&width=657"><br><a name="okIj4"></a></p>
<h4 id="开发人员"><a href="#开发人员" class="headerlink" title="开发人员"></a>开发人员</h4><p>描述开发人员的字段有两个：<code>author</code> 和 <code>contributors</code>， <code>author</code> 指包的主要作者，一个 <code>author</code> 对应一个人。<code>contributors</code> 指贡献者信息，一个 <code>contributors</code> 对应多个贡献者，值为数组，对人的描述可以是一个字符串，也可以是下面的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot; : &quot;ConardLi&quot;,</span><br><span class="line">    &quot;email&quot; : &quot;lisqPersion@163.com&quot;,</span><br><span class="line">    &quot;url&quot; : &quot;https://github.com/ConardLi&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="JQLnh"></a></p>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;homepage&quot;: &quot;http://ant.design/&quot;,</span><br><span class="line">  &quot;bugs&quot;: &#123;</span><br><span class="line">    &quot;url&quot;: &quot;https://github.com/ant-design/ant-design/issues&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;https://github.com/ant-design/ant-design&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>homepage</code> 用于指定该模块的主页。<br /><code>repository</code> 用于指定模块的代码仓库。<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742555-af3c5dfb-e735-4e72-a1b2-c3596091a6d3.webp#align=left&display=inline&height=393&originHeight=352&originWidth=589&size=0&status=done&style=none&width=657"><br /><code>bugs</code> 指定一个地址或者一个邮箱，对你的模块存在疑问的人可以到这里提出问题。<br><a name="DC7Bz"></a></p>
<h3 id="1-3-依赖配置"><a href="#1-3-依赖配置" class="headerlink" title="1.3 依赖配置"></a>1.3 依赖配置</h3><p>我们的项目可能依赖一个或多个外部依赖包，根据依赖包的不同用途，我们将他们配置在下面几个属性下：<code>dependencies、devDependencies、peerDependencies、bundledDependencies、optionalDependencies</code>。<br><a name="OI27s"></a></p>
<h4 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h4><p>在介绍几种依赖配置之前，首先我们来看一下依赖的配置规则，你看到的依赖包配置可能是下面这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">      &quot;antd&quot;: &quot;ant-design/ant-design#4.0.0-alpha.8&quot;,</span><br><span class="line">      &quot;axios&quot;: &quot;^1.2.0&quot;,</span><br><span class="line">      &quot;test-js&quot;: &quot;file:../test&quot;,</span><br><span class="line">      &quot;test2-js&quot;: &quot;http://cdn.com/test2-js.tar.gz&quot;,</span><br><span class="line">      &quot;core-js&quot;: &quot;^1.1.5&quot;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>依赖配置遵循下面几种配置规则：</p>
<ul>
<li><p><code>依赖包名称:VERSION</code><br /></p>
<ul>
<li><code>VERSION</code>是一个遵循<code>SemVer</code>规范的版本号配置，<code>npm install</code> 时将到npm服务器下载符合指定版本范围的包。<br /></li>
</ul>
</li>
<li><p><code>依赖包名称:DWONLOAD_URL</code><br /></p>
<ul>
<li><code>DWONLOAD_URL</code> 是一个可下载的<code>tarball</code>压缩包地址，模块安装时会将这个<code>.tar</code>下载并安装到本地。<br /></li>
</ul>
</li>
<li><p><code>依赖包名称:LOCAL_PATH</code><br /></p>
<ul>
<li><code>LOCAL_PATH</code> 是一个本地的依赖包路径，例如 <code>file:../pacakges/pkgName</code>。适用于你在本地测试一个<code>npm</code>包，不应该将这种方法应用于线上。<br /></li>
</ul>
</li>
<li><p><code>依赖包名称:GITHUB_URL</code><br /></p>
<ul>
<li><code>GITHUB_URL</code> 即 <code>github</code> 的 <code>username/modulename</code> 的写法，例如：<code>ant-design/ant-design</code>，你还可以在后面指定 <code>tag</code> 和 <code>commit id</code>。<br /></li>
</ul>
</li>
<li><p><code>依赖包名称:GIT_URL</code><br /></p>
<ul>
<li><code>GIT_URL</code> 即我们平时clone代码库的 <code>git url</code>，其遵循以下形式：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;protocol&gt;://[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:][/]&lt;path&gt;[#&lt;commit-ish&gt; | #semver:&lt;semver&gt;]</span><br></pre></td></tr></table></figure>
其中 <code>protocal</code> 可以是以下几种形式：</li>
</ul>
</li>
<li><p><code>git://github.com/user/project.git#commit-ish</code><br /></p>
</li>
<li><p><code>git+ssh://user@hostname:project.git#commit-ish</code><br /></p>
</li>
<li><p><code>git+ssh://user@hostname/project.git#commit-ish</code><br /></p>
</li>
<li><p><code>git+http://user@hostname/project/blah.git#commit-ish</code><br /></p>
</li>
<li><p><code>git+https://user@hostname/project/blah.git#commit-ish</code><br /><br><a name="omNsZ"></a></p>
<h4 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h4><p><code>dependencies</code> 指定了项目运行所依赖的模块，开发环境和生产环境的依赖模块都可以配置到这里，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">      &quot;lodash&quot;: &quot;^4.17.13&quot;,</span><br><span class="line">      &quot;moment&quot;: &quot;^2.24.0&quot;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><a name="35bbm"></a></p>
<h4 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h4><p>有一些包有可能你只是在开发环境中用到，例如你用于检测代码规范的 <code>eslint</code> ,用于进行测试的 <code>jest</code> ，用户使用你的包时即使不安装这些依赖也可以正常运行，反而安装他们会耗费更多的时间和资源，所以你可以把这些依赖添加到 <code>devDependencies</code> 中，这些依赖照样会在你本地进行 <code>npm install</code> 时被安装和管理，但是不会被安装到生产环境：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;jest&quot;</span>: <span class="string">&quot;^24.3.1&quot;</span>,</span><br><span class="line">      <span class="string">&quot;eslint&quot;</span>: <span class="string">&quot;^6.1.0&quot;</span>,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><a name="Lt80W"></a></p>
<h4 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h4><p><code>peerDependencies</code> 用于指定你正在开发的模块所依赖的版本以及用户安装的依赖包版本的兼容性。<br />上面的说法可能有点太抽象，我们直接拿 <code>ant-design</code> 来举个例子，<code>ant-design</code> 的 <code>package.json</code> 中有如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;peerDependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;&gt;=16.0.0&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;&gt;=16.0.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当你正在开发一个系统，使用了 <code>ant-design</code> ，所以也肯定需要依赖 <code>React</code>。同时， <code>ant-design</code> 也是需要依赖 <code>React</code> 的，它要保持稳定运行所需要的 <code>React</code> 版本是<code>16.0.0</code>，而你开发时依赖的 <code>React</code> 版本是 <code>15.x</code>：<br />这时，<code>ant-design</code> 要使用 <code>React</code>，并将其引入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &#x27;react&#x27;;</span><br><span class="line">import * as ReactDOM from &#x27;react-dom&#x27;;</span><br></pre></td></tr></table></figure>
<p>这时取到的是宿主环境也就是你的环境中的 <code>React</code> 版本，这就可能造成一些问题。在 <code>npm2</code> 的时候，指定上面的 <code>peerDependencies</code> 将意味着强制宿主环境安装 <code>react@&gt;=16.0.0和react-dom@&gt;=16.0.0</code> 的版本。<br /><code>npm3</code> 以后不会再要求 <code>peerDependencies</code> 所指定的依赖包被强制安装，相反 <code>npm3</code> 会在安装结束后检查本次安装是否正确，如果不正确会给用户打印警告提示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;15.6.0&quot;,</span><br><span class="line">    &quot;antd&quot;: &quot;^3.22.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>例如，我在项目中依赖了 <code>antd</code> 的最新版本，然后依赖了 <code>react</code> 的 <code>15.6.0</code>版本，在进行依赖安装时将给出以下警告：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742549-41472d90-a911-4837-bb07-bfd1a0e0e557.webp#align=left&display=inline&height=137&originHeight=198&originWidth=952&size=0&status=done&style=none&width=657"><br><a name="zIIvP"></a></p>
<h4 id="optionalDependencies"><a href="#optionalDependencies" class="headerlink" title="optionalDependencies"></a>optionalDependencies</h4><p>某些场景下，依赖包可能不是强依赖的，这个依赖包的功能可有可无，当这个依赖包无法被获取到时，你希望 <code>npm install</code> 继续运行，而不会导致失败，你可以将这个依赖放到 <code>optionalDependencies</code> 中，注意 <code>optionalDependencies</code> 中的配置将会覆盖掉 <code>dependencies</code> 所以只需在一个地方进行配置。<br />当然，引用 <code>optionalDependencies</code> 中安装的依赖时，一定要做好异常处理，否则在模块获取不到时会导致报错。<br><a name="xfV9I"></a></p>
<h4 id="bundledDependencies"><a href="#bundledDependencies" class="headerlink" title="bundledDependencies"></a>bundledDependencies</h4><p>和以上几个不同，<code>bundledDependencies</code> 的值是一个数组，数组里可以指定一些模块，这些模块将在这个包发布时被一起打包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;bundledDependencies&quot;: [&quot;package1&quot; , &quot;package2&quot;]</span><br></pre></td></tr></table></figure>
<p><a name="eewk9"></a></p>
<h3 id="1-4-协议"><a href="#1-4-协议" class="headerlink" title="1.4 协议"></a>1.4 协议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;license&quot;: &quot;MIT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>license</code> 字段用于指定软件的开源协议，开源协议里面详尽表述了其他人获得你代码后拥有的权利，可以对你的的代码进行何种操作，何种操作又是被禁止的。同一款协议有很多变种，协议太宽松会导致作者丧失对作品的很多权利，太严格又不便于使用者使用及作品的传播，所以开源作者要考虑自己对作品想保留哪些权利，放开哪些限制。</p>
<blockquote>
<p>软件协议可分为开源和商业两类，对于商业协议，或者叫法律声明、许可协议，每个软件会有自己的一套行文，由软件作者或专门律师撰写，对于大多数人来说不必自己花时间和精力去写繁长的许可协议，选择一份广为流传的开源协议就是个不错的选择。</p>
</blockquote>
</li>
</ul>
<p>以下就是几种主流的开源协议：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744887-af159395-e854-4b6f-a69d-e1c55e56676e.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"></p>
<ul>
<li><code>MIT</code>：只要用户在项目副本中包含了版权声明和许可声明，他们就可以拿你的代码做任何想做的事情，你也无需承担任何责任。<br /></li>
<li><code>Apache</code>：类似于 <code>MIT</code>，同时还包含了贡献者向用户提供专利授权相关的条款。<br /></li>
<li><code>GPL</code>：修改项目代码的用户再次分发源码或二进制代码时，必须公布他的相关修改。<br /></li>
</ul>
<p>如果你对开源协议有更详细的要求，可以到 <a target="_blank" rel="noopener" href="https://choosealicense.com/">https://choosealicense.com/</a> 获取更详细的开源协议说明。<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744913-5d19d2dd-3013-4055-bd1a-c2ea2f138b75.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br><a name="rPVSL"></a></p>
<h3 id="1-5-目录、文件相关"><a href="#1-5-目录、文件相关" class="headerlink" title="1.5 目录、文件相关"></a>1.5 目录、文件相关</h3><p><a name="fL3Aq"></a></p>
<h4 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;main&quot;: &quot;lib/index.js&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code> 属性可以指定程序的主入口文件，例如，上面 <code>antd</code> 指定的模块入口 <code>lib/index.js</code> ，当我们在代码用引入 <code>antd</code> 时：<code>import &#123; notification &#125; from &#39;antd&#39;;</code> 实际上引入的就是 <code>lib/index.js</code> 中暴露出去的模块。<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744884-7d3b34d1-d584-4a00-a55a-28b697942e42.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br><a name="t6ucZ"></a></p>
<h4 id="命令行工具入口"><a href="#命令行工具入口" class="headerlink" title="命令行工具入口"></a>命令行工具入口</h4><p>当你的模块是一个命令行工具时，你需要为命令行工具指定一个入口，即指定你的命令名称和本地可指定文件的对应关系。如果是全局安装，npm 将会使用符号链接把可执行文件链接到 <code>/usr/local/bin</code>，如果是本地安装，会链接到 <code>./node_modules/.bin/</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;bin&quot;: &#123;</span><br><span class="line">    &quot;conard&quot;: &quot;./bin/index.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如上面的配置：当你的包安装到全局时：<code>npm</code> 会在 <code>/usr/local/bin</code>下创建一个以 <code>conard</code> 为名字的软链接，指向全局安装下来的 <code>conard</code> 包下面的 <code>&quot;./bin/index.js&quot;</code>。这时你在命令行执行 <code>conard</code> 则会调用链接到的这个js文件。</p>
<blockquote>
<p>这里不再过多展开，更多内容在我后续的命令行工具文章中会进行详细讲解。</p>
</blockquote>
<p><a name="I2QlZ"></a></p>
<h4 id="发布文件配置"><a href="#发布文件配置" class="headerlink" title="发布文件配置"></a>发布文件配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;files&quot;: [</span><br><span class="line">      &quot;dist&quot;,</span><br><span class="line">      &quot;lib&quot;,</span><br><span class="line">      &quot;es&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>files</code> 属性用于描述你 <code>npm publish</code> 后推送到 <code>npm</code> 服务器的文件列表，如果指定文件夹，则文件夹内的所有内容都会包含进来。我们可以看到下载后的包是下面的目录结构：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742584-665d4d39-9442-4d54-b159-0f293fe05b06.webp#align=left&display=inline&height=286&originHeight=194&originWidth=445&size=0&status=done&style=none&width=657"></p>
<blockquote>
<p>另外，你还可以通过配置一个 <code>.npmignore</code> 文件来排除一些文件, 防止大量的垃圾文件推送到 <code>npm</code>, 规则上和你用的 <code>.gitignore</code> 是一样的。<code>.gitignore</code> 文件也可以充当<code>.npmignore</code> 文件。</p>
</blockquote>
<p><a name="SGBOU"></a></p>
<h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p><code>man</code> 命令是 <code>Linux</code> 下的帮助指令，通过 <code>man</code> 指令可以查看 <code>Linux</code> 中的指令帮助、配置文件帮助和编程帮助等信息。<br />如果你的 <code>node.js</code> 模块是一个全局的命令行工具，在 <code>package.json</code> 通过 <code>man</code>  属性可以指定 <code>man</code> 命令查找的文档地址。<br /><code>man</code> 文件必须以数字结尾，或者如果被压缩了，以 <code>.gz</code> 结尾。数字表示文件将被安装到 <code>man</code> 的哪个部分。如果 <code>man</code> 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。<br />例如下面这段配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;man&quot; : [</span><br><span class="line">    &quot;/Users/isaacs/dev/npm/cli/man/man1/npm-access.1&quot;,</span><br><span class="line">    &quot;/Users/isaacs/dev/npm/cli/man/man1/npm-audit.1&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在命令行输入 <code>man npm-audit</code> ：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744888-795c8dc5-81d6-4554-8564-c1cb6194887a.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br><a name="KGQVG"></a></p>
<h4 id="规范项目目录"><a href="#规范项目目录" class="headerlink" title="规范项目目录"></a>规范项目目录</h4><p>一个 <code>node.js</code> 模块是基于 <code>CommonJS</code> 模块化规范实现的，严格按照 <code>CommonJS</code> 规范，模块目录下除了必须包含包描述文件 <code>package.json</code> 以外，还需要包含以下目录：</p>
<ul>
<li><code>bin</code>：存放可执行二进制文件的目录<br /></li>
<li><code>lib</code>：存放js代码的目录<br /></li>
<li><code>doc</code>：存放文档的目录<br /></li>
<li><code>test</code>：存放单元测试用例代码的目录<br /></li>
<li>…<br /></li>
</ul>
<p>在模块目录中你可能没有严格按照以上结构组织或命名，你可以通过在 <code>package.json</code> 指定 <code>directories</code> 属性来指定你的目录结构和上述的规范结构的对应情况。除此之外 <code>directories</code> 属性暂时没有其他应用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;directories&quot;: &#123;</span><br><span class="line">    &quot;lib&quot;: &quot;src/lib/&quot;,</span><br><span class="line">    &quot;bin&quot;: &quot;src/bin/&quot;,</span><br><span class="line">    &quot;man&quot;: &quot;src/man/&quot;,</span><br><span class="line">    &quot;doc&quot;: &quot;src/doc/&quot;,</span><br><span class="line">    &quot;example&quot;: &quot;src/example/&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不过官方文档表示，虽然目前这个属性没有什么重要作用，未来可能会整出一些花样出来，例如：doc 中存放的 markdown 文件、example 中存放的示例文件，可能会友好的展示出来。</p>
</blockquote>
<p><a name="wDIPj"></a></p>
<h3 id="1-6-脚本配置"><a href="#1-6-脚本配置" class="headerlink" title="1.6 脚本配置"></a>1.6 脚本配置</h3><p><a name="1PvqI"></a></p>
<h4 id="script"><a href="#script" class="headerlink" title="script"></a>script</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;jest --config .jest.js --no-cache&quot;,</span><br><span class="line">    &quot;dist&quot;: &quot;antd-tools run dist&quot;,</span><br><span class="line">    &quot;compile&quot;: &quot;antd-tools run compile&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;npm run compile &amp;&amp; npm run dist&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>scripts</code> 用于配置一些脚本命令的缩写，各个脚本可以互相组合使用，这些脚本可以覆盖整个项目的生命周期，配置后可使用 <code>npm run command</code> 进行调用。如果是 <code>npm</code> 关键字，则可以直接调用。例如，上面的配置制定了以下几个命令：<code>npm run test</code>、<code>npm run dist</code>、<code>npm run compile</code>、<code>npm run build</code>。<br><a name="15ULi"></a></p>
<h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p><code>config</code> 字段用于配置脚本中使用的环境变量，例如下面的配置，可以在脚本中使用<code>process.env.npm_package_config_port</code>进行获取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="SAvzR"></a></p>
<h3 id="1-7-发布配置"><a href="#1-7-发布配置" class="headerlink" title="1.7 发布配置"></a>1.7 发布配置</h3><p><a name="klM6K"></a></p>
<h4 id="preferGlobal"><a href="#preferGlobal" class="headerlink" title="preferGlobal"></a>preferGlobal</h4><p>如果你的 <code>node.js</code> 模块主要用于安装到全局的命令行工具，那么该值设置为 <code>true</code> ，当用户将该模块安装到本地时，将得到一个警告。这个配置并不会阻止用户安装，而是会提示用户防止错误使用而引发一些问题。<br><a name="ySDNA"></a></p>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>如果将 <code>private</code> 属性设置为 <code>true</code>，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742604-b5307eef-88c2-4e0a-8ebe-d4a7e56a8d52.webp#align=left&display=inline&height=192&originHeight=316&originWidth=1080&size=0&status=done&style=none&width=657"><br><a name="35xA2"></a></p>
<h4 id="publishConfig"><a href="#publishConfig" class="headerlink" title="publishConfig"></a>publishConfig</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;registry&quot;: &quot;https://registry.npmjs.org/&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>发布模块时更详细的配置，例如你可以配置只发布某个 <code>tag</code>、配置发布到的私有 <code>npm</code> 源。更详细的配置可以参考 npm-config<br><a name="wMF7p"></a></p>
<h4 id="os"><a href="#os" class="headerlink" title="os"></a>os</h4><p>假如你开发了一个模块，只能跑在 <code>darwin</code> 系统下，你需要保证 <code>windows</code> 用户不会安装到你的模块，从而避免发生不必要的错误。<br />使用 <code>os</code> 属性可以帮助你完成以上的需求，你可以指定你的模块只能被安装在某些系统下，或者指定一个不能安装的系统黑名单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;os&quot; : [ &quot;darwin&quot;, &quot;linux&quot; ]</span><br><span class="line">&quot;os&quot; : [ &quot;!win32&quot; ]</span><br></pre></td></tr></table></figure>
<p>例如，我把一个测试模块指定一个系统黑名单：<code>&quot;os&quot; : [ &quot;!darwin&quot; ]</code>，当我在此系统下安装它时会爆出如下错误：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742595-16429df0-4511-405a-b45f-4bbb13213682.webp#align=left&display=inline&height=93&originHeight=137&originWidth=969&size=0&status=done&style=none&width=657"></p>
<blockquote>
<p>在node环境下可以使用 process.platform 来判断操作系统。</p>
</blockquote>
<p><a name="OZDeW"></a></p>
<h4 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h4><p>和上面的 <code>os</code> 类似，我们可以用 <code>cpu</code> 属性更精准的限制用户安装环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;cpu&quot; : [ &quot;x64&quot;, &quot;ia32&quot; ]</span><br><span class="line">&quot;cpu&quot; : [ &quot;!arm&quot;, &quot;!mips&quot; ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在node环境下可以使用 process.arch 来判断 cpu 架构。</p>
</blockquote>
<p><a name="tUUc9"></a></p>
<h2 id="二、剖析包版本管理机制"><a href="#二、剖析包版本管理机制" class="headerlink" title="二、剖析包版本管理机制"></a>二、剖析包版本管理机制</h2><p><code>Nodejs</code>成功离不开 <code>npm</code> 优秀的依赖管理系统。在介绍整个依赖系统之前，必须要了解 <code>npm</code>如何管理依赖包的版本，本章将介绍 <code>npm包</code> 的版本发布规范、如何管理各种依赖包的版本以及一些关于包版本的最佳实践。<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744871-16e3ccd1-8ddc-4bde-8806-a3bb435fbcae.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br><a name="Q2qPF"></a></p>
<h3 id="2-1-查看npm包版本"><a href="#2-1-查看npm包版本" class="headerlink" title="2.1 查看npm包版本"></a>2.1 查看npm包版本</h3><p>你可以执行 <code>npm view package version</code> 查看某个 <code>package</code> 的最新版本。<br />执行 <code>npm view conard versions</code> 查看某个 <code>package</code> 在npm服务器上所有发布过的版本。<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744870-c55fb6d5-75ef-43f7-90ec-97be8b156fbe.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br />执行 <code>npm ls</code> 可查看当前仓库依赖树上所有包的版本信息。<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744885-97b11132-fb70-434b-a76d-2edf9f091efa.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br><a name="jkbDb"></a></p>
<h3 id="2-2-SemVer规范"><a href="#2-2-SemVer规范" class="headerlink" title="2.2 SemVer规范"></a>2.2 SemVer规范</h3><p><code>npm包</code> 中的模块版本都需要遵循 <code>SemVer</code>规范——由 <code>Github</code> 起草的一个具有指导意义的，统一的版本号表示规则。实际上就是 <code>Semantic Version</code>（语义化版本）的缩写。</p>
<blockquote>
<p>SemVer规范官网：<a target="_blank" rel="noopener" href="https://semver.org/">https://semver.org/</a></p>
</blockquote>
<p><a name="rccoi"></a></p>
<h4 id="标准版本"><a href="#标准版本" class="headerlink" title="标准版本"></a>标准版本</h4><p><code>SemVer</code>规范的标准版本号采用 <code>X.Y.Z</code> 的格式，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须以数值来递增。</p>
<ul>
<li>主版本号(<code>major</code>)：当你做了不兼容的API 修改<br /></li>
<li>次版本号(<code>minor</code>)：当你做了向下兼容的功能性新增<br /></li>
<li>修订号(<code>patch</code>)：当你做了向下兼容的问题修正。<br /></li>
</ul>
<p>例如：<code>1.9.1 -&gt; 1.10.0 -&gt; 1.11.0</code><br><a name="CVmPY"></a></p>
<h4 id="先行版本"><a href="#先行版本" class="headerlink" title="先行版本"></a>先行版本</h4><p>当某个版本改动比较大、并非稳定而且可能无法满足预期的兼容性需求时，你可能要先发布一个先行版本。<br />先行版本号可以加到“主版本号.次版本号.修订号”的后面，先加上一个连接号再加上一连串以句点分隔的标识符和版本编译信息。</p>
<ul>
<li><p>内部版本(<code>alpha</code>):<br /></p>
</li>
<li><p>公测版本(<code>beta</code>):<br /></p>
</li>
<li><p>正式版本的候选版本<code>rc</code>: 即 <code>Release candiate</code><br /><br><a name="HzbHD"></a></p>
<h4 id="React的版本"><a href="#React的版本" class="headerlink" title="React的版本"></a>React的版本</h4><p>下面我们来看看 <code>React</code> 的历史版本：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535742655-3a9c5277-5812-44d6-991f-328df4ed42c3.gif#align=left&display=inline&height=505&originHeight=447&originWidth=581&size=0&status=done&style=none&width=657"><br />可见是严格按照 <code>SemVer</code> 规范来发版的：</p>
</li>
<li><p>版本号严格按照 <code>主版本号.次版本号.修订号</code> 格式命名<br /></p>
</li>
<li><p>版本是严格递增的，：<code>16.8.0 -&gt; 16.8.1 -&gt; 16.8.2</code><br /></p>
</li>
<li><p>发布重大版本或版本改动较大时，先发布<code>alpha</code>、<code>beta</code>、<code>rc</code>等先行版本<br /><br><a name="eilks"></a></p>
<h4 id="发布版本"><a href="#发布版本" class="headerlink" title="发布版本"></a>发布版本</h4><p>在修改 <code>npm</code> 包某些功能后通常需要发布一个新的版本，我们通常的做法是直接去修改 <code>package.json</code> 到指定版本。如果操作失误，很容易造成版本号混乱，我们可以借助符合 <code>Semver</code> 规范的命令来完成这一操作：</p>
</li>
<li><p><code>npm version patch</code> : 升级修订版本号<br /></p>
</li>
<li><p><code>npm version minor</code> : 升级次版本号<br /></p>
</li>
<li><p><code>npm version major</code> : 升级主版本号<br /><br><a name="dHV7c"></a></p>
<h3 id="2-3-版本工具使用"><a href="#2-3-版本工具使用" class="headerlink" title="2.3 版本工具使用"></a>2.3 版本工具使用</h3><p>在开发中肯定少不了对一些版本号的操作，如果这些版本号符合 <code>SemVer</code>规范 ，我们可以借助用于操作版本的npm包<code>semver</code>来帮助我们进行比较版本大小、提取版本信息等操作。</p>
<blockquote>
<p>Npm 也使用了该工具来处理版本相关的工作。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install semver</span><br></pre></td></tr></table></figure>

<ul>
<li><p>比较版本号大小<br /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semver.gt(&#x27;1.2.3&#x27;, &#x27;9.8.7&#x27;) // false</span><br><span class="line">semver.lt(&#x27;1.2.3&#x27;, &#x27;9.8.7&#x27;) // true</span><br></pre></td></tr></table></figure></li>
<li><p>判断版本号是否符合规范，返回解析后符合规范的版本号。<br /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semver.valid(&#x27;1.2.3&#x27;) // &#x27;1.2.3&#x27;</span><br><span class="line">semver.valid(&#x27;a.b.c&#x27;) // null</span><br></pre></td></tr></table></figure></li>
<li><p>将其他版本号强制转换成semver版本号<br /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semver.valid(semver.coerce(&#x27;v2&#x27;)) // &#x27;2.0.0&#x27;</span><br><span class="line">semver.valid(semver.coerce(&#x27;42.6.7.9.3-alpha&#x27;)) // &#x27;42.6.7&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>一些其他用法<br /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semver.clean(&#x27;  =v1.2.3   &#x27;) // &#x27;1.2.3&#x27;</span><br><span class="line">semver.satisfies(&#x27;1.2.3&#x27;, &#x27;1.x || &gt;=2.5.0 || 5.0.0 - 7.2.3&#x27;) // true</span><br><span class="line">semver.minVersion(&#x27;&gt;=1.0.0&#x27;) // &#x27;1.0.0&#x27;</span><br></pre></td></tr></table></figure>
<p>以上都是semver最常见的用法，更多详细内容可以查看 semver文档：<a target="_blank" rel="noopener" href="https://github.com/npm/node-semver">https://github.com/npm/node-semver</a><br><a name="iIJ2I"></a></p>
<h3 id="2-4-依赖版本管理"><a href="#2-4-依赖版本管理" class="headerlink" title="2.4 依赖版本管理"></a>2.4 依赖版本管理</h3><p>我们经常看到，在 <code>package.json</code> 中各种依赖的不同写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;signale&quot;: &quot;1.4.0&quot;,</span><br><span class="line">    &quot;figlet&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;react&quot;: &quot;16.x&quot;,</span><br><span class="line">    &quot;table&quot;: &quot;~5.4.6&quot;,</span><br><span class="line">    &quot;yargs&quot;: &quot;^14.0.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>前面三个很容易理解：</p>
</li>
<li><p><code>&quot;signale&quot;: &quot;1.4.0&quot;</code>: 固定版本号<br /></p>
</li>
<li><p><code>&quot;figlet&quot;: &quot;*&quot;</code>: 任意版本（<code>&gt;=0.0.0</code>）<br /></p>
</li>
<li><p><code>&quot;react&quot;: &quot;16.x&quot;</code>: 匹配主要版本（<code>&gt;=16.0.0 &lt;17.0.0</code>）<br /></p>
</li>
<li><p><code>&quot;react&quot;: &quot;16.3.x&quot;</code>: 匹配主要版本和次要版本（<code>&gt;=16.3.0 &lt;16.4.0</code>）<br /></p>
</li>
</ul>
<p>再来看看后面两个，版本号中引用了 <code>~</code> 和 <code>^</code> 符号：</p>
<ul>
<li><code>~</code>: 当安装依赖时获取到有新版本时，安装到 <code>x.y.z</code> 中 <code>z</code> 的最新的版本。即保持主版本号、次版本号不变的情况下，保持修订号的最新版本。<br /></li>
<li><code>^</code>: 当安装依赖时获取到有新版本时，安装到 <code>x.y.z</code> 中 <code>y</code> 和 <code>z</code> 都为最新版本。即保持主版本号不变的情况下，保持次版本号、修订版本号为最新版本。<br /></li>
</ul>
<p>在 <code>package.json</code> 文件中最常见的应该是 <code>&quot;yargs&quot;: &quot;^14.0.0&quot;</code> 这种格式的 依赖, 因为我们在使用 <code>npm install package</code> 安装包时，<code>npm</code> 默认安装当前最新版本，然后在所安装的版本号前加 <code>^</code> 号。<br />注意，当主版本号为 <code>0</code> 的情况，会被认为是一个不稳定版本，情况与上面不同：</p>
<ul>
<li>主版本号和次版本号都为 <code>0</code>: <code>^0.0.z</code>、<code>~0.0.z</code> 都被当作固定版本，安装依赖时均不会发生变化。<br /></li>
<li>主版本号为 <code>0</code>: <code>^0.y.z</code> 表现和 <code>~0.y.z</code> 相同，只保持修订号为最新版本。<br /><blockquote>
<p>1.0.0 的版本号用于界定公共 API。当你的软件发布到了正式环境，或者有稳定的API时，就可以发布1.0.0版本了。所以，当你决定对外部发布一个正式版本的npm包时，把它的版本标为1.0.0。</p>
</blockquote>
</li>
</ul>
<p><a name="IX3Jx"></a></p>
<h3 id="2-5-锁定依赖版本"><a href="#2-5-锁定依赖版本" class="headerlink" title="2.5 锁定依赖版本"></a>2.5 锁定依赖版本</h3><p><a name="EUfVd"></a></p>
<h4 id="lock文件"><a href="#lock文件" class="headerlink" title="lock文件"></a>lock文件</h4><p>实际开发中，经常会因为各种依赖不一致而产生奇怪的问题，或者在某些场景下，我们不希望依赖被更新，建议在开发中使用 <code>package-lock.json</code>。<br />锁定依赖版本意味着在我们不手动执行更新的情况下，每次安装依赖都会安装固定版本。保证整个团队使用版本号一致的依赖。<br />每次安装固定版本，无需计算依赖版本范围，大部分场景下能大大加速依赖安装时间。</p>
<blockquote>
<p>使用 package-lock.json 要确保npm的版本在5.6以上，因为在5.0 - 5.6中间，对 package-lock.json的处理逻辑进行过几次更新，5.6版本后处理逻辑逐渐稳定。</p>
</blockquote>
<p>关于 <code>package-lock.json</code> 详细的结构，我们会在后面的章节进行解析。<br><a name="LSr72"></a></p>
<h4 id="定期更新依赖"><a href="#定期更新依赖" class="headerlink" title="定期更新依赖"></a>定期更新依赖</h4><p>我们的目的是保证团队中使用的依赖一致或者稳定，而不是永远不去更新这些依赖。实际开发场景下，我们虽然不需要每次都去安装新的版本，仍然需要定时去升级依赖版本，来让我们享受依赖包升级带来的问题修复、性能提升、新特性更新。<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742637-579b2577-4248-4c53-94ee-b9ca2a13e143.webp#align=left&display=inline&height=389&originHeight=639&originWidth=1080&size=0&status=done&style=none&width=657"><br />使用 <code>npm outdated</code> 可以帮助我们列出有哪些还没有升级到最新版本的依赖：</p>
<ul>
<li>黄色表示不符合我们指定的语意化版本范围 - 不需要升级<br /></li>
<li>红色表示符合指定的语意化版本范围 - 需要升级<br /></li>
</ul>
<p>执行 <code>npm update</code> 会升级所有的红色依赖。<br><a name="aHu9U"></a></p>
<h3 id="2-6-依赖版本选择的最佳实践"><a href="#2-6-依赖版本选择的最佳实践" class="headerlink" title="2.6 依赖版本选择的最佳实践"></a>2.6 依赖版本选择的最佳实践</h3><p><a name="3Sy34"></a></p>
<h4 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h4><ul>
<li><p>对外部发布一个正式版本的npm包时，把它的版本标为<code>1.0.0</code>。<br /></p>
</li>
<li><p>某个包版本发行后，任何修改都必须以新版本发行。<br /></p>
</li>
<li><p>版本号严格按照 <code>主版本号.次版本号.修订号</code> 格式命名<br /></p>
</li>
<li><p>版本号发布必须是严格递增的<br /></p>
</li>
<li><p>发布重大版本或版本改动较大时，先发布<code>alpha、beta、rc</code>等先行版本<br /><br><a name="EF5E2"></a></p>
<h4 id="依赖范围选择"><a href="#依赖范围选择" class="headerlink" title="依赖范围选择"></a>依赖范围选择</h4></li>
<li><p>主工程依赖了很多子模块，都是团队成员开发的<code>npm</code>包，此时建议把版本前缀改为<code>~</code>，如果锁定的话每次子依赖更新都要对主工程的依赖进行升级，非常繁琐，如果对子依赖完全信任，直接开启<code>^</code>每次升级到最新版本。<br /></p>
</li>
<li><p>主工程跑在<code>docker</code>线上，本地还在进行子依赖开发和升级，在<code>docker</code>版本发布前要锁定所有依赖版本，确保本地子依赖发布后线上不会出问题。<br /><br><a name="SPPah"></a></p>
<h4 id="保持依赖一致"><a href="#保持依赖一致" class="headerlink" title="保持依赖一致"></a>保持依赖一致</h4></li>
<li><p>确保<code>npm</code>的版本在<code>5.6</code>以上，确保默认开启 <code>package-lock.json</code> 文件。<br /></p>
</li>
<li><p>由初始化成员执行 <code>npm inatall</code> 后，将 <code>package-lock.json</code> 提交到远程仓库。不要直接提交 <code>node_modules</code>到远程仓库。<br /></p>
</li>
<li><p>定期执行 <code>npm update</code> 升级依赖，并提交 <code>lock</code> 文件确保其他成员同步更新依赖，不要手动更改 <code>lock</code> 文件。<br /><br><a name="CaNzu"></a></p>
<h4 id="依赖变更"><a href="#依赖变更" class="headerlink" title="依赖变更"></a>依赖变更</h4></li>
<li><p>升级依赖: 修改 <code>package.json</code>文件的依赖版本，执行 <code>npm install</code><br /></p>
</li>
<li><p>降级依赖: 直接执行 <code>npm install package@version</code>(改动<code>package.json</code>不会对依赖进行降级)<br /></p>
</li>
<li><p>注意改动依赖后提交<code>lock</code>文件<br /><br><a name="PyTfN"></a></p>
<h2 id="三、剖析-npm-install-原理"><a href="#三、剖析-npm-install-原理" class="headerlink" title="三、剖析 npm install 原理"></a>三、剖析 npm install 原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744876-9faca344-8094-41ef-9a70-45a8cd0e7f82.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br /><code>npm install</code> 大概会经过上面的几个流程，这一章就来讲一讲各个流程的实现细节、发展以及为何要这样实现。<br><a name="C3fi1"></a></p>
<h3 id="3-1-嵌套结构"><a href="#3-1-嵌套结构" class="headerlink" title="3.1 嵌套结构"></a>3.1 嵌套结构</h3><p>我们都知道，执行 <code>npm install</code> 后，依赖包被安装到了 <code>node_modules</code> ，下面我们来具体了解下，<code>npm</code> 将依赖包安装到 <code>node_modules</code> 的具体机制是什么。<br />在 <code>npm</code> 的早期版本， <code>npm</code> 处理依赖的方式简单粗暴，以递归的形式，严格按照 <code>package.json</code> 结构以及子依赖包的 <code>package.json</code> 结构将依赖安装到他们各自的 <code>node_modules</code> 中。直到有子依赖包不在依赖其他模块。<br />举个例子，我们的模块 <code>my-app</code> 现在依赖了两个模块：<code>buffer</code>、<code>ignore</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;my-app&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;buffer&quot;: &quot;^5.4.3&quot;,</span><br><span class="line">    &quot;ignore&quot;: &quot;^5.1.4&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ignore</code>是一个纯 <code>JS</code> 模块，不依赖任何其他模块，而 <code>buffer</code> 又依赖了下面两个模块：<code>base64-js</code> 、 <code>ieee754</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;buffer&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;base64-js&quot;: &quot;^1.0.2&quot;,</span><br><span class="line">    &quot;ieee754&quot;: &quot;^1.1.4&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，执行 <code>npm install</code> 后，得到的 <code>node_modules</code> 中模块目录结构就是下面这样的：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744874-9a4552af-2e48-4e06-bd1c-b123a733bfcd.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br />这样的方式优点很明显， <code>node_modules</code> 的结构和 <code>package.json</code> 结构一一对应，层级结构明显，并且保证了每次安装目录结构都是相同的。<br />但是，试想一下，如果你依赖的模块非常之多，你的 <code>node_modules</code> 将非常庞大，嵌套层级非常之深：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744867-0f28265c-54d2-4b5c-b94b-548cd83c1229.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br /></p>
</li>
<li><p>在不同层级的依赖中，可能引用了同一个模块，导致大量冗余。<br /></p>
</li>
<li><p>在 <code>Windows</code> 系统中，文件路径最大长度为260个字符，嵌套层级过深可能导致不可预知的问题。<br /><br><a name="ZMrLv"></a></p>
<h3 id="3-2-扁平结构"><a href="#3-2-扁平结构" class="headerlink" title="3.2 扁平结构"></a>3.2 扁平结构</h3><p>为了解决以上问题，<code>NPM</code> 在 <code>3.x</code> 版本做了一次较大更新。其将早期的嵌套结构改为扁平结构：</p>
</li>
<li><p>安装模块时，不管其是直接依赖还是子依赖的依赖，优先将其安装在 <code>node_modules</code> 根目录。<br /></p>
</li>
</ul>
<p>还是上面的依赖结构，我们在执行 <code>npm install</code> 后将得到下面的目录结构：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742649-4aaf7e81-3009-4dea-a159-1f779e748d35.webp#align=left&display=inline&height=183&originHeight=112&originWidth=402&size=0&status=done&style=none&width=657"><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742618-5f15425c-e6c0-4d05-9d6d-7eb059a9f6b8.webp#align=left&display=inline&height=354&originHeight=582&originWidth=1080&size=0&status=done&style=none&width=657"><br />此时我们若在模块中又依赖了 <code>base64-js@1.0.1</code> 版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;my-app&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;buffer&quot;: &quot;^5.4.3&quot;,</span><br><span class="line">    &quot;ignore&quot;: &quot;^5.1.4&quot;,</span><br><span class="line">    &quot;base64-js&quot;: &quot;1.0.1&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当安装到相同模块时，判断已安装的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 <code>node_modules</code> 下安装该模块。<br /></li>
</ul>
<p>此时，我们在执行 <code>npm install</code> 后将得到下面的目录结构：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742673-b45a7f1d-09ab-4323-a1f4-22774ce1ef81.webp#align=left&display=inline&height=375&originHeight=294&originWidth=515&size=0&status=done&style=none&width=657"><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744873-7001bdc6-523d-4b8f-8815-ea70b589214f.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br />对应的，如果我们在项目代码中引用了一个模块，模块查找流程如下：</p>
<ul>
<li>在当前模块路径下搜索<br /></li>
<li>在当前模块 <code>node_modules</code> 路径下搜素<br /></li>
<li>在上级模块的 <code>node_modules</code> 路径下搜索<br /></li>
<li>…<br /></li>
<li>直到搜索到全局路径中的 <code>node_modules</code><br /></li>
</ul>
<p>假设我们又依赖了一个包 <code>buffer2@^5.4.3</code>，而它依赖了包 <code>base64-js@1.0.3</code>，则此时的安装结构是下面这样的：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744877-cd1ed81f-38f1-478b-9d7c-88309de27046.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br />所以 <code>npm 3.x</code> 版本并未完全解决老版本的模块冗余问题，甚至还会带来新的问题。<br />试想一下，你的APP假设没有依赖 <code>base64-js@1.0.1</code> 版本，而你同时依赖了依赖不同 <code>base64-js</code> 版本的 <code>buffer</code> 和 <code>buffer2</code>。由于在执行 <code>npm install</code> 的时候，按照 <code>package.json</code> 里依赖的顺序依次解析，则 <code>buffer</code> 和 <code>buffer2</code> 在  <code>package.json</code> 的放置顺序则决定了 <code>node_modules</code> 的依赖结构：<br />先依赖<code>buffer2</code>：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744890-0be552c4-b052-408f-8fd7-7a9d6c28a7cc.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br />先依赖<code>buffer</code>：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742730-6a7d820e-d5c0-4a84-b359-e6f12618eb5a.webp#align=left&display=inline&height=350&originHeight=575&originWidth=1080&size=0&status=done&style=none&width=657"><br />另外，为了让开发者在安全的前提下使用最新的依赖包，我们在 <code>package.json</code> 通常只会锁定大版本，这意味着在某些依赖包小版本更新后，同样可能造成依赖结构的改动，依赖结构的不确定性可能会给程序带来不可预知的问题。<br><a name="k92gq"></a></p>
<h3 id="3-3-Lock文件"><a href="#3-3-Lock文件" class="headerlink" title="3.3 Lock文件"></a>3.3 Lock文件</h3><p>为了解决 <code>npm install</code> 的不确定性问题，在 <code>npm 5.x</code> 版本新增了 <code>package-lock.json</code> 文件，而安装方式还沿用了 <code>npm 3.x</code> 的扁平化的方式。<br /><code>package-lock.json</code> 的作用是锁定依赖结构，即只要你目录下有 <code>package-lock.json</code> 文件，那么你每次执行 <code>npm install</code> 后生成的 <code>node_modules</code> 目录结构一定是完全相同的。<br />例如，我们有如下的依赖结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;my-app&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;buffer&quot;: &quot;^5.4.3&quot;,</span><br><span class="line">    &quot;ignore&quot;: &quot;^5.1.4&quot;,</span><br><span class="line">    &quot;base64-js&quot;: &quot;1.0.1&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行 <code>npm install</code> 后生成的 <code>package-lock.json</code> 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;my-app&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;base64-js&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class="line">      &quot;resolved&quot;: &quot;https://registry.npmjs.org/base64-js/-/base64-js-1.0.1.tgz&quot;,</span><br><span class="line">      &quot;integrity&quot;: &quot;sha1-aSbRsZT7xze47tUTdW3i/Np+pAg=&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;buffer&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;5.4.3&quot;,</span><br><span class="line">      &quot;resolved&quot;: &quot;https://registry.npmjs.org/buffer/-/buffer-5.4.3.tgz&quot;,</span><br><span class="line">      &quot;integrity&quot;: &quot;sha512-zvj65TkFeIt3i6aj5bIvJDzjjQQGs4o/sNoezg1F1kYap9Nu2jcUdpwzRSJTHMMzG0H7bZkn4rNQpImhuxWX2A==&quot;,</span><br><span class="line">      &quot;requires&quot;: &#123;</span><br><span class="line">        &quot;base64-js&quot;: &quot;^1.0.2&quot;,</span><br><span class="line">        &quot;ieee754&quot;: &quot;^1.1.4&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;dependencies&quot;: &#123;</span><br><span class="line">        &quot;base64-js&quot;: &#123;</span><br><span class="line">          &quot;version&quot;: &quot;1.3.1&quot;,</span><br><span class="line">          &quot;resolved&quot;: &quot;https://registry.npmjs.org/base64-js/-/base64-js-1.3.1.tgz&quot;,</span><br><span class="line">          &quot;integrity&quot;: &quot;sha512-mLQ4i2QO1ytvGWFWmcngKO//JXAQueZvwEKtjgQFM4jIK0kU+ytMfplL8j+n5mspOfjHwoAg+9yhb7BwAHm36g==&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ieee754&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;1.1.13&quot;,</span><br><span class="line">      &quot;resolved&quot;: &quot;https://registry.npmjs.org/ieee754/-/ieee754-1.1.13.tgz&quot;,</span><br><span class="line">      &quot;integrity&quot;: &quot;sha512-4vf7I2LYV/HaWerSo3XmlMkp5eZ83i+/CDluXi/IGTs/O1sejBNhTtnxzmRZfvOUqj7lZjqHkeTvpgSFDlWZTg==&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ignore&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;5.1.4&quot;,</span><br><span class="line">      &quot;resolved&quot;: &quot;https://registry.npmjs.org/ignore/-/ignore-5.1.4.tgz&quot;,</span><br><span class="line">      &quot;integrity&quot;: &quot;sha512-MzbUSahkTW1u7JpKKjY7LCARd1fU5W2rLdxlM4kdkayuCwZImjkpluF9CM1aLewYJguPDqewLam18Y6AU69A8A==&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来具体看看上面的结构：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744925-a50aefa1-3aa4-4a97-a382-1211900052dc.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br />最外面的两个属性 <code>name</code> 、<code>version</code> 同 <code>package.json</code> 中的 <code>name</code> 和 <code>version</code> ，用于描述当前包名称和版本。<br /><code>dependencies</code> 是一个对象，对象和 <code>node_modules</code> 中的包结构一一对应，对象的 <code>key</code> 为包名称，值为包的一些描述信息：</p>
<ul>
<li><code>version</code>：包版本 —— 这个包当前安装在 <code>node_modules</code> 中的版本<br /></li>
<li><code>resolved</code>：包具体的安装来源<br /></li>
<li><code>integrity</code>：包 <code>hash</code> 值，基于 <code>Subresource Integrity</code> 来验证已安装的软件包是否被改动过、是否已失效<br /></li>
<li><code>requires</code>：对应子依赖的依赖，与子依赖的 <code>package.json</code> 中 <code>dependencies</code>的依赖项相同。<br /></li>
<li><code>dependencies</code>：结构和外层的 <code>dependencies</code> 结构相同，存储安装在子依赖 <code>node_modules</code> 中的依赖包。<br /></li>
</ul>
<p>这里注意，并不是所有的子依赖都有 <code>dependencies</code> 属性，只有子依赖的依赖和当前已安装在根目录的  <code>node_modules</code> 中的依赖冲突之后，才会有这个属性。<br />例如，回顾下上面的依赖关系：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744892-536d6c0f-e9d0-453a-93c7-909567660a87.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br />我们在 <code>my-app</code> 中依赖的 <code>base64-js@1.0.1</code> 版本与 <code>buffer</code> 中依赖的 <code>base64-js@^1.0.2</code> 发生冲突，所以  <code>base64-js@1.0.1</code>  需要安装在 <code>buffer</code> 包的 <code>node_modules</code> 中，对应了 <code>package-lock.json</code> 中 <code>buffer</code> 的 <code>dependencies</code> 属性。这也对应了 <code>npm</code> 对依赖的扁平化处理方式。<br />所以，根据上面的分析， <code>package-lock.json</code> 文件 和 <code>node_modules</code> 目录结构是一一对应的，即项目目录下存在  <code>package-lock.json</code> 可以让每次安装生成的依赖目录结构保持相同。<br />另外，项目中使用了 <code>package-lock.json</code> 可以显著加速依赖安装时间。<br />我们使用 <code>npm i --timing=true --loglevel=verbose</code> 命令可以看到 <code>npm install</code> 的完整过程，下面我们来对比下使用 <code>lock</code> 文件和不使用 <code>lock</code> 文件的差别。在对比前先清理下<code>npm</code> 缓存。<br />不使用 <code>lock</code> 文件：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535742710-47ff6566-d6df-44f7-b30d-110a59dba0a3.gif#align=left&display=inline&height=370&originHeight=360&originWidth=639&size=0&status=done&style=none&width=657"><br />使用 <code>lock</code> 文件：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535742685-2ac4a78a-df7e-44e2-80f9-8f076dc928b7.gif#align=left&display=inline&height=370&originHeight=360&originWidth=639&size=0&status=done&style=none&width=657">[]<br />可见， <code>package-lock.json</code> 中已经缓存了每个包的具体版本和下载链接，不需要再去远程仓库进行查询，然后直接进入文件完整性校验环节，减少了大量网络请求。<br><a name="FDHYf"></a></p>
<h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><p>开发系统应用时，建议把 <code>package-lock.json</code> 文件提交到代码版本仓库，从而保证所有团队开发者以及 <code>CI</code> 环节可以在执行 <code>npm install</code> 时安装的依赖版本都是一致的。<br />在开发一个 <code>npm</code>包 时，你的 <code>npm</code>包 是需要被其他仓库依赖的，由于上面我们讲到的扁平安装机制，如果你锁定了依赖包版本，你的依赖包就不能和其他依赖包共享同一 <code>semver</code> 范围内的依赖包，这样会造成不必要的冗余。所以我们不应该把<code>package-lock.json</code> 文件发布出去（ <code>npm</code> 默认也不会把 <code>package-lock.json</code> 文件发布出去）。<br><a name="pvPhw"></a></p>
<h3 id="3-4-缓存"><a href="#3-4-缓存" class="headerlink" title="3.4 缓存"></a>3.4 缓存</h3><p>在执行 <code>npm install</code> 或 <code>npm update</code>命令下载依赖后，除了将依赖包安装在<code>node_modules</code> 目录下外，还会在本地的缓存目录缓存一份。<br />通过 <code>npm config get cache</code> 命令可以查询到：在 <code>Linux</code> 或 <code>Mac</code> 默认是用户主目录下的 <code>.npm/_cacache</code> 目录。<br />在这个目录下又存在两个目录：<code>content-v2</code>、<code>index-v5</code>，<code>content-v2</code> 目录用于存储 <code>tar</code>包的缓存，而<code>index-v5</code>目录用于存储<code>tar</code>包的 <code>hash</code>。<br />npm 在执行安装时，可以根据 <code>package-lock.json</code> 中存储的 <code>integrity、version、name</code> 生成一个唯一的 <code>key</code> 对应到 <code>index-v5</code> 目录下的缓存记录，从而找到 <code>tar</code>包的 <code>hash</code>，然后根据 <code>hash</code> 再去找缓存的 <code>tar</code>包直接使用。<br />我们可以找一个包在缓存目录下搜索测试一下，在 <code>index-v5</code> 搜索一下包路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;https://registry.npmjs.org/base64-js/-/base64-js-1.0.1.tgz&quot; -r index-v5</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744916-ae68a05d-0223-4dfc-a292-fc37c8ad731b.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br />然后我们将json格式化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;key&quot;: &quot;pacote:version-manifest:https://registry.npmjs.org/base64-js/-/base64-js-1.0.1.tgz:sha1-aSbRsZT7xze47tUTdW3i/Np+pAg=&quot;,</span><br><span class="line">  &quot;integrity&quot;: &quot;sha512-C2EkHXwXvLsbrucJTRS3xFHv7Mf/y9klmKDxPTE8yevCoH5h8Ae69Y+/lP+ahpW91crnzgO78elOk2E6APJfIQ==&quot;,</span><br><span class="line">  &quot;time&quot;: 1575554308857,</span><br><span class="line">  &quot;size&quot;: 1,</span><br><span class="line">  &quot;metadata&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: &quot;base64-js@1.0.1&quot;,</span><br><span class="line">    &quot;manifest&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;base64-js&quot;,</span><br><span class="line">      &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class="line">      &quot;engines&quot;: &#123;</span><br><span class="line">        &quot;node&quot;: &quot;&gt;= 0.4&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;dependencies&quot;: &#123;&#125;,</span><br><span class="line">      &quot;optionalDependencies&quot;: &#123;&#125;,</span><br><span class="line">      &quot;devDependencies&quot;: &#123;</span><br><span class="line">        &quot;standard&quot;: &quot;^5.2.2&quot;,</span><br><span class="line">        &quot;tape&quot;: &quot;4.x&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;bundleDependencies&quot;: false,</span><br><span class="line">      &quot;peerDependencies&quot;: &#123;&#125;,</span><br><span class="line">      &quot;deprecated&quot;: false,</span><br><span class="line">      &quot;_resolved&quot;: &quot;https://registry.npmjs.org/base64-js/-/base64-js-1.0.1.tgz&quot;,</span><br><span class="line">      &quot;_integrity&quot;: &quot;sha1-aSbRsZT7xze47tUTdW3i/Np+pAg=&quot;,</span><br><span class="line">      &quot;_shasum&quot;: &quot;6926d1b194fbc737b8eed513756de2fcda7ea408&quot;,</span><br><span class="line">      &quot;_shrinkwrap&quot;: null,</span><br><span class="line">      &quot;bin&quot;: null,</span><br><span class="line">      &quot;_id&quot;: &quot;base64-js@1.0.1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;type&quot;: &quot;finalized-manifest&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>_shasum</code> 属性 <code>6926d1b194fbc737b8eed513756de2fcda7ea408</code> 即为 <code>tar</code> 包的 <code>hash</code>， <code>hash</code>的前几位 <code>6926</code> 即为缓存的前两层目录，我们进去这个目录果然找到的压缩后的依赖包：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742736-16add4a7-fdff-4c6f-a516-b9975a6f94fc.webp#align=left&display=inline&height=113&originHeight=185&originWidth=1080&size=0&status=done&style=none&width=657"></p>
<blockquote>
<p>以上的缓存策略是从 npm v5 版本开始的，在 npm v5 版本之前，每个缓存的模块在 ~/.npm 文件夹中以模块名的形式直接存储，储存结构是{cache}/{name}/{version}。</p>
</blockquote>
<p><code>npm</code> 提供了几个命令来管理缓存数据：</p>
<ul>
<li><code>npm cache add</code>：官方解释说这个命令主要是 <code>npm</code> 内部使用，但是也可以用来手动给一个指定的 package 添加缓存。<br /></li>
<li><code>npm cache clean</code>：删除缓存目录下的所有数据，为了保证缓存数据的完整性，需要加上 <code>--force</code> 参数。<br /></li>
<li><code>npm cache verify</code>：验证缓存数据的有效性和完整性，清理垃圾数据。<br /></li>
</ul>
<p>基于缓存数据，npm 提供了离线安装模式，分别有以下几种：</p>
<ul>
<li><p><code>--prefer-offline</code>：优先使用缓存数据，如果没有匹配的缓存数据，则从远程仓库下载。<br /></p>
</li>
<li><p><code>--prefer-online</code>：优先使用网络数据，如果网络数据请求失败，再去请求缓存数据，这种模式可以及时获取最新的模块。<br /></p>
</li>
<li><p><code>--offline</code>：不请求网络，直接使用缓存数据，一旦缓存数据不存在，则安装失败。<br /><br><a name="tfehL"></a></p>
<h3 id="3-5-文件完整性"><a href="#3-5-文件完整性" class="headerlink" title="3.5 文件完整性"></a>3.5 文件完整性</h3><p>上面我们多次提到了文件完整性，那么什么是文件完整性校验呢？<br />在下载依赖包之前，我们一般就能拿到 <code>npm</code> 对该依赖包计算的 <code>hash</code> 值，例如我们执行 <code>npm info</code> 命令，紧跟 <code>tarball</code>(下载链接) 的就是 <code>shasum</code>(<code>hash</code>) ：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742699-a09ee38d-834b-461f-8f95-1a2453724668.webp#align=left&display=inline&height=279&originHeight=336&originWidth=792&size=0&status=done&style=none&width=657"><br />用户下载依赖包到本地后，需要确定在下载过程中没有出现错误，所以在下载完成之后需要在本地在计算一次文件的 <code>hash</code> 值，如果两个 <code>hash</code> 值是相同的，则确保下载的依赖是完整的，如果不同，则进行重新下载。<br><a name="K6IjE"></a></p>
<h3 id="3-6-整体流程"><a href="#3-6-整体流程" class="headerlink" title="3.6 整体流程"></a>3.6 整体流程</h3><p>好了，我们再来整体总结下上面的流程：</p>
</li>
<li><p>检查 <code>.npmrc</code> 文件：优先级为：项目级的 <code>.npmrc</code> 文件 &gt; 用户级的 <code>.npmrc</code> 文件&gt; 全局级的 <code>.npmrc</code> 文件 &gt; npm 内置的 <code>.npmrc</code> 文件<br /></p>
</li>
<li><p>检查项目中有无 <code>lock</code> 文件。<br /></p>
</li>
<li><p>无 <code>lock</code> 文件：<br /></p>
<ul>
<li>不存在缓存：<br /></li>
<li>存在缓存：将缓存按照依赖结构解压到 <code>node_modules</code><br /></li>
<li>将下载的包复制到 <code>npm</code> 缓存目录<br /></li>
<li>将下载的包按照依赖结构解压到 <code>node_modules</code><br /></li>
<li>重新下载<br /></li>
<li>从 <code>npm</code> 远程仓库下载包<br /></li>
<li>校验包的完整性<br /></li>
<li>校验不通过：<br /></li>
<li>校验通过：<br /></li>
<li>构建依赖树时，不管其是直接依赖还是子依赖的依赖，优先将其放置在 <code>node_modules</code> 根目录。<br /></li>
<li>当遇到相同模块时，判断已放置在依赖树的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 <code>node_modules</code> 下放置该模块。<br /></li>
<li>注意这一步只是确定逻辑上的依赖树，并非真正的安装，后面会根据这个依赖结构去下载或拿到缓存中的依赖包<br /></li>
<li>从 <code>npm</code> 远程仓库获取包信息<br /></li>
<li>根据 <code>package.json</code> 构建依赖树，构建过程：<br /></li>
<li>在缓存中依次查找依赖树中的每个包<br /></li>
<li>将包解压到 <code>node_modules</code><br /></li>
<li>生成 <code>lock</code> 文件<br /></li>
</ul>
</li>
<li><p>有 <code>lock</code> 文件：<br /></p>
<ul>
<li>检查 <code>package.json</code> 中的依赖版本是否和 <code>package-lock.json</code> 中的依赖有冲突。<br /></li>
<li>如果没有冲突，直接跳过获取包信息、构建依赖树过程，开始在缓存中查找包信息，后续过程相同<br /></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744893-3321d080-037b-4b81-88eb-aaa367a9d8f5.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br />上面的过程简要描述了 <code>npm install</code> 的大概过程，这个过程还包含了一些其他的操作，例如执行你定义的一些生命周期函数，你可以执行 <code>npm install package --timing=true --loglevel=verbose</code> 来查看某个包具体的安装流程和细节。<br><a name="IZbrV"></a></p>
<h3 id="3-7-yarn"><a href="#3-7-yarn" class="headerlink" title="3.7 yarn"></a>3.7 yarn</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744887-0e2a904e-5c06-47ec-93a2-87d4c50611dc.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br /><code>yarn</code> 是在 <code>2016</code> 年发布的，那时 <code>npm</code> 还处于 <code>V3</code> 时期，那时候还没有 <code>package-lock.json</code> 文件，就像上面我们提到的：不稳定性、安装速度慢等缺点经常会受到广大开发者吐槽。此时，<code>yarn</code> 诞生：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1579535744888-c339037b-03a1-4cab-b585-d88a59576952.gif#align=left&display=inline&height=1&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br />上面是官网提到的 <code>yarn</code> 的优点，在那个时候还是非常吸引人的。当然，后来 <code>npm</code> 也意识到了自己的问题，进行了很多次优化，在后面的优化（<code>lock</code>文件、缓存、默认-s…）中，我们多多少少能看到 <code>yarn</code> 的影子，可见 <code>yarn</code> 的设计还是非常优秀的。<br /><code>yarn</code> 也是采用的是 <code>npm v3</code> 的扁平结构来管理依赖，安装依赖后默认会生成一个 <code>yarn.lock</code> 文件，还是上面的依赖关系，我们看看 <code>yarn.lock</code> 的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.</span><br><span class="line"># yarn lockfile v1</span><br><span class="line">base64-js@1.0.1:</span><br><span class="line">  version &quot;1.0.1&quot;</span><br><span class="line">  resolved &quot;https://registry.yarnpkg.com/base64-js/-/base64-js-1.0.1.tgz#6926d1b194fbc737b8eed513756de2fcda7ea408&quot;</span><br><span class="line">  integrity sha1-aSbRsZT7xze47tUTdW3i/Np+pAg=</span><br><span class="line">base64-js@^1.0.2:</span><br><span class="line">  version &quot;1.3.1&quot;</span><br><span class="line">  resolved &quot;https://registry.yarnpkg.com/base64-js/-/base64-js-1.3.1.tgz#58ece8cb75dd07e71ed08c736abc5fac4dbf8df1&quot;</span><br><span class="line">  integrity sha512-mLQ4i2QO1ytvGWFWmcngKO//JXAQueZvwEKtjgQFM4jIK0kU+ytMfplL8j+n5mspOfjHwoAg+9yhb7BwAHm36g==</span><br><span class="line">buffer@^5.4.3:</span><br><span class="line">  version &quot;5.4.3&quot;</span><br><span class="line">  resolved &quot;https://registry.yarnpkg.com/buffer/-/buffer-5.4.3.tgz#3fbc9c69eb713d323e3fc1a895eee0710c072115&quot;</span><br><span class="line">  integrity sha512-zvj65TkFeIt3i6aj5bIvJDzjjQQGs4o/sNoezg1F1kYap9Nu2jcUdpwzRSJTHMMzG0H7bZkn4rNQpImhuxWX2A==</span><br><span class="line">  dependencies:</span><br><span class="line">    base64-js &quot;^1.0.2&quot;</span><br><span class="line">    ieee754 &quot;^1.1.4&quot;</span><br><span class="line">ieee754@^1.1.4:</span><br><span class="line">  version &quot;1.1.13&quot;</span><br><span class="line">  resolved &quot;https://registry.yarnpkg.com/ieee754/-/ieee754-1.1.13.tgz#ec168558e95aa181fd87d37f55c32bbcb6708b84&quot;</span><br><span class="line">  integrity sha512-4vf7I2LYV/HaWerSo3XmlMkp5eZ83i+/CDluXi/IGTs/O1sejBNhTtnxzmRZfvOUqj7lZjqHkeTvpgSFDlWZTg==</span><br><span class="line">ignore@^5.1.4:</span><br><span class="line">  version &quot;5.1.4&quot;</span><br><span class="line">  resolved &quot;https://registry.yarnpkg.com/ignore/-/ignore-5.1.4.tgz#84b7b3dbe64552b6ef0eca99f6743dbec6d97adf&quot;</span><br><span class="line">  integrity sha512-MzbUSahkTW1u7JpKKjY7LCARd1fU5W2rLdxlM4kdkayuCwZImjkpluF9CM1aLewYJguPDqewLam18Y6AU69A8A==</span><br></pre></td></tr></table></figure>
<p>可见其和 <code>package-lock.json</code> 文件还是比较类似的，还有一些区别就是：</p>
<ul>
<li><code>package-lock.json</code> 使用的是 <code>json</code> 格式，<code>yarn.lock</code> 使用的是一种自定义格式<br /></li>
<li><code>yarn.lock</code> 中子依赖的版本号不是固定的，意味着单独又一个 <code>yarn.lock</code> 确定不了 <code>node_modules</code> 目录结构，还需要和 <code>package.json</code> 文件进行配合。而 <code>package-lock.json</code> 只需要一个文件即可确定。<br /></li>
</ul>
<p><code>yarn</code> 的缓策略看起来和 <code>npm v5</code> 之前的很像，每个缓存的模块被存放在独立的文件夹，文件夹名称包含了模块名称、版本号等信息。使用命令 <code>yarn cache dir</code> 可以查看缓存数据的目录：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/186051/1579535742775-b232e73c-1ce0-4afc-a770-bd78b89bbeb8.webp#align=left&display=inline&height=385&originHeight=633&originWidth=1080&size=0&status=done&style=none&width=657"></p>
<blockquote>
<p><code>yarn</code> 默认使用 <code>prefer-online</code> 模式，即优先使用网络数据，如果网络数据请求失败，再去请求缓存数据。</p>
</blockquote>
<p><a name="wMpBF"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a6008c2f265da3e5033cd93">https://juejin.im/post/5a6008c2f265da3e5033cd93</a><br /></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/305539244/answer/551386426">https://www.zhihu.com/question/305539244/answer/551386426</a><br /></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37285173">https://zhuanlan.zhihu.com/p/37285173</a><br /></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://semver.org/lang/zh-CN/">https://semver.org/lang/zh-CN/</a><br /></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://deadhorse.me/nodejs/2014/04/27/semver-in-nodejs.html">http://deadhorse.me/nodejs/2014/04/27/semver-in-nodejs.html</a><br /></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://caibaojian.com/npm/files/package.json.html">http://caibaojian.com/npm/files/package.json.html</a><br /><br><a name="OuMZt"></a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望阅读完本篇文章能对你有如下帮助：</p>
</li>
<li><p>了解 <code>pacakge.json</code> 中的各项详细配置从而对项目工程化配置有更进一步的见解<br /></p>
</li>
<li><p>掌握 <code>npm</code> 的版本管理机制，能合理配置依赖版本<br /></p>
</li>
<li><p>理解 <code>npm install</code> 安装原理，能合理运用 <code>npm</code>缓存、<code>package-lock.json</code><br /></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/20/192-%E3%80%90NPM%E3%80%91%E5%89%96%E6%9E%90npm%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" data-id="ckts3ejzw00rl4d9k71btagpm" data-title="192-【NPM】剖析npm的包管理机制" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NPM/" rel="tag">NPM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-191-【CSS】写给自己看的shapes布局教程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/08/191-%E3%80%90CSS%E3%80%91%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9C%8B%E7%9A%84shapes%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2020-01-07T16:17:09.000Z" itemprop="datePublished">2020-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/08/191-%E3%80%90CSS%E3%80%91%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9C%8B%E7%9A%84shapes%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B/">191-【CSS】写给自己看的shapes布局教程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a name="er6Ws"></a></p>
<h3 id="一、前言-amp-索引"><a href="#一、前言-amp-索引" class="headerlink" title="一、前言&amp;索引"></a>一、前言&amp;索引</h3><p>CSS Shapes布局可以实现不规则的文字环绕效果，需要和浮动配合使用。<br />兼容性如下图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566072-77759718-883a-4a50-bc7a-fe8e041cbde6.png#align=left&display=inline&height=212&originHeight=212&originWidth=489&size=0&status=done&style=none&width=489"><br />还是很不错的，移动端可用，内部中后台项目可用。<br />CSS shapes布局相关属性并不多，学习成本比grid布局，flex布局小很多。</p>
<table>
<thead>
<tr>
<th align="center">Shapes布局相关属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><br />- <a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2019/02/css-css3-shapes/#shape-outside">shape-outside</a><br />- <a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2019/02/css-css3-shapes/#shape-margin">shape-margin</a><br />- <a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2019/02/css-css3-shapes/#shape-image-threshold">shape-image-threshold</a><br /></td>
</tr>
</tbody></table>
<p><a name="shape-outside"></a></p>
<h3 id="二、详细了解shape-outside"><a href="#二、详细了解shape-outside" class="headerlink" title="二、详细了解shape-outside"></a>二、详细了解shape-outside</h3><p><code>shape-outside</code>是不规则形状环绕布局的核心，支持的属性值分为如下四大类：</p>
<ol>
<li>none – 默认值</li>
<li><shape-box> – 图形盒子。</li>
<li><basic-shape> – 基本图形函数。</li>
<li><image> – 图像类。</li>
</ol>
<p>其中：</p>
<ul>
<li><code>none</code>很好理解，表示就是普通的矩形环绕。</li>
<li><code>&lt;shape-box&gt;</code>（图形盒子）是shape相关布局中的一个名词，比<code>clip-path</code>属性中的<code>&lt;geometry-box&gt;</code>（几何盒子）支持的盒子要少一些，就是CSS2.1中的基本盒模型的4种盒子，分别是<code>margin-box</code>，<code>border-box</code>，<code>padding-box</code>和<code>content-box</code>。要来指定文字环绕的时候是依照哪个盒子的边缘来计算的。</li>
<li><code>&lt;basic-shape&gt;</code>指的是基本形状函数，和CSS <a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2014/12/css3-svg-clip-path/">clip-path剪裁属性</a>支持的基本形状函数一模一样。</li>
<li><code>&lt;image&gt;</code>值的是图像类，包括URL链接图片，渐变图像，<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2012/09/css3-background-image-cross-fade/">cross-fade()</a>，<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/?p=1758">element()</a>等。所有这些图像类，<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2017/11/css-css3-mask-masks/">CSS3 mask遮罩属性</a>也都支持，本文只会介绍常用的URL链接和渐变图像，其他图片类不介绍，有兴趣可以访问<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2017/11/css-css3-mask-masks/">介绍遮罩的这篇文章</a>，有完全展示。</li>
</ul>
<p>不同类型属性值使用示意（取自<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/shape-outside">MDN</a>）：<br /></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 关键字值 */</span></span><br><span class="line">shape-outside: none;</span><br><span class="line">shape-outside: margin-box;</span><br><span class="line">shape-outside: content-box;</span><br><span class="line">shape-outside: border-box;</span><br><span class="line">shape-outside: padding-box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数值 */</span></span><br><span class="line">shape-outside: <span class="built_in">circle</span>();</span><br><span class="line">shape-outside: <span class="built_in">ellipse</span>();</span><br><span class="line">shape-outside: <span class="built_in">inset</span>(<span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span>);</span><br><span class="line">shape-outside: <span class="built_in">polygon</span>(<span class="number">10px</span> <span class="number">10px</span>, <span class="number">20px</span> <span class="number">20px</span>, <span class="number">30px</span> <span class="number">30px</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;url&gt;值 */</span></span><br><span class="line">shape-outside: <span class="built_in">url</span>(<span class="string">image.png</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 渐变值 */</span></span><br><span class="line">shape-outside: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>) <span class="number">150px</span>, red <span class="number">150px</span>);</span><br></pre></td></tr></table></figure>

<p>我们通过一个一个实例快速了解下各个类型属性值的作用和表现。<br><a name="sMS0q"></a></p>
<h4 id="1-关键字属性值"><a href="#1-关键字属性值" class="headerlink" title="1. 关键字属性值"></a>1. 关键字属性值</h4><p>测试HTML和CSS代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;shape&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>在CSS Shapes问世之前...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.shape</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>; <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: currentColor;</span><br><span class="line">    <span class="attribute">background-clip</span>: content-box;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#cd0000</span>;</span><br><span class="line">    shape-outside: none;  <span class="comment">/* 或margin-box，border-box，padding-box，content-box */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果布局表现如下GIF截屏示意：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1578413566089-42f0d934-b234-4eea-a500-5cafbeb78faa.gif#align=left&display=inline&height=343&originHeight=343&originWidth=421&size=0&status=done&style=none&width=421"><br />可以看到，当<code>shape-outside</code>属性值为<code>none</code>以外的其他关键字的时候，就算是普通的<code>border-radius</code>圆角也能实现环绕效果。<br />眼见为实，您可以狠狠的点击这里：<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/study/201901/css-shape-outside-keywords-demo.php">CSS shape-outside关键字属性值测试demo</a><br><a name="dIThY"></a></p>
<h4 id="2-基本的形状函数"><a href="#2-基本的形状函数" class="headerlink" title="2. 基本的形状函数"></a>2. 基本的形状函数</h4><p>指的是下面这四个基本的形状函数：</p>
<ul>
<li>circle() – 圆</li>
<li>ellipse() – 椭圆</li>
<li>inset() – 内矩形（包括圆角矩形）</li>
<li>polygon() – 多边形</li>
</ul>
<p>其中：<br /><strong>circle() – 圆</strong><br />语法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">circle( <span class="selector-attr">[&lt;shape-radius&gt;]</span>? <span class="selector-attr">[at &lt;position&gt;]</span>? )</span><br></pre></td></tr></table></figure>

<p>其中问号<code>?</code>是正则表达式中的特殊字符，表示<code>0</code>和<code>1</code>，也就是说<code>shape-radius</code>（圆半径）和<code>position</code>（圆心位置）都是可以缺省的，表示。因此，下面的写法都是合法的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shape-outside: <span class="built_in">circle</span>();</span><br><span class="line">shape-outside: <span class="built_in">circle</span>(<span class="number">50%</span>);</span><br><span class="line">shape-outside: <span class="built_in">circle</span>(at <span class="number">50%</span> <span class="number">50%</span>);</span><br><span class="line">shape-outside: <span class="built_in">circle</span>(<span class="number">50%</span> at <span class="number">50%</span> <span class="number">50%</span>);</span><br><span class="line">shape-outside: <span class="built_in">circle</span>(<span class="number">50px</span> at <span class="number">50px</span> <span class="number">50px</span>);</span><br></pre></td></tr></table></figure>

<p>可以实现类似下图的环绕效果：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566147-1d8124fa-0c35-4054-aba2-3d917e598df0.png#align=left&display=inline&height=225&originHeight=225&originWidth=254&size=0&status=done&style=none&width=254"><br />和关键字属性值加<code>border-radius</code>实现的圆形环绕相比，<code>circle()</code>得实现相对更加灵活一些，比方说想弄一个半圆的环绕效果，可以：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shape-outside: <span class="built_in">circle</span>(<span class="number">50%</span> at <span class="number">0%</span> <span class="number">50%</span>);</span><br></pre></td></tr></table></figure>

<p>结果如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566157-64b0da0a-540a-4eb7-a884-b7d0fa1aa163.png#align=left&display=inline&height=223&originHeight=223&originWidth=303&size=0&status=done&style=none&width=303"><br /><strong>ellipse() – 椭圆</strong><br />语法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ellipse( <span class="selector-attr">[&lt;shape-radius&gt;&#123;2&#125;]</span>? <span class="selector-attr">[at &lt;position&gt;]</span>? )</span><br></pre></td></tr></table></figure>

<p>x轴半径，y轴半径，以及椭圆的圆心位置。以下都是合法的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shape-outside: <span class="built_in">ellipse</span>();</span><br><span class="line">shape-outside: <span class="built_in">ellipse</span>(<span class="number">50px</span> <span class="number">75px</span>);</span><br><span class="line">shape-outside: <span class="built_in">ellipse</span>(at <span class="number">50%</span> <span class="number">50%</span>);</span><br><span class="line">shape-outside: <span class="built_in">ellipse</span>(<span class="number">50px</span> <span class="number">75px</span> at <span class="number">50%</span> <span class="number">50%</span>);</span><br></pre></td></tr></table></figure>

<p>x，y半径除了具体数值，还支持<code>farthest-side</code>和<code>closest-side</code>这两个关键字，顾名思义，分别表示到最长边的长度和最短边的长度。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ellipse(farthest-side closest-side at <span class="number">25%</span> <span class="number">25%</span>)</span><br></pre></td></tr></table></figure>

<p>表示在浮动元素<code>25% 25%</code>位置，以距离浮动元素最长边的距离作为椭圆的x坐标，以距离浮动元素边缘最短的距离作为椭圆的y坐标。于是，有如下的效果图（浮动元素尺寸100*100，红色点标记是<code>25% 25%</code>位置，可以看出椭圆的轮廓）：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566127-e755a974-57b5-4723-bac7-ccf7b7529718.png#align=left&display=inline&height=237&originHeight=237&originWidth=347&size=0&status=done&style=none&width=347"><br />如果我们调换一下顺序，把最短边作为x轴，最长边作为y轴：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ellipse(closest-side farthest-side at <span class="number">25%</span> <span class="number">25%</span>)</span><br></pre></td></tr></table></figure>

<p>则最终的表现如下截图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566140-83887f86-8c79-4179-9a26-3f18b17f3c2d.png#align=left&display=inline&height=259&originHeight=259&originWidth=247&size=0&status=done&style=none&width=247"><br />仔细观察，就不难理解<code>farthest-side</code>和<code>closest-side</code>的意思了。<br /><strong>inset() – 内矩形（包括圆角矩形）</strong><br />语法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inset( &lt;shape-arg&gt;&#123;<span class="number">1</span>,<span class="number">4</span>&#125; <span class="selector-attr">[round &lt;border-radius&gt;]</span>? )</span><br></pre></td></tr></table></figure>

<p>其中<code>shape-arg</code>是必须参数，可以是1~4个值。当提供所有前四个参数时，它们表示从参考框向内的顶部，右侧，底部和左侧偏移，也就是定义了插入的矩形的边缘位置。 这些参数遵循边距缩写的语法（类似<code>margin</code>、<code>padding</code>等属性），我们可以使用1个，2个，3个或4个值。<code>border-radius</code>表示圆角大小，可以缺省。<br />因此，下面这些写法都是合法的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shape-outside: <span class="built_in">inset</span>(<span class="number">10px</span>);</span><br><span class="line">shape-outside: <span class="built_in">inset</span>(<span class="number">10px</span> <span class="number">20px</span>);</span><br><span class="line">shape-outside: <span class="built_in">inset</span>(<span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span>);</span><br><span class="line">shape-outside: <span class="built_in">inset</span>(<span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span> <span class="number">40px</span>);</span><br><span class="line">shape-outside: <span class="built_in">inset</span>(<span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span> <span class="number">40px</span> round <span class="number">10px</span>);</span><br></pre></td></tr></table></figure>

<p>例如上面最后一行代码效果为：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566007-b31ec3e2-3be9-4433-ad3a-c8e3783a56ec.png#align=left&display=inline&height=220&originHeight=220&originWidth=280&size=0&status=done&style=none&width=280"><br />控制台查看元素盒子可以看到：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566143-89bc095e-7eae-4875-a407-1ae3670574a1.png#align=left&display=inline&height=237&originHeight=237&originWidth=310&size=0&status=done&style=none&width=310"><br /><strong>polygon() – 多边形</strong><br /><code>polygon()</code>多边形反而是语法最好理解的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">polygon( <span class="selector-attr">[&lt;fill-rule&gt;,]</span>? <span class="selector-attr">[&lt;shape-arg&gt; &lt;shape-arg&gt;]</span># )</span><br></pre></td></tr></table></figure>

<p><code>fill-rule</code>表示填充规则，可以是<code>nonzero</code>以及<code>evenodd</code>，默认值是<code>nonzero</code>。这两个填充规则是图形领域必须要掌握的基础知识，可以参见我之前的文章“<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2018/10/nonzero-evenodd-fill-mode-rule/">搞懂SVG/Canvas中nonzero和evenodd填充规则</a>”进行学习。<br />场景<code>polygon</code>用法就是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">polygon( x1 y1, x2 y2, x3 y3, ... )</span><br></pre></td></tr></table></figure>

<p>就是一个一个多边形的点坐标。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shape-outside: <span class="built_in">polygon</span>(<span class="number">0</span> <span class="number">0</span>, <span class="number">0</span> <span class="number">100px</span>, <span class="number">100px</span> <span class="number">200px</span>);</span><br><span class="line">shape-outside: <span class="built_in">polygon</span>(<span class="number">0</span> <span class="number">0</span>, <span class="number">100px</span> <span class="number">0</span>, <span class="number">0</span> <span class="number">50px</span>, <span class="number">100px</span> <span class="number">100px</span>, <span class="number">0</span> <span class="number">100px</span>);</span><br></pre></td></tr></table></figure>

<p>效果示意：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566041-c7797a0f-b382-4bee-ae26-5cd48b62f711.png#align=left&display=inline&height=214&originHeight=214&originWidth=309&size=0&status=done&style=none&width=309"><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566024-07bb1f4a-9389-480e-a912-76b7b66a72be.png#align=left&display=inline&height=232&originHeight=232&originWidth=307&size=0&status=done&style=none&width=307"><br />//zxx: Firefox浏览器内置了一个形状编辑器，你可以在 Inspector 中通过点击多边形可视化生成我们需要的<code>polygon()</code>坐标代码。</p>
<hr>
<p><strong>复盘汇总</strong><br />上面提到的所有shape函数都有demo可以体验，您可以狠狠地点击这里：<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/study/201901/css-shape-outside-function-demo.php">CSS shape-outside基本形状测试demo</a><br />红色的图形只是为了方便让大家知道形状是怎么样子的，实际开发的时候可以直接省略，或者换成其他字符或者位图，如照片，风景画，插画等。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566027-fb707c35-1041-4b15-8e99-6c9671d819fd.png#align=left&display=inline&height=304&originHeight=304&originWidth=421&size=0&status=done&style=none&width=421"><br><a name="cEqds"></a></p>
<h4 id="3-图像类"><a href="#3-图像类" class="headerlink" title="3. 图像类"></a>3. 图像类</h4><p>图像类只举URL和渐变的例子，因为这两种类型最常用。<br /><strong>URL不规则图形</strong><br />已知有个国家二级保护动物鹦鹉的PNG图形，如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566028-29f220a5-9edc-4682-a96a-ed7404e35ba6.png#align=left&display=inline&height=297&originHeight=297&originWidth=181&size=0&status=done&style=none&width=181"><br />如下CSS代码，就可以实现文字环绕这个鹦鹉轮廓布局效果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.shape</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="comment">/* 文字环绕这个鹦鹉 */</span></span><br><span class="line">    shape-outside: <span class="built_in">url</span>(<span class="string">./birds.png</span>);</span><br><span class="line">    <span class="comment">/* 鹦鹉赋色并显示 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#cd0000</span>;</span><br><span class="line">    -webkit-<span class="attribute">mask</span>: <span class="built_in">url</span>(<span class="string">./birds.png</span>) no-repeat;</span><br><span class="line">    <span class="attribute">mask</span>: <span class="built_in">url</span>(<span class="string">./birds.png</span>) no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的效果如下截图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566131-cb71e59b-b41b-451a-9376-e717b1e32514.png#align=left&display=inline&height=391&originHeight=391&originWidth=487&size=0&status=done&style=none&width=487"><br />这个效果有专门的demo页面的，您可以狠狠的点击这里：<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/study/201901/css-shape-outside-url-image-demo.php">CSS shape-outside PNG图片环绕demo</a><br /><strong>注意：</strong><code>url()</code>链接的图片尺寸无法修改；<code>url()</code>链接的图片不能跨域，否则会没有效果，因为没有兼容CORS，打开浏览器控制台，会看到类似下图的报错效果：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566033-07e5477b-926b-45bb-b3a8-222fab9b0ab1.png#align=left&display=inline&height=157&originHeight=157&originWidth=456&size=0&status=done&style=none&width=456"><br />此时需要在服务器侧，或者CDN那里配置’Access-Control-Allow-Origin’头包含当前页面的域名。<br /><strong>gradient渐变与环绕</strong><br />这里的渐变可以是<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/?p=3639">线性渐变</a>也可以是<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2017/11/css3-radial-gradient-syntax-example/">径向渐变</a>，以及repeat渐变。<br />例如绘制斜向线性渐变，CSS如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.shape</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>; <span class="attribute">height</span>: <span class="number">120px</span>;</span><br><span class="line">    --gradient: <span class="built_in">linear-gradient</span>(to right bottom, <span class="number">#cd0000</span>, transparent <span class="number">50%</span>, transparent <span class="number">90%</span>, <span class="number">#cd0000</span>);</span><br><span class="line">    shape-outside: <span class="built_in">var</span>(--gradient);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--gradient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/186051/1578413566178-ce3a6734-685a-4805-b459-dbe5244f3b49.png#align=left&display=inline&height=241&originHeight=241&originWidth=381&size=0&status=done&style=none&width=381"><br />Shape布局中有个CSS属性名为<code>[shape-image-threshold](https://www.zhangxinxu.com/wordpress/2019/02/css-css3-shapes/#shape-image-threshold)</code>，可以指定文字环绕图像的边界透明度值。这个后面会介绍。<br><a name="shape-margin"></a></p>
<h3 id="三、了解shape-margin"><a href="#三、了解shape-margin" class="headerlink" title="三、了解shape-margin"></a>三、了解shape-margin</h3><p><code>shape-margin</code>很好理解，就是文字环绕图形时候，距离边界的位置，这个属性很有用。因为在Shape布局中，文字环绕有时候是无视<code>margin</code>属性的，想要撑开间距，多半还得用<code>shape-margin</code>属性。<br />用法示意：<br /></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 长度值 */</span></span><br><span class="line">shape-<span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">shape-<span class="attribute">margin</span>: <span class="number">20mm</span>;</span><br><span class="line"><span class="comment">/* 百分比值 */</span></span><br><span class="line">shape-<span class="attribute">margin</span>: <span class="number">60%</span>;</span><br></pre></td></tr></table></figure>

<p>虽然该属性包含了<code>margin</code>，但是行为表现和CSS的<code>margin</code>属性却有很大的差别。首先，<code>shape-margin</code>只支持1个值，<code>margin</code>则1~4个；然后<code>shape-margin</code>的有效数值范围是有限制的，从0到浮动元素的边界（此时布局效果表现如同普通浮动布局）。<br />拿小鹦鹉案例举例吧，不同<code>shape-margin</code>值的表现分别如下gif动图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1578413566049-da89211a-7d9a-4eba-8d1f-327352df4480.gif#align=left&display=inline&height=380&originHeight=380&originWidth=437&size=0&status=done&style=none&width=437"><br />可以看到，当<code>shape-margin</code>的值超过一定的数量的时候（超过了浮动元素的盒子的边界），此时，看不到任何的变化了，也就是，<code>shape-margin</code>只能控制不规则环绕的间距。<br />您可以狠狠地点击这里：<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/study/201901/css-shape-margin-demo.php">CSS shape-margin测试demo</a><br><a name="shape-image-threshold"></a></p>
<h3 id="四、了解shape-image-threshold"><a href="#四、了解shape-image-threshold" class="headerlink" title="四、了解shape-image-threshold"></a>四、了解shape-image-threshold</h3><p>threshold这个单词是“阈(yu)值”的意思，<code>shape-image-threshold</code>指图像环绕时候的半透明阈值，默认是<code>0.0</code>，也就是图像透明度为<code>0</code>的区域边界才能环绕。同理，如果值是<code>0.5</code>表示透明度小于0.5的区域都可以文字环绕。<br />这个属性也非常实用，也很好理解，例如，我们写一个实色到透明的倾斜线性渐变，则从0~1的透明度都覆盖到了，此时，不同的<code>shape-image-threshold</code>值则会产生不同的布局变化，如下GIF图示意：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1578413566076-947da95b-54f9-4693-ac11-c7e5aeae6be3.gif#align=left&display=inline&height=340&originHeight=340&originWidth=412&size=0&status=done&style=none&width=412"><br />分别展示了如下阈值的环绕表现：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shape-image-threshold: <span class="number">0.0</span>;</span><br><span class="line">shape-image-threshold: <span class="number">0.3</span>;</span><br><span class="line">shape-image-threshold: <span class="number">0.6</span>;</span><br><span class="line">shape-image-threshold: <span class="number">0.8</span>;</span><br></pre></td></tr></table></figure>

<p>眼见为实，您可以狠狠地点击这里：<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/study/201901/css-shape-image-threshold-demo.php">CSS不同shape-image-threshold值测试demo</a><br><a name="0jwvd"></a></p>
<h3 id="五、案例：iPhone-X刘海头"><a href="#五、案例：iPhone-X刘海头" class="headerlink" title="五、案例：iPhone X刘海头"></a>五、案例：iPhone X刘海头</h3><p>实现环绕iPhone X刘海头的效果：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/186051/1578413566081-350a2504-57dc-4775-af19-14ed398f7957.gif#align=left&display=inline&height=491&originHeight=491&originWidth=302&size=0&status=done&style=none&width=302"><br />这是我2年前的iPhone X刚出来实现介绍的布局实现，就是借助CSS Shapes布局，详细实现参见这篇文章：“<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2017/09/css-shapes-outside-iphone-x-head/">借助CSS Shapes实现元素滚动环绕iPhone X的刘海</a>”。<br />这里不赘述。<br><a name="7BYza"></a></p>
<h3 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h3><p>至此，CSS3 几大布局全部介绍完毕了，分别是Flex布局，Grid布局，Columns布局，以及本文的Shapes布局，至于CSS Regions布局，看趋势，浏览器应该放弃支持了，因此，忽略，不做介绍。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/">写给自己看的display: flex布局教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/">写给自己看的display: grid布局教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2019/01/css-css3-columns-layout/">写给自己看的CSS columns分栏布局教程</a></li>
</ul>
<p>本文虽然有些篇幅，但是比Grid布局学起来要轻松多了。<br />感谢阅读，欢迎交流！<br /><img src="https://cdn.nlark.com/yuque/0/2020/svg/186051/1578413566093-20d47d86-6504-4282-9b49-0f4183e40542.svg#align=left&display=inline&height=20&originHeight=36&originWidth=36&size=0&status=done&style=none&width=20"><br />本文为原创文章，会经常更新知识点以及修正一些错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验。<br />本文地址：<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/?p=8453">https://www.zhangxinxu.com/wordpress/?p=8453</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/08/191-%E3%80%90CSS%E3%80%91%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9C%8B%E7%9A%84shapes%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B/" data-id="ckts3ejyh00mn4d9kdhoq9f0u" data-title="191-【CSS】写给自己看的shapes布局教程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-190-【总结】2019全年总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/04/190-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%912019%E5%85%A8%E5%B9%B4%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2020-01-04T05:26:21.000Z" itemprop="datePublished">2020-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/04/190-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%912019%E5%85%A8%E5%B9%B4%E6%80%BB%E7%BB%93/">190-【总结】2019全年总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <img width="600px" src="https://blog.pingan8787.com/EveryYear/2019Summary/leo2019.JPG" />

<p>回顾这一年，几句总结：</p>
<blockquote>
<p>再忙也要留点学习进步的时间；<br>再小的事，都是未来的基石；</p>
</blockquote>
<h2 id="零、与人为善"><a href="#零、与人为善" class="headerlink" title="零、与人为善"></a>零、与人为善</h2><h2 id="一、2019-计划完成情况"><a href="#一、2019-计划完成情况" class="headerlink" title="一、2019 计划完成情况"></a>一、2019 计划完成情况</h2><p>每年总结，写到回顾去年计划完成情况，各种事情便仿佛在眼前一闪而过。翻起去年<a target="_blank" rel="noopener" href="http://pingan8787.com/2019/01/12/130-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%912019%E5%85%A8%E5%B9%B4%E8%AE%A1%E5%88%92/">《130-【总结】2019全年计划》</a>，隐约闻到时间的味道，还有太阳的味道，不知你们会不会这样觉得。</p>
<p>先放几张这一年的代码 push 记录，累加起来接近一整年啦：</p>
<ul>
<li><strong>Github</strong>：</li>
</ul>
<img width="800px" src="https://blog.pingan8787.com/EveryYear/2019Summary/github.png" />

<ul>
<li><strong>Gitlab</strong>：</li>
</ul>
<img width="800px" src="https://blog.pingan8787.com/EveryYear/2019Summary/gitlab.png" />

<ul>
<li><strong>Gitee</strong>：</li>
</ul>
<img width="800px" src="https://blog.pingan8787.com/EveryYear/2019Summary/gitee.png" />


<h3 id="1-回顾学习规划"><a href="#1-回顾学习规划" class="headerlink" title="1. 回顾学习规划"></a>1. 回顾学习规划</h3><p>回顾今年学习规划，学习的知识范围更集中了，也做到知识沉淀，将沉淀的知识转化为自己的文章，并同步到各个前端技术社区、<a href="htt://www.pingan8787.com">博客</a>和<a target="_blank" rel="noopener" href="https://www.yuque.com/wangpingan/cute-frontend">语雀</a>上。</p>
<p>下面将几部分内容分别总结下：</p>
<ul>
<li><strong>前端知识</strong></li>
</ul>
<p>前端基础知识，整理了包括 JavaScript / ECAMScript / TypeScript / HTTP / 数据结构与算法 / 正则表达式 / Hybrid / 设计模式 等一系列基础入门知识的文章。</p>
<p>前端框架知识，整理了包括 Webpack / Angular / GraphQL / React / MobX 几个框架的基础入门知识的文章。</p>
<p>今年也学习很多其他知识，包括 JSBridge / 前端原生端交互 / ionic-native 原理 / Auto2 / CSRF和CORS / Restful等等等等。</p>
<p>很多已经汇总在<a target="_blank" rel="noopener" href="https://www.yuque.com/wangpingan/cute-frontend">《Cute-Frontend》</a>中。</p>
<ul>
<li><strong>后端知识</strong></li>
</ul>
<p>学习 Eggjs + Mongodb + Redis ，并开发团队内部项目网盘项目，说真的也是学习了很多后端开发的思维。<br>另外今年也有使用 Nodejs 写了几个简单工具，如：Fiddler 请求接口时间统计工具 / Excel 公众号数据清洗工具。</p>
<ul>
<li><strong>个人品牌</strong></li>
</ul>
<p>公众号【前端自习课】：今年满勤，截止今天已经连续推送 461 篇（含删除/未获得白名单的转载/发重复），粉丝数涨了约 11 倍（从2019/7/24开始），阅读量稳定 160+（自然）。</p>
<p>个人博客：将自己在其他社区发的文章都同步到博客，原创文章 57 篇，未达标。</p>
<p>其他社区：今年推送的文章分享的平台包括：<a target="_blank" rel="noopener" href="https://juejin.im/user/586fc337a22b9d0058807d53/posts">掘金</a>、<a target="_blank" rel="noopener" href="https://segmentfault.com/blog/pingan8787">思否</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/cute-javascript">知乎</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36380426">CSDN</a>、<a target="_blank" rel="noopener" href="https://www.yuque.com/wangpingan/cute-frontend">语雀</a>、<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/2ec5d94afd60">简书</a>、<a target="_blank" rel="noopener" href="https://www.imooc.com/u/3591250/articles">慕课手记</a>还有自己<a target="_blank" rel="noopener" href="http://www.pingan8787.com/">博客</a>和 <a target="_blank" rel="noopener" href="https://github.com/pingan8787">github</a>。掘金粉丝 4429 未达标，点赞数 8862 也未达标。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">Github Reading</a>：今年满勤，截止这个月已经连续打卡 30 个月了。</p>
<h3 id="2-回顾工作规划"><a href="#2-回顾工作规划" class="headerlink" title="2. 回顾工作规划"></a>2. 回顾工作规划</h3><p>工作上，对于迭代需求任务，已经养成开发前核对需求，提测前核对UI稿和原型稿这样的习惯，几次迭代任务实现 0 BUG。</p>
<p>这一年也向团队前端学习了很多，为人处世，工作方式，工作技能等等。对于公司产品，今年积极参与各种运营活动（学习打卡、点赞活动、学习任务等），也发表一些自己对产品的看法，两个专栏号持续输出中。</p>
<h3 id="3-回顾生活规划"><a href="#3-回顾生活规划" class="headerlink" title="3. 回顾生活规划"></a>3. 回顾生活规划</h3><p>生活的规划中，2019年，熬夜少了很多，基本12点准时关电脑睡觉，除了自己喜欢的球赛啦~</p>
<p>锻炼这方面也是陆陆续续，唯一做得好的可能就是坚持自己做早饭，牛奶燕麦，白米粥，绿豆粥，燕麦粥，烤面包，煎蛋，水煮蛋，培根鸡蛋堡，今年的早餐都是这些，也比较清淡。</p>
<p>宿舍没换，不过住得舒适呀，另外独自去了很多地方，骑行 1100+ 公里：</p>
<img width="200px" src="https://blog.pingan8787.com/EveryYear/2019Summary/bicycle.jpg" />

<p>达成厦门岛换到骑行🚴的个人记录：</p>
<img width="400px" src="https://blog.pingan8787.com/EveryYear/2019Summary/xiamendao.JPG" />


<h2 id="二、2019-总结和分析"><a href="#二、2019-总结和分析" class="headerlink" title="二、2019 总结和分析"></a>二、2019 总结和分析</h2><p>老套路，继续按照每个类型选一件事情来说：</p>
<h3 id="2019-最正确的一件事"><a href="#2019-最正确的一件事" class="headerlink" title="2019 最正确的一件事"></a>2019 最正确的一件事</h3><p>回顾这一整年，发生的事情真的很多，做得正确的事情也很多，从对于职业生涯和自身性格出发，我觉得2019我做得最正确的一件事是<strong>12月份去杭州参加语雀知识大会</strong>，我也总结一篇<a target="_blank" rel="noopener" href="https://www.yuque.com/wangpingan/cute-frontend/uf68aa">《北上 寻“雀”》</a>。</p>
<p>这趟三天旅行，是我独自一人制定所有行程和计划，我逛了阿里巴巴、支付宝、蚂蚁金服、湖畔花园这些互联网传奇的地方，也去了西湖、雷峰塔、钱塘江大桥、京杭大运河、浙江大学、黄龙洞等等。</p>
<p>也面基玉伯大佬，并拿到签名与合影，😄哈哈。</p>
<img width="300px" src="https://blog.pingan8787.com/EveryYear/2019Summary/i_and_yubo.JPG" />

<p>这次行程，很大程度拓展我的视野，一些只在互联网上存在的庞然大物，原来也是离我这么近的，并且今年有一次蚂蚁金服的面试，虽然挂了，还是自身本领不够。</p>
<p>很多时候，人的眼界格局一下子产生变换，很多失败，我都将之视为经验，未来，再来。</p>
<h3 id="2019-最错误的一件事"><a href="#2019-最错误的一件事" class="headerlink" title="2019 最错误的一件事"></a>2019 最错误的一件事</h3><p>这应该算是那次顶撞母亲的事情，被催相亲催到发脾气，顶撞母亲，实在惭愧惭愧，虽然已经和母亲交谈，但心里还是挺惭愧。</p>
<h3 id="2019-最开心的一件事"><a href="#2019-最开心的一件事" class="headerlink" title="2019 最开心的一件事"></a>2019 最开心的一件事</h3><p>当然属于公众号【前端自习课】，全年满勤，截止今天已经连续推送 461 篇（含删除/未获得白名单的转载/发重复），粉丝数涨了约 11 倍（从2019/7/24开始），阅读量稳定 160+（自然）。</p>
<p>公众号的初衷，是想<strong>看看自己能坚持做这件事情做多久</strong>，后面发现，做这个事情特别有意义，对我对他人都是。</p>
<p>对我而已，是自己学习的素材库，坚持的动力，也是和圈子交流的话题。</p>
<p>对他人而言，这也许是他们发现宝藏的时刻。</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://cu2019.newrank.cn/h5.html?n=5903fb7">【前端自习课】的2019</a></strong></li>
</ul>
<p>2019.07.24 开始正式向外部宣传，至今收获 2300+ 粉丝，一个 100+ 人微信群。</p>
<p>累计 3W 阅读量，693 个在看，362 天发布， 404 篇文章， 89 篇原创， 267W 字 …</p>
<p><img src="https://blog.pingan8787.com/EveryYear/2019Summary/fe-study01.png" alt="fe-study01.png"></p>
<p>另外今年也将为【前端自习课】开发了<a target="_blank" rel="noopener" href="https://blog.pingan8787.com/weixin/index.html">文章分类大全，点击链接即可体验</a>，另外也有小程序，只是小程序有现在无法打开公众号文章。</p>
<h2 id="三、思考自省"><a href="#三、思考自省" class="headerlink" title="三、思考自省"></a>三、思考自省</h2><p>21世纪20年代已经开始。   </p>
<p>总结过往 10 年，人生两大事情改变了我，人的生老病死，爱情的现实。   </p>
<p>既然遇到了，那我就积极、勇敢面对，去改变。   </p>
<p>这 10 年，从一个娇生惯养的小孩，到一心只有这个家的年轻人，双手不再稚嫩，双肩不再轻荡。   </p>
<p>努力做好自己，强大自己，去学习，去进步。  </p>
<p>这 10 年，我尽力了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/04/190-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%912019%E5%85%A8%E5%B9%B4%E6%80%BB%E7%BB%93/" data-id="ckts3ejtz00594d9k9s5d7oy2" data-title="190-【总结】2019全年总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-189-【微前端】每日优鲜供应链前端团队微前端改造" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/12/24/189-%E3%80%90%E5%BE%AE%E5%89%8D%E7%AB%AF%E3%80%91%E6%AF%8F%E6%97%A5%E4%BC%98%E9%B2%9C%E4%BE%9B%E5%BA%94%E9%93%BE%E5%89%8D%E7%AB%AF%E5%9B%A2%E9%98%9F%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%94%B9%E9%80%A0/" class="article-date">
  <time class="dt-published" datetime="2019-12-24T14:08:53.000Z" itemprop="datePublished">2019-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/12/24/189-%E3%80%90%E5%BE%AE%E5%89%8D%E7%AB%AF%E3%80%91%E6%AF%8F%E6%97%A5%E4%BC%98%E9%B2%9C%E4%BE%9B%E5%BA%94%E9%93%BE%E5%89%8D%E7%AB%AF%E5%9B%A2%E9%98%9F%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%94%B9%E9%80%A0/">189-【微前端】每日优鲜供应链前端团队微前端改造</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="【微前端】7-每日优鲜供应链前端团队微前端改造"><a href="#【微前端】7-每日优鲜供应链前端团队微前端改造" class="headerlink" title="【微前端】7- 每日优鲜供应链前端团队微前端改造"></a>【微前端】7- 每日优鲜供应链前端团队微前端改造</h1><p>文 掘金号 Terry豆 @每日优鲜</p>
<blockquote>
<p>著作权归作者所有。商业转载请联系本账号获得授权，非商业转载请注明每日优鲜大前端团队以及原文地址。</p>
</blockquote>
<p><a name="tKl2V"></a></p>
<h2 id="一、需求以及成果"><a href="#一、需求以及成果" class="headerlink" title="一、需求以及成果"></a>一、需求以及成果</h2><p>我所在团队是做toB业务的，技术栈是Vue，团队目前有十多个典型的toB业务（菜单+内容布局），这些业务都是服务于一个大平台的，因为历史原因，每个业务都是独立的，都有一个html入口，所以当用户在这个大平台上使用这十多个业务的时候，每当切换系统时，页面都会刷新，体验很差；在开发层面，这十多个业务又有太多共同之处，每次修改成本都很高。<br />最近有一个很重要的需求X，内容是这样的：从十多个项目中，每个项目抽取若干功能组成一个新项目，基于现有架构的话，每当点击来自不同系统的功能页面就要刷新一次，这是不可接受的。为了新需求X重复开发一遍这些业务功能又不现实，所以从技术角度来看，架构改造不可避免。<br />经过一番调研比对，我们决定使用当下比较火的 <a target="_blank" rel="noopener" href="https://single-spa.js.org/">SingleSpa</a> 来完成改造（iframe方案尝试过，不太适合我们的场景），目前改造已完成，我们实现了以下效果：</p>
<ul>
<li>只有一个不包含子项目（子项目指的是那十多个业务）资源的主项目，主项目只有一个html入口，子项目通过主项目来按需加载，子系统间切换不再刷新；</li>
<li>菜单栏、登录、退出等功能都从子项目剥离，写在主项目里，再有相关改动只需修改主项目，包括错误监控、埋点等行为，只需处理一个主项目，十几个子项目不再需要处理；</li>
<li>子项目原本需要加载的公共部分（如vue、vuex、vue-router、ivew/element、私有npm包等），全部由主项目调度，配合webpack的externals功能通过外链的方式按需加载，一旦有一个子项目加载过，下一个子项目就不需要再加载，这样一来每个子项目的dist文件里就只有子项目自己的业务代码（最终子项目包的体积缩小了80%，只有几十k），项目实际加载速度快了很多，肉眼可见；</li>
<li>子项目并没有重新开发，只是进行了一些改造，接入了微前端这套架构，所以新需求X的开发成本也极大的降低了，接入功能同时可供未来新增子项目使用；</li>
<li>我们的项目有自己的tab系统（类似浏览器的tab页签），这些tab页签通过keep-alive和一系列对缓存的处理，使其体验接近原生浏览器tab。<br><a name="yyJnt"></a><h2 id="二、展示以及技术点"><a href="#二、展示以及技术点" class="headerlink" title="二、展示以及技术点"></a>二、展示以及技术点</h2><a name="SUszb"></a><h3 id="图1：项目外观示意图："><a href="#图1：项目外观示意图：" class="headerlink" title="图1：项目外观示意图："></a>图1：项目外观示意图：</h3><img src="https://cdn.nlark.com/yuque/0/2019/webp/186051/1577196362755-932ee761-e270-4353-9768-cdb53ea60e6f.webp#align=left&display=inline&height=855&originHeight=855&originWidth=1280&size=0&status=done&style=none&width=1280"><blockquote>
<p>做微前端改造之前，蓝色系区域都是用公共包的方式由每个子项目引入，所以子项目运行的时候展示的蓝色系部分都是相同的，给人一种在使用同一个系统的错觉，实际上切换系统的时候整个页面都要重新载入。</p>
</blockquote>
</li>
</ul>
<p>微前端改造后，只有橘红色区域是变化的，页面也不再刷新。<br><a name="B8mXG"></a></p>
<h3 id="图2：局部效果动图"><a href="#图2：局部效果动图" class="headerlink" title="图2：局部效果动图"></a>图2：局部效果动图</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/gif/186051/1577196362769-fe0a2f98-a877-4838-8ec7-79a5ede828b3.gif#align=left&display=inline&height=705&originHeight=705&originWidth=1215&size=0&status=done&style=none&width=1215"></p>
<blockquote>
<p>图2展示了图1中的tab页签区以及子项目展示区。信息做了马赛克处理。</p>
</blockquote>
<p>乍一看没什么特别的，但如果我说这些tab<strong>分别来自于不同git仓库的独立vue项目</strong>呢？<br />这就是这套微前端架构的强大之处，让<strong>不同单页vue项目可以随意组合成一个项目，而这些项目自己又是独立的vue项目</strong>。</p>
<blockquote>
<p>仔细看图2中路由的变化，<strong>hash路由的第一级</strong>决定了要加载哪个子项目（work、sms、tms是三个不同的git工程），不同子项目间的切换也完全没有刷新😁<br>为了让tab切换不刷新，这里使用了keep-alive去缓存页面，考虑到内存性能，在关闭tab页签时通过一些方法(主要是keep-alive的exclude属性)去除了keep-alive缓存，同时为了让子项目间的tab切换也不刷新，对图3下面提到的包装器也进行了不小的改造。让tab切换不刷新只是为了提升用户体验，这一步不是必要的，有一定的成本。</p>
</blockquote>
<p><a name="htxsA"></a></p>
<h3 id="图3：部署架构示意图"><a href="#图3：部署架构示意图" class="headerlink" title="图3：部署架构示意图"></a>图3：部署架构示意图</h3><p>实现一套微前端架构，可以把其分成四部分（参考：<a target="_blank" rel="noopener" href="https://alili.tech/archive/11052bf4/">alili.tech/archive/110…</a> ）</p>
<ul>
<li>加载器：也就是微前端架构的核心，图3中的“加载器JS文件”就是由加载器打包压缩出来的，这是原始的加载器：<a target="_blank" rel="noopener" href="https://github.com/Fantasy9527/lotus-scaffold-micro-frontend-portal">github.com/Fantasy9527…</a> —— <strong>可以把它理解成电源</strong></li>
<li>包装器：有了加载器，我们要把现有的vue项目包装一下，使得加载器可以使用它们，这是原始的包装器：<a target="_blank" rel="noopener" href="https://github.com/CanopyTax/single-spa-vue">github.com/CanopyTax/s…</a> ——  <strong>如果想改造，建议改造这个部分，它相当于电源适配器</strong></li>
<li>主项目：一般是包含所有项目公共部分的项目—— <strong>它相当于电器底座</strong></li>
<li>子项目：众多展示在主项目内容区的项目—— <strong>它相当于你要使用的电器</strong></li>
</ul>
<p>所以是这么个概念：<strong>电源(加载器)→电源适配器(包装器)→️电器底座(主项目)→️电器(子项目)️</strong></p>
<blockquote>
<p>主项目和子项目都需要用包装器包装，只不过主项目的配置写法有不同<br>加载器和包装器需要根据自己的需求做一些二次开发</p>
</blockquote>
<p><strong>总的来说是这样一个流程：用户访问index.html后，浏览器运行加载器的js文件，加载器去读取图4中的配置文件，然后注册配置文件中配置的各个项目后，首先加载主项目(菜单等)，再通过路由判定，动态远程加载子项目。</strong><br />这里有个<a target="_blank" rel="noopener" href="https://github.com/joeldenning/coexisting-vue-microfrontends">vue微前端版demo</a>，包含最基础的<strong>效果与源码</strong>，务必研究一下这个demo再结合以上理论来帮助理解<br />*远程加载的子项目资源要在chrome的network中的xhr那一栏才能看到<br><a name="rgOXs"></a></p>
<h3 id="图4：图3中的apps-config-js"><a href="#图4：图3中的apps-config-js" class="headerlink" title="图4：图3中的apps.config.js"></a>图4：图3中的apps.config.js</h3><p>用户访问index.html后，js加载器会加载apps.config.js。<br />无论路由是什么，每次必会首先加载主项目，再根据路由来匹配要加载哪个子项目。<br />apps.config.js的生成如图3的绿色部分所示:</p>
<blockquote>
<p>在资源服务器上起一个监听服务(我使用的是nodejs脚本+pm2守护)，原有子项目的部署方式完全不变(前后端完全分离，资源带hash)，当监听服务检测到文件改动时，去子项目部署文件夹里找它的index.html，把入口js用如下正则匹配出来，写入apps.config.js。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// content[i]为子项目文件夹名称。这段代码是nodejs脚本片段。</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`src=&quot;\(\\/<span class="subst">$&#123;content[i]&#125;</span>\\/index\\.\\w&#123;8&#125;.js\)`</span>) <span class="comment">// 对应图中的 /brain/index.3c4b55cf.js</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<blockquote>
<p>图4中的brain即是主项目，它的base属性为true，其余子项目的base属性为false</p>
</blockquote>
<p><a name="H2Rhy"></a></p>
<h2 id="三、一些技术细节"><a href="#三、一些技术细节" class="headerlink" title="三、一些技术细节"></a>三、一些技术细节</h2><p>这里说的的项目打包都是基于webpack。<br><a name="4lc1Y"></a></p>
<h3 id="System-js"><a href="#System-js" class="headerlink" title="System.js"></a>System.js</h3><p>它是实现远程加载子项目的核心。<br />我们使用的是0.21版本的：<a target="_blank" rel="noopener" href="https://github.com/systemjs/systemjs/tree/0.21">github.com/systemjs/sy…</a><br />因为要动态通过http引入外部js，又不影响在开发的时候使用import、require方法，所以找到了systemjs来做这件事。<br />根据systemjs文档说明，我们只需要把子项目打成umd格式(umd糅合了AMD和CommonJS)的包即可动态外部加载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个子项目的webpack.config.js</span></span><br><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: xxx,</span><br><span class="line">    <span class="attr">publicPath</span>: xxx,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span>,</span><br><span class="line">    <span class="attr">chunkFilename</span>: <span class="string">&#x27;js/[name].[chunkhash:8].chunk.js&#x27;</span>,</span><br><span class="line">    <span class="attr">libraryTarget</span>: <span class="string">&#x27;umd&#x27;</span>, <span class="comment">// 这里一定要写成umd，不然打出来的包system.js无法读取</span></span><br><span class="line">    <span class="attr">library</span>: xxx, <span class="comment">//模块的名称</span></span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><a name="ZHCNo"></a></p>
<h3 id="Webpack-Externals"><a href="#Webpack-Externals" class="headerlink" title="Webpack Externals"></a>Webpack Externals</h3><p>文档：<a target="_blank" rel="noopener" href="https://www.webpackjs.com/configuration/externals/">www.webpackjs.com/configurati…</a><br />这么多同类型的vue项目，一定有大量的重复代码、重复引用，所以这是一块巨大的性能优化点，通过配置externals可以极大减小子项目打包出来的体积。<br />我并没有完全按照文档说明的方式来从CDN引入，原因是这样的：入口index.html只有一个，如果按文档来做，一次引入所有CDN资源，可能子项目A用得到这些，但子项目B用不到这些，而我只访问了子项目B而已，这样不就多加载了无用的资源吗？<br />经过一番调研，同样利用systemjs解决了这个问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个子项目自己的webpack.config.js，根据使用情况设置externals</span></span><br><span class="line"> <span class="attr">externals</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;axios&#x27;</span>: <span class="string">&#x27;axios&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;vue&#x27;</span>: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;vue-router&#x27;</span>: <span class="string">&#x27;VueRouter&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;vuex&#x27;</span>: <span class="string">&#x27;Vuex&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;iview&#x27;</span>: <span class="string">&#x27;iview&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;moment&#x27;</span>: <span class="string">&#x27;moment&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;echarts&#x27;</span>: <span class="string">&#x27;echarts&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;@mfb/pc-utils-micro&#x27;</span>:<span class="string">&#x27;@mfb/pc-utils-micro&#x27;</span>, <span class="comment">// 私有公共方法包</span></span><br><span class="line">      <span class="string">&#x27;@mfb/pc-components-micro&#x27;</span>:<span class="string">&#x27;@mfb/pc-components-micro&#x27;</span>, <span class="comment">// 私有公共组件包</span></span><br><span class="line">      <span class="comment">// &#x27;@mfb/pc-components-micro&#x27;:&#x27;@mfb/pc-components-micro-0.2.1&#x27;, // 如果需要指定版本,则用这一行替换上一行 </span></span><br><span class="line">      ...</span><br><span class="line">  &#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// index.html 整个微前端的唯一入口</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;system.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  SystemJS.config(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">map</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;Vue&quot;</span>: <span class="string">&quot;//xxx.cdn.cn/static/vue/2.5.17/vue.min.js&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;vue&quot;</span>: <span class="string">&quot;//xxx.cdn.cn/static/vue/2.5.17/vue.min.js&quot;</span>, <span class="comment">// 因为iview前置需要vue，是小写的，就又声明了一次</span></span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;Vuex&quot;</span>: <span class="string">&quot;//xxx.cdn.cn/static/vuex/3.0.1/vuex.min.js&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;VueRouter&quot;</span>: <span class="string">&quot;//xxx.cdn.cn/static/vueRouter/3.0.1/vue-router.min.js&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;iview&quot;</span>: <span class="string">&quot;//xxx.cdn.cn/static/iview/3.3.2/iview.min.js&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;moment&quot;</span>: <span class="string">&quot;//xxx.cdn.cn/static/moment/2.22.2/moment.min.js&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;axios&quot;</span>: <span class="string">&quot;//xxx.cdn.cn/static/axios/0.15.3/axios.min.js&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;echarts&quot;</span>: <span class="string">&quot;//xxx.cdn.cn/static/echarts/4.2.1/echarts.min.js&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;@mfb/pc-utils-micro&quot;</span>: <span class="string">&quot;//xxx.cdn.cn/static/mfb-pc-utils-micro/mfb-pc-utils-micro-0.0.6.js&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;@mfb/pc-components-micro&quot;</span>: <span class="string">&quot;//xxx.cdn.cn/static/mfb-pc-components-micro/mfb-pc-components-micro-0.0.42.js&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;@mfb/pc-components-micro-0.2.1&quot;</span>: <span class="string">&quot;//xxx.cdn.cn/static/mfb-pc-components-micro/mfb-pc-components-micro-0.2.1.js&quot;</span> <span class="comment">// 如果需要指定版本</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>如此一来，systemjs只是在加载index.html时注册了这些CDN地址，不会直接去加载，当子项目里用到的时候，systemjs会接管模块引入，systemjs会去上面注册的map中查找匹配的模块，就再动态去加载资源。这样就避免了不同子项目在这套架构下产生的多余加载。</p>
<blockquote>
<p>按我们的配置，webpack打包后，externals配置的模块不会打包进bundle，会被摘出来按umd规范通过requre/define方式去加载。<br>看systemjs源码会发现它重新定义了require和define方法，所以它能接管externals的外部引入过程。</p>
</blockquote>
<p><a name="uloS1"></a></p>
<h2 id="四、总结体会"><a href="#四、总结体会" class="headerlink" title="四、总结体会"></a>四、总结体会</h2><p><em>我最直白的感受是实现了项目级别的模块化，把不同项目变成了一个个模块来拼装组合，也就是说模块化从项目内提升到了项目本身</em><br /><strong>总结一下使用这套架构收到的好处，分为以下几点：</strong></p>
<ul>
<li>缩小项目打包体积(平均每个子项目bundle不到100k)，而整合后的公共资源只需加载一次，性能得到很大提升 (技术角度)</li>
<li>用户体验更好，用户感知不到自己在使用多个不同的项目，更加平顺流畅 (产品角度)</li>
<li>不同git的项目经过改造后，可以随意以项目内每个路由页面为单元拼装成一个新项目，产品灵活性本质上得到提升 (产品/技术角度)</li>
<li>技术尝新，使用业界比较先进的微前端理念，几十个项目，成千上百个功能也能很好的分模块管理。 (管理角度)</li>
</ul>
<p><strong>也是有很多麻烦之处，需要消耗一定成本：</strong></p>
<ul>
<li>因为多个vue实例在同一个document里，需要避免全局变量污染、全局监听污染、样式污染等，需要制定接入规范。</li>
<li>使用了external抽离公共模块(比如Vue、Vue-router等)后，构造函数(或者Class)的污染也需要避免，比如Vue.mixin、Vue.components、Vue<br>.use等等都需要做一些额外的工作去避免它们产生冲突。</li>
<li>如果你也想要tab切换不刷新(使用keep-alive)，那需要做的工作更多，主要是处理缓存，防止堆内存溢出（用chrome自带的performance monitor查看），还有项目间切换时路由钩子等等的处理。</li>
</ul>
<p>不过跟收益比起来，这些成本就不算什么了~<br />最后要说一下，<strong>并不是所有场景都适合微前端</strong>，尤其是项目规模小、数量少的场景不建议使用。<br />什么样的<strong>场景</strong>适合这套架构呢？一般有以下特征：</p>
<ul>
<li>项目很<strong>多</strong>，规模很<strong>大</strong>，都是每个项目<strong>独立使用</strong>git此类仓库维护的、技术栈为vue/react/angular的这类应用</li>
<li>需要整合到统一平台上，你正在寻找<strong>可能比iframe更合适</strong>的替代方案</li>
<li>项目A有功能A1、A2、A3,项目B有功能B1、B2、B3，产品经理要你把A2、B1、B3组合成一个<strong>包含这些功能的新项目</strong></li>
</ul>
<p><strong>可能你会问：为什么不一开始就把所有需要整合的功能用一个git来维护？</strong><br />答：理想是美好的，谁也没有先知能力，随着公司业务发展亦或是组织架构的改变、人员更迭，以上场景是几乎不可避免的；我很难想象十多个项目的好几百个功能都在一个git里管理起来有多困难。<br /><strong>可能你还会问，那我把需要整合的业务整合成到一个git仓库呢？</strong><br />答：这当然是一个解决办法，前提是整合的成本你能接受；并且将来还有这类需求呢？每次都要手动整合业务代码到同一个git仓库吗？假设所有人都只维护这个整合完的git仓库，并行的需求线多了，上线时间会不会拥挤？一个功能产生了致命错误，会不会所有功能跟着出问题？<br />最后我想说：<br /><em><strong>我们做这套框架的初衷是解决眼前的问题，然而发现它附带的潜力价值却比想象的多得多。</strong></em></p>
<p>作者：每日优鲜大前端团队<br />链接：<a target="_blank" rel="noopener" href="https://juejin.im/post/5d7f702ce51d4561f777e258">https://juejin.im/post/5d7f702ce51d4561f777e258</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/12/24/189-%E3%80%90%E5%BE%AE%E5%89%8D%E7%AB%AF%E3%80%91%E6%AF%8F%E6%97%A5%E4%BC%98%E9%B2%9C%E4%BE%9B%E5%BA%94%E9%93%BE%E5%89%8D%E7%AB%AF%E5%9B%A2%E9%98%9F%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%94%B9%E9%80%A0/" data-id="ckts3ejty00544d9k5zoh9geg" data-title="189-【微前端】每日优鲜供应链前端团队微前端改造" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" rel="tag">微前端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-188-【前端知乎系列】File和FileList和FileReader对象详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/12/18/188-%E3%80%90%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97%E3%80%91File%E5%92%8CFileList%E5%92%8CFileReader%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2019-12-18T15:48:33.000Z" itemprop="datePublished">2019-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/12/18/188-%E3%80%90%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97%E3%80%91File%E5%92%8CFileList%E5%92%8CFileReader%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/">188-【前端知乎系列】File和FileList和FileReader对象详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="http://images.pingan8787.com/blog/File_FileList_FileReader%E5%B0%81%E9%9D%A2%E5%9B%BE.png" alt="File_FileList_FileReader封面图.png"></p>
<blockquote>
<p>本文首发在我的【<a target="_blank" rel="noopener" href="http://www.pingan8787.com/">个人博客</a>】<br>更多丰富的前端学习资料，可以查看我的 <strong>Github</strong>: <a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo-JavaScript">《Leo-JavaScript》</a>，内容涵盖<strong>数据结构与算法</strong>、<strong>HTTP</strong>、<strong>Hybrid</strong>、<strong>面试题</strong>、<strong>React</strong>、<strong>Angular</strong>、<strong>TypeScript</strong>和<strong>Webpack</strong>等等。<br>点个 Star 不迷路~</p>
</blockquote>
<p>欢迎阅读《前端知乎系列》：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5df838e3e51d455830351a3c">《【前端知乎】443- ArrayBuffer 与 Blob 对象详解》</a></li>
</ul>
<p><img src="http://images.pingan8787.com/blog/%E5%89%8D%E7%AB%AF%E8%87%AA%E4%B9%A0%E8%AF%BE%E2%80%94%E2%80%94banner.png" alt="前端自习课——banner"></p>
<p><code>File</code> 对象、<code>FileList</code> 对象与 <code>FileReader</code> 对象大家或许不太陌生，常见于文件上传下载操作处理（如处理图片上传预览，读取文件内容，监控文件上传进度等问题）。</p>
<p>那么本文将与大家深入介绍两者。</p>
<h2 id="一、File-对象"><a href="#一、File-对象" class="headerlink" title="一、File 对象"></a>一、File 对象</h2><h3 id="1-概念介绍"><a href="#1-概念介绍" class="headerlink" title="1. 概念介绍"></a>1. 概念介绍</h3><p><code>File</code> 对象提供有关文件的信息，并允许网页中的 JavaScript 读写文件。</p>
<p>最常见的使用场合是表单的文件上传控件，用户在一个 <code>&lt;input type=&quot;file&quot;&gt;</code> 元素上选择文件后，浏览器会生成一个数组，里面是每一个用户选中的文件，它们都是 <code>File</code> 实例对象。</p>
<p>另外值得提到一点：<code>File</code> 对象是一种特殊 <code>Blob</code> 对象，并且可以用在任意的 <code>Blob</code> 对象的 <code>context</code> 中。比如说， <code>FileReader</code>, <code>URL.createObjectURL()</code>, <code>createImageBitmap()</code>, 及 <code>XMLHttpRequest.send()</code> 都能处理 <code>Blob</code> 和 <code>File</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input id=&quot;fileItem&quot; type=&quot;file&quot;&gt;</span></span><br><span class="line"><span class="keyword">const</span> file = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;fileItem&#x27;</span>).files[<span class="number">0</span>];</span><br><span class="line">file <span class="keyword">instanceof</span> File <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-对象使用"><a href="#2-对象使用" class="headerlink" title="2. 对象使用"></a>2. 对象使用</h3><p>浏览器原生提供一个 <code>File()</code> 构造函数，用来生成 <code>File</code> 实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFile = <span class="keyword">new</span> File(bits, name[, options]);</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>bits</code>：</li>
</ul>
<p>一个数组，表示文件的内容。成员可以是 <code>ArrayBuffer</code>，<code>ArrayBufferView</code>，<code>Blob</code>，或者 <code>DOMString </code>对象的 <code>Array</code>，或者任何这些对象的组合。</p>
<p>通过这个参数，也可以实现 <code>ArrayBuffer</code>，<code>ArrayBufferView</code>，<code>Blob</code> 转换为 <code>File</code> 对象。</p>
<ul>
<li><code>name</code>：</li>
</ul>
<p>字符串，表示文件名或文件路径。</p>
<ul>
<li><code>options</code>：</li>
</ul>
<p>配置对象，设置实例的属性。该参数可选。可选值有如下两种：</p>
<p><code>type</code>:  <code>DOMString</code>，表示将要放到文件中的内容的 MIME 类型。默认值为 <code>&quot;&quot;</code> 。<br><code>lastModified</code>:  数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 <code>Date.now()</code>。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFile = <span class="keyword">new</span> File([<span class="string">&#x27;leo1&#x27;</span>, <span class="string">&#x27;leo2&#x27;</span>], <span class="string">&#x27;leo.txt&#x27;</span>, &#123;<span class="attr">type</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>根据已有的 blob 对象创建 File 对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFile = <span class="keyword">new</span> File([blob], <span class="string">&#x27;leo.png&#x27;</span>, &#123;<span class="attr">type</span>: <span class="string">&#x27;image/png&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="3-实例属性和方法"><a href="#3-实例属性和方法" class="headerlink" title="3. 实例属性和方法"></a>3. 实例属性和方法</h3><h4 id="3-1-实例属性"><a href="#3-1-实例属性" class="headerlink" title="3.1 实例属性"></a>3.1 实例属性</h4><p>实例有以下几个属性：</p>
<ul>
<li><code>File.lastModified</code>：最后修改时间。只读</li>
</ul>
<p>自 UNIX 时间起始值（1970年1月1日 00:00:00 UTC）以来的毫秒数</p>
<ul>
<li><code>File.name</code>：文件名或文件路径。只读   </li>
</ul>
<p>出于安全考虑，返回值不包含文件路径 。</p>
<ul>
<li><code>File.size</code>：文件大小（单位字节）。只读   </li>
<li><code>File.type</code>：文件的 MIME 类型。只读   </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input id=&quot;fileItem&quot; type=&quot;file&quot;&gt;</span></span><br><span class="line"><span class="keyword">const</span> myFile = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;fileItem&#x27;</span>)</span><br><span class="line">myFile.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> file = <span class="built_in">this</span>.files[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(file.name);</span><br><span class="line">    <span class="built_in">console</span>.log(file.size);</span><br><span class="line">    <span class="built_in">console</span>.log(file.lastModified);</span><br><span class="line">    <span class="built_in">console</span>.log(file.lastModifiedDate);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-实例方法"><a href="#3-2-实例方法" class="headerlink" title="3.2 实例方法"></a>3.2 实例方法</h4><p><code>File</code> 对象没有定义任何方法，但是它从 Blob 接口继承了以下方法：</p>
<ul>
<li><code>Blob.slice([start[, end[, contentType]]])</code></li>
</ul>
<p>返回一个新的 <code>Blob</code> 对象，它包含有源 <code>Blob</code> 对象中指定范围内的数据。</p>
<h3 id="4-兼容性"><a href="#4-兼容性" class="headerlink" title="4. 兼容性"></a>4. 兼容性</h3><p><img src="http://images.pingan8787.com/blog/File%E5%AF%B9%E8%B1%A1%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt="File对象兼容性.png"></p>
<h2 id="二、FileList-对象"><a href="#二、FileList-对象" class="headerlink" title="二、FileList 对象"></a>二、FileList 对象</h2><h3 id="1-概念介绍-1"><a href="#1-概念介绍-1" class="headerlink" title="1. 概念介绍"></a>1. 概念介绍</h3><p><code>FileList</code> 对象是一个类数组对象，每个成员都是一个 <code>File</code> 实例，主要出现在两种场合：</p>
<ul>
<li>通过 <code>&lt;input type=&quot;file&quot;&gt;</code> 控件的 <code>files</code> 属性，返回一个 <code>FileList</code> 实例。</li>
</ul>
<p>另外，当 <code>input</code> 元素拥有 <code>multiple</code> 属性，则可以用它来选择多个文件。</p>
<ul>
<li>通过拖放文件，查看 <code>DataTransfer.files</code> 属性，返回一个 <code>FileList</code> 实例。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input id=&quot;fileItem&quot; type=&quot;file&quot;&gt;</span></span><br><span class="line"><span class="keyword">const</span> files = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;fileItem&#x27;</span>).files;</span><br><span class="line">files <span class="keyword">instanceof</span> FileList <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstFile = files[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<h3 id="2-对象使用-1"><a href="#2-对象使用-1" class="headerlink" title="2. 对象使用"></a>2. 对象使用</h3><p>所有 <code>type</code> 属性为 <code>file</code> 的 <code>&lt;input&gt;</code> 元素都有一个 <code>files</code> 属性，<strong>用来存储用户所选择的文件</strong>. 例如:</p>
<h3 id="3-实例属性和方法-1"><a href="#3-实例属性和方法-1" class="headerlink" title="3. 实例属性和方法"></a>3. 实例属性和方法</h3><h4 id="3-1-实例属性-1"><a href="#3-1-实例属性-1" class="headerlink" title="3.1 实例属性"></a>3.1 实例属性</h4><p>实例只有一个属性：</p>
<ul>
<li><code>FileList.length</code>：返回列表中的文件数量。只读</li>
</ul>
<h4 id="3-2-实例方法-1"><a href="#3-2-实例方法-1" class="headerlink" title="3.2 实例方法"></a>3.2 实例方法</h4><p>实例只有一个方法：</p>
<ul>
<li><code>FileList.item()</code>：用来返回指定位置的实例，从 0 开始。</li>
</ul>
<p>由于 <code>FileList</code> 实例是个类数组对象，可以直接用方括号运算符，即<code> myFileList[0]</code> 等同于 <code>myFileList.item(0)</code> ，所以一般用不到 <code>item() </code>方法。</p>
<h3 id="4-兼容性-1"><a href="#4-兼容性-1" class="headerlink" title="4. 兼容性"></a>4. 兼容性</h3><p><img src="http://images.pingan8787.com/blog/FileList%E5%AF%B9%E8%B1%A1%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt="FileList对象兼容性.png"></p>
<h3 id="5-实例"><a href="#5-实例" class="headerlink" title="5. 实例"></a>5. 实例</h3><p>选择多个文件，并获取每个文件信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input id=&quot;myfiles&quot; multiple type=&quot;file&quot;&gt;</span></span><br><span class="line"><span class="keyword">const</span> myFile = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#myfiles&quot;</span>);</span><br><span class="line">myFile.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> files = <span class="built_in">this</span>.files;</span><br><span class="line">    <span class="keyword">let</span> fileLength = files.length;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt; fileLength) &#123;</span><br><span class="line">        <span class="keyword">let</span> file = files[i];</span><br><span class="line">        <span class="built_in">console</span>.log(file.name);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="三、FileReader-对象"><a href="#三、FileReader-对象" class="headerlink" title="三、FileReader 对象"></a>三、FileReader 对象</h2><h3 id="1-概念介绍-2"><a href="#1-概念介绍-2" class="headerlink" title="1. 概念介绍"></a>1. 概念介绍</h3><p><code>FileReader</code> 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 <code>File</code> 或 <code>Blob</code> 对象指定要读取的文件或数据。</p>
<p>简单理解，就是用于读取 <code>File</code> 对象或 <code>Blob</code> 对象所包含的文件内容。</p>
<h3 id="2-对象使用-2"><a href="#2-对象使用-2" class="headerlink" title="2. 对象使用"></a>2. 对象使用</h3><p>浏览器原生提供一个 <code>FileReader</code> 构造函数，用来生成 <code>FileReader</code> 实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br></pre></td></tr></table></figure>

<h3 id="3-实例属性和方法-2"><a href="#3-实例属性和方法-2" class="headerlink" title="3. 实例属性和方法"></a>3. 实例属性和方法</h3><p><code>FileReader</code> 对象拥有的属性和方法较多。</p>
<h4 id="3-1-实例属性-2"><a href="#3-1-实例属性-2" class="headerlink" title="3.1 实例属性"></a>3.1 实例属性</h4><ul>
<li><code>FileReader.error</code> : 表示在读取文件时发生的错误。只读</li>
<li><code>FileReader.readyState</code> : 整数，表示读取文件时的当前状态。只读</li>
</ul>
<p>共有三种状态：<br>0 : EMPTY，表示尚未加载任何数据；<br>1 : LOADING，表示数据正在加载；<br>2 : DONE，表示加载完成；</p>
<ul>
<li><code>FileReader.result</code> 读取完成后的文件内容。只读</li>
</ul>
<p>仅在读取操作完成后才有效，返回的数据格式<strong>取决于使用哪个方法来启动读取操作</strong>。</p>
<h4 id="3-2-事件处理"><a href="#3-2-事件处理" class="headerlink" title="3.2 事件处理"></a>3.2 事件处理</h4><ul>
<li><code>FileReader.onabort</code> : 处理<code>abort</code>事件。该事件在读取操作<strong>被中断</strong>时触发。</li>
<li><code>FileReader.onerror</code> : 处理<code>error</code>事件。该事件在读取操作<strong>发生错误</strong>时触发。</li>
<li><code>FileReader.onload</code> : 处理<code>load</code>事件。该事件在读取操作<strong>完成</strong>时触发。</li>
<li><code>FileReader.onloadstart</code> : 处理<code>loadstar</code>t事件。该事件在读取操作<strong>开始</strong>时触发。</li>
<li><code>FileReader.onloadend</code> : 处理<code>loadend</code>事件。该事件在读取操<strong>作结束</strong>时（要么成功，要么失败）触发。</li>
<li><code>FileReader.onprogress</code> : 处理<code>progress</code>事件。该事件在读取<strong>Blob</strong>时触发。</li>
</ul>
<h4 id="3-3-实例方法"><a href="#3-3-实例方法" class="headerlink" title="3.3 实例方法"></a>3.3 实例方法</h4><ul>
<li><code>FileReader.abort()</code>：终止读取操作，<code>readyState</code> 属性将变成2。</li>
<li><code>FileReader.readAsArrayBuffer()</code>：以 <code>ArrayBuffer</code> 的格式读取文件，读取完成后 <code>result</code> 属性将返回一个 <code>ArrayBuffer</code> 实例。</li>
<li><code>FileReader.readAsBinaryString()</code>：读取完成后， <code>result</code> 属性将<strong>返回原始的二进制字符串</strong>。</li>
<li><code>FileReader.readAsDataURL()</code>：读取完成后， <code>result</code> 属性将返回一个 Data URL 格式（Base64 编码）的字符串，代表文件内容。</li>
</ul>
<p>对于图片文件，这个字符串可以用于<code>&lt;img&gt;</code>元素的 <code>src</code> 属性。注意，这个字符串不能直接进行 Base64 解码，必须把前缀 <code>data:*/*;base64</code> ,从字符串里删除以后，再进行解码。</p>
<ul>
<li><code>FileReader.readAsText()</code>：读取完成后， <code>result</code> 属性将返回文件内容的文本字符串。</li>
</ul>
<p>该方法的第一个参数是代表文件的 Blob 实例，第二个参数是可选的，表示文本编码，默认为 <code>UTF-8</code>。</p>
<h3 id="4-兼容性-2"><a href="#4-兼容性-2" class="headerlink" title="4. 兼容性"></a>4. 兼容性</h3><p><img src="http://images.pingan8787.com/blog/FileReader%E5%AF%B9%E8%B1%A1%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt="FileReader对象兼容性.png"></p>
<h3 id="5-实例-1"><a href="#5-实例-1" class="headerlink" title="5. 实例"></a>5. 实例</h3><p>这里举一个图片预览的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;input type=&quot;file&quot; onchange=&quot;previewFile()&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;img src=&quot;&quot; height=&quot;200&quot;&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">previewFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> preview = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> file    = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;input[type=file]&#x27;</span>).files[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> reader  = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">  reader.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    preview.src = reader.result;</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (file) &#123;</span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/bom/file.html">《File 对象，FileList 对象，FileReader 对象》</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API">MDN</a></li>
</ol>
<h2 id="五、关于我"><a href="#五、关于我" class="headerlink" title="五、关于我"></a>五、关于我</h2><blockquote>
<p>本文首发在 <a target="_blank" rel="noopener" href="http://www.pingan8787.com/">pingan8787个人博客</a>，如需转载请保留个人介绍。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#112;&#x69;&#x6e;&#x67;&#x61;&#110;&#56;&#55;&#x38;&#x37;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#109;">&#112;&#x69;&#x6e;&#x67;&#x61;&#110;&#56;&#55;&#x38;&#x37;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>ES小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>
<p><img src="http://images.pingan8787.com/2019_07_12guild_page.png" alt="bg">  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/12/18/188-%E3%80%90%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97%E3%80%91File%E5%92%8CFileList%E5%92%8CFileReader%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/" data-id="ckts3ejtx00514d9k97dm4skr" data-title="188-【前端知乎系列】File和FileList和FileReader对象详解" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97/" rel="tag">前端知乎系列</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/" rel="tag">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS%E5%8A%A8%E7%94%BB/" rel="tag">CSS动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome/" rel="tag">Chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6-ES7-ES8/" rel="tag">ES6/ES7/ES8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eslint/" rel="tag">Eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Express/" rel="tag">Express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GraphQL/" rel="tag">GraphQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/H5/" rel="tag">H5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP%E5%8D%8F%E8%AE%AE/" rel="tag">HTTP协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hybrid/" rel="tag">Hybrid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NPM/" rel="tag">NPM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Numpy/" rel="tag">Numpy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/" rel="tag">Tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TyeScript/" rel="tag">TyeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vuejs/" rel="tag">Vuejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/" rel="tag">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/demo/" rel="tag">demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" rel="tag">人工智能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/" rel="tag">全栈开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2/" rel="tag">前端探索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97/" rel="tag">前端知乎系列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/" rel="tag">常用技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" rel="tag">微前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" rel="tag">构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB/" rel="tag">源码精读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%83%AD%E9%97%A8/" rel="tag">热门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/" rel="tag">生活杂记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" rel="tag">网络请求</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E6%B8%A9%E5%9F%BA%E7%A1%80/" rel="tag">重温基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Angular/" style="font-size: 11.88px;">Angular</a> <a href="/tags/CSS/" style="font-size: 18.13px;">CSS</a> <a href="/tags/CSS%E5%8A%A8%E7%94%BB/" style="font-size: 12.5px;">CSS动画</a> <a href="/tags/Chrome/" style="font-size: 10px;">Chrome</a> <a href="/tags/ES6-ES7-ES8/" style="font-size: 10.63px;">ES6/ES7/ES8</a> <a href="/tags/Eslint/" style="font-size: 10px;">Eslint</a> <a href="/tags/Express/" style="font-size: 10px;">Express</a> <a href="/tags/GraphQL/" style="font-size: 10px;">GraphQL</a> <a href="/tags/H5/" style="font-size: 10px;">H5</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/HTTP/" style="font-size: 11.88px;">HTTP</a> <a href="/tags/HTTP%E5%8D%8F%E8%AE%AE/" style="font-size: 11.25px;">HTTP协议</a> <a href="/tags/Hybrid/" style="font-size: 10.63px;">Hybrid</a> <a href="/tags/JavaScript/" style="font-size: 19.38px;">JavaScript</a> <a href="/tags/NPM/" style="font-size: 10px;">NPM</a> <a href="/tags/Nodejs/" style="font-size: 11.25px;">Nodejs</a> <a href="/tags/Numpy/" style="font-size: 10.63px;">Numpy</a> <a href="/tags/Python/" style="font-size: 17.5px;">Python</a> <a href="/tags/React/" style="font-size: 12.5px;">React</a> <a href="/tags/Tensorflow/" style="font-size: 10.63px;">Tensorflow</a> <a href="/tags/TyeScript/" style="font-size: 10px;">TyeScript</a> <a href="/tags/TypeScript/" style="font-size: 11.25px;">TypeScript</a> <a href="/tags/Vuejs/" style="font-size: 14.38px;">Vuejs</a> <a href="/tags/WebSocket/" style="font-size: 10px;">WebSocket</a> <a href="/tags/Webpack/" style="font-size: 15.63px;">Webpack</a> <a href="/tags/demo/" style="font-size: 10.63px;">demo</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">中间件</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 16.25px;">人工智能</a> <a href="/tags/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/" style="font-size: 11.25px;">全栈开发</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 20px;">前端开发</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2/" style="font-size: 11.25px;">前端探索</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97/" style="font-size: 10.63px;">前端知乎系列</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 18.75px;">原创</a> <a href="/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/" style="font-size: 10.63px;">常用技术</a> <a href="/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">微前端</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 13.75px;">总结</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">机器学习</a> <a href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" style="font-size: 10.63px;">构建工具</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10.63px;">正则表达式</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 10px;">源码</a> <a href="/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB/" style="font-size: 10px;">源码精读</a> <a href="/tags/%E7%83%AD%E9%97%A8/" style="font-size: 10px;">热门</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/" style="font-size: 10px;">生活杂记</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.13px;">算法</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 10px;">编译原理</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" style="font-size: 10px;">网络请求</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.38px;">读书笔记</a> <a href="/tags/%E9%87%8D%E6%B8%A9%E5%9F%BA%E7%A1%80/" style="font-size: 16.88px;">重温基础</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 10px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/28/227-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8SVG%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/">227-【总结】如何优雅的在微信小程序使用SVG字体图标</a>
          </li>
        
          <li>
            <a href="/2021/07/28/226-%E3%80%90HTTP%E3%80%91%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9F/">226-【HTTP】如何优雅的管理HTTP请求和响应拦截器？</a>
          </li>
        
          <li>
            <a href="/2021/07/28/225-%E3%80%90Vue%E3%80%91%E4%BB%8E%E6%89%8B%E5%86%99Vue3%E7%9A%84Reactivity%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%85%A5Vue3%E6%BA%90%E7%A0%81/">225-【Vue】从手写Vue3的Reactivity开始深入Vue3源码</a>
          </li>
        
          <li>
            <a href="/2021/05/30/224-%E3%80%90Chrome%E3%80%915%E4%B8%AAChrome%E8%B0%83%E8%AF%95%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7/">224-【Chrome】5个Chrome调试混合应用的技巧</a>
          </li>
        
          <li>
            <a href="/2021/03/19/223-%E3%80%90%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2%E3%80%91%E6%8E%A2%E7%B4%A2Snabbdom%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">223-【前端探索】探索Snabbdom模块系统原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>