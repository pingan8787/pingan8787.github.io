<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-187-【前端知乎系列】ArrayBuffer和Blob对象" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/12/16/187-%E3%80%90%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97%E3%80%91ArrayBuffer%E5%92%8CBlob%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time class="dt-published" datetime="2019-12-16T14:12:23.000Z" itemprop="datePublished">2019-12-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/12/16/187-%E3%80%90%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97%E3%80%91ArrayBuffer%E5%92%8CBlob%E5%AF%B9%E8%B1%A1/">187-【前端知乎系列】ArrayBuffer和Blob对象</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="http://images.pingan8787.com/blog/ArrayBufferAndBlob.png" alt="ArrayBufferAndBlob.png"></p>
<blockquote>
<p>本文首发在我的【<a target="_blank" rel="noopener" href="http://www.pingan8787.com/">个人博客</a>】<br>更多丰富的前端学习资料，可以查看我的 <strong>Github</strong>: <a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo-JavaScript">《Leo-JavaScript》</a>，内容涵盖<strong>数据结构与算法</strong>、<strong>HTTP</strong>、<strong>Hybrid</strong>、<strong>面试题</strong>、<strong>React</strong>、<strong>Angular</strong>、<strong>TypeScript</strong>和<strong>Webpack</strong>等等。<br>点个 Star 不迷路~</p>
</blockquote>
<p><code>ArrayBuffer</code> 对象与 <code>Blob</code> 对象大家或许不太陌生，常见于文件上传操作处理（如处理图片上传预览等问题）。</p>
<p>那么本文将与大家深入介绍两者。</p>
<h2 id="一、ArrayBuffer-对象"><a href="#一、ArrayBuffer-对象" class="headerlink" title="一、ArrayBuffer 对象"></a>一、ArrayBuffer 对象</h2><p><code>ArrayBuffer</code> 对象是 ES6 才纳入正式 ECMAScript 规范，是 JavaScript <strong>操作二进制数据</strong>的一个接口。<code>ArrayBuffer</code> 对象是以数组的语法处理二进制数据，也称二进制数组。</p>
<p>介绍 <code>ArrayBuffer</code> 对象还需介绍 <code>TypedArray</code> 视图和 <code>DataView</code> 视图，本文不具体介绍，详细可以查看阮一峰老师<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/arraybuffer">《ECMAScript 6 入门 ArrayBuffer》</a> 章节。</p>
<h3 id="1-概念介绍"><a href="#1-概念介绍" class="headerlink" title="1. 概念介绍"></a>1. 概念介绍</h3><p><code>ArrayBuffer</code> 对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（<code>TypedArray</code>视图和<code>DataView</code>视图）来读写，视图的作用是以指定格式解读二进制数据。</p>
<p>关于 <code>TypedArray</code> 视图和 <code>DataView</code> 视图 ，可以查看阮一峰老师<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/arraybuffer">《ECMAScript 6 入门 ArrayBuffer》</a> 章节的介绍。</p>
<h3 id="2-对象使用"><a href="#2-对象使用" class="headerlink" title="2. 对象使用"></a>2. 对象使用</h3><p>浏览器原生提供 <code>ArrayBuffer()</code> 构造函数，用来生成实例。</p>
<p>参数： </p>
<ul>
<li>整数，表示二进制数据占用的字节长度。</li>
</ul>
<p>返回值：</p>
<ul>
<li>一个指定大小的 <code>ArrayBuffer</code> 对象，其内容被初始化为 0。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">32</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码表示实例对象 <code>buffer</code> 占用 32 个字节。</p>
<h3 id="3-实例属性和方法"><a href="#3-实例属性和方法" class="headerlink" title="3. 实例属性和方法"></a>3. 实例属性和方法</h3><p><code>ArrayBuffer</code> 对象有实例属性 <code>byteLength</code> ，表示当前实例<strong>占用的内存字节长度</strong>（单位字节），<strong>一单创建就不可变更（只读）</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">32</span>);</span><br><span class="line">buffer.byteLength; <span class="comment">// 32</span></span><br></pre></td></tr></table></figure>

<p><code>ArrayBuffer</code> 对象有实例方法 <code>slice()</code>，用来复制一部分内存。</p>
<p>参数如下：</p>
<ul>
<li><p>start，整数类型，表示开始复制的位置。默认从 0 开始。</p>
</li>
<li><p>end，整数类型，表示结束复制的位置（不包括结束的位置）。如果省略，则表示复制到结束。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">32</span>);</span><br><span class="line"><span class="keyword">const</span> buffer2 = buffer.slice(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-兼容性"><a href="#4-兼容性" class="headerlink" title="4. 兼容性"></a>4. 兼容性</h3><p><img src="http://images.pingan8787.com/blog/ArrayBuffer%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt="ArrayBuffer兼容性.png"></p>
<p>图片来自 MDN </p>
<h2 id="二、Blob-对象"><a href="#二、Blob-对象" class="headerlink" title="二、Blob 对象"></a>二、Blob 对象</h2><h3 id="1-概念介绍-1"><a href="#1-概念介绍-1" class="headerlink" title="1. 概念介绍"></a>1. 概念介绍</h3><p><code>Blob</code> 全称：<code>Binary Large Object</code> （二进制大型对象）。</p>
<p><code>Blob</code> 对象表示一个二进制文件的数据内容，通常用来<strong>读写文件</strong>，比如一个图片文件的内容就可以通过 <code>Blob</code> 对象读写。</p>
<p>与 <code>ArrayBuffer</code> 区别：</p>
<ul>
<li><code>Blob</code> 用于操作<strong>二进制文件</strong></li>
<li><code>ArrayBuffer</code> 用于操作<strong>内存</strong></li>
</ul>
<h3 id="2-对象使用-1"><a href="#2-对象使用-1" class="headerlink" title="2. 对象使用"></a>2. 对象使用</h3><p>浏览器原生提供 <code>Blob()</code> 构造函数，用来生成实例。</p>
<p><code>Blob</code> 的内容由参数数组中给出的值的串联组成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> leoBlob = <span class="keyword">new</span> Blob(array [, options]);</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>array</code>，必填，成员是字符串或二进制对象，表示新生成的Blob实例对象的内容；</li>
</ul>
<p>成员可以是一个由 <code>ArrayBuffer</code> ,  <code>ArrayBufferView</code> , <code>Blob</code> ,  <code>DOMString</code> 等对象构成的 <code>Array</code> ，或者其他类似对象的混合体，它将会被放进 <code>Blob</code>。<code>DOMStrings</code>会被编码为<code>UTF-8</code>。</p>
<ul>
<li><code>options</code>，可选，是一个配置对象，这里介绍常用的属性 <code>type</code>，表示数据的 MIME 类型，默认空字符串；</li>
</ul>
<p><code>options</code> 目前可能有两个属性： <code>type</code> 和 <code>endings</code>。</p>
<p><code>endings</code> 用于指定包含行结束符 <code>\n</code> 的字符串如何被写入，默认值 <code>transparent</code>。它只有这两个值：<code>native</code> （代表行结束符会被更改为适合宿主操作系统文件系统的换行符）和 <code>transparent</code> （代表会保持blob中保存的结束符不变）。</p>
<p>使用案例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> leoHtmlFragment = [<span class="string">&#x27;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey leo！&lt;/b&gt;&lt;/a&gt;&#x27;</span>]; <span class="comment">// 一个包含 DOMString 的数组</span></span><br><span class="line"><span class="keyword">const</span> leoBlob = <span class="keyword">new</span> Blob(leoHtmlFragment, &#123;<span class="attr">type</span> : <span class="string">&#x27;text/html&#x27;</span>&#125;);   <span class="comment">// 得到 blob</span></span><br></pre></td></tr></table></figure>

<p>该代码中，实例对象 <code>leoBlob</code> 包含的是字符串。生成实例时，指定数据类型为 <code>text/html</code>。</p>
<p>还可以使用 Blob 保存 JSON 数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">hello</span>: <span class="string">&#x27;leo&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([ <span class="built_in">JSON</span>.stringify(obj) ], &#123;<span class="attr">type</span> : <span class="string">&#x27;application/json&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-实例属性和方法-1"><a href="#3-实例属性和方法-1" class="headerlink" title="3. 实例属性和方法"></a>3. 实例属性和方法</h3><p><code>Blob</code> 具有两个实例属性：</p>
<ul>
<li><p><code>size</code>：文件的大小，单位为字节。</p>
</li>
<li><p><code>type</code>：文件的 MIME 类型。如果类型无法确定，则返回空字符串。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> leoHtmlFragment = [<span class="string">&#x27;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey leo！&lt;/b&gt;&lt;/a&gt;&#x27;</span>]; <span class="comment">// 一个包含 DOMString 的数组</span></span><br><span class="line"><span class="keyword">const</span> leoBlob = <span class="keyword">new</span> Blob(leoHtmlFragment, &#123;<span class="attr">type</span> : <span class="string">&#x27;text/html&#x27;</span>&#125;);   <span class="comment">// 得到 blob</span></span><br><span class="line"></span><br><span class="line">leoBlob.size; <span class="comment">// 38</span></span><br><span class="line">leoBlob.type; <span class="comment">// &quot;text/html&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Blob</code> 实例方法：</p>
<ul>
<li><code>clice</code>：方法用于创建一个包含源 <code>Blob</code> 的指定字节范围内的数据的新 <code>Blob</code> 对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newBlob = oldBlob.slice([start [, end [, contentType]]])</span><br></pre></td></tr></table></figure>

<p>包含三个参数：</p>
<p><code>start</code>，可选，起始的字节位置，默认 0；</p>
<p><code>end</code>，可选，结束的字节位置，默认 <code>size</code> 属性的值，不包含该位置；</p>
<p><code>contentType</code>，可选，新实例的数据类型（默认为空字符串）；</p>
<h3 id="4-兼容性-1"><a href="#4-兼容性-1" class="headerlink" title="4. 兼容性"></a>4. 兼容性</h3><p><img src="http://images.pingan8787.com/blog/Blob%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt="Blob兼容性.png"></p>
<p>图片来自 MDN </p>
<h3 id="5-实际案例"><a href="#5-实际案例" class="headerlink" title="5. 实际案例"></a>5. 实际案例</h3><h4 id="5-1-获取文件信息"><a href="#5-1-获取文件信息" class="headerlink" title="5.1 获取文件信息"></a>5.1 获取文件信息</h4><p>文件选择器 <code>&lt;input type=&quot;file&quot;&gt;</code> 用来让用户选取文件。出于安全考虑，浏览器不允许脚本自行设置这个控件的 <code>value</code> 属性，即<strong>文件必须是用户手动选取的，不能是脚本指定的</strong>。一旦用户选好了文件，脚本就可以读取这个文件。</p>
<p>文件选择器返回一个 <code>FileList</code> 对象，该对象是个类数组对象，每个成员都是一个 <code>File</code> 实例对象。<code>File</code> 实例对象是一个特殊的 <code>Blob</code> 实例，增加了 <code>name</code> 和 <code>lastModifiedDate</code> 属性。</p>
<p>也包括<strong>拖放 API</strong> 的 <code>dataTransfer.files</code> 返回的也是一个 <code>FileList</code> 对象，成员也是 <code>File</code> 实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; multiple onchange=&quot;fileinfo(this.files)&quot;/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileinfo</span>(<span class="params">files</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> f = files[i];</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      f.name, <span class="comment">// 文件名，不含路径</span></span><br><span class="line">      f.size, <span class="comment">// 文件大小，Blob 实例属性</span></span><br><span class="line">      f.type, <span class="comment">// 文件类型，Blob 实例属性</span></span><br><span class="line">      f.lastModifiedDate <span class="comment">// 文件的最后修改时间</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-下载文件"><a href="#5-2-下载文件" class="headerlink" title="5.2 下载文件"></a>5.2 下载文件</h4><p>在 AJAX 请求中，指定 <code>responseType</code> 属性为 <code>blob</code> ，皆可以下下载一个 Blob 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBlob</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">  xhr.responseType = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(xhr.response);</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，<code>xhr.response</code> 拿到的就是一个 <code>Blob</code> 对象。</p>
<h4 id="5-3-生成-URL"><a href="#5-3-生成-URL" class="headerlink" title="5.3 生成 URL"></a>5.3 生成 URL</h4><p>浏览器允许使用 <code>URL.createObjectURL()</code> 方法，针对 <code>Blob</code> 对象生成一个临时<code> URL</code>，以便于某些 <code>API</code> 使用。</p>
<p>如作为图片预览的 URL。</p>
<p>这个 URL 以 <code>blob://</code> 开头，表明对应一个 <code>Blob</code> 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象。这一点与 <code>data://URL</code>（URL 包含实际数据）和 <code>file://URL</code>（本地文件系统里面的文件）都不一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> droptarget = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;droptarget&#x27;</span>);</span><br><span class="line"></span><br><span class="line">droptarget.ondrop = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> files = e.dataTransfer.files;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> type = files[i].type;</span><br><span class="line">    <span class="keyword">if</span> (type.substring(<span class="number">0</span>,<span class="number">6</span>) !== <span class="string">&#x27;image/&#x27;</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    img.src = URL.createObjectURL(files[i]);</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.width = <span class="number">100</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(<span class="built_in">this</span>);</span><br><span class="line">      URL.revokeObjectURL(<span class="built_in">this</span>.src);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中，通过为拖放的图片文件生成一个 URL，作为预览的缩略图。</p>
<p>浏览器处理 Blob URL 就跟普通的 URL 一样，如果 <code>Blob</code> 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 <code>GET</code> 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。</p>
<h4 id="5-4-读取文件"><a href="#5-4-读取文件" class="headerlink" title="5.4 读取文件"></a>5.4 读取文件</h4><p>取得 <code>Blob</code> 对象以后，可以通过 <code>FileReader</code> 对象，读取 <code>Blob</code> 对象的内容，即文件内容。</p>
<p><code>FileReader</code> 对象提供四个方法。将 Blob 对象作为参数传入，然后以指定的格式返回。</p>
<ul>
<li><code>FileReader.readAsText()</code>：返回文本，需要指定文本编码，默认为 UTF-8。   </li>
<li><code>FileReader.readAsArrayBuffer()</code>：返回 ArrayBuffer 对象。  </li>
<li><code>FileReader.readAsDataURL()</code>：返回 Data URL。  </li>
<li><code>FileReader.readAsBinaryString()</code>：返回原始的二进制字符串。  </li>
</ul>
<p>下面是 <code>FileReader.readAsText()</code> 方法的例子，用来读取文本文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&#x27;file&#x27; onchange=&#x27;readfile(this.files[0])&#x27;&gt;&lt;/input&gt;</span></span><br><span class="line"><span class="comment">// &lt;pre id=&#x27;output&#x27;&gt;&lt;/pre&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readfile</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  reader.readAsText(f);</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> text = reader.result;</span><br><span class="line">    <span class="keyword">let</span> out = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;output&#x27;</span>);</span><br><span class="line">    out.innerHTML = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    out.appendChild(<span class="built_in">document</span>.createTextNode(text));</span><br><span class="line">  &#125;</span><br><span class="line">  reader.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Error&#x27;</span>, e);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 <code>FileReader.readAsArrayBuffer()</code> 方法的例子，用于读取二进制文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;file&quot; onchange=&quot;typefile(this.files[0])&quot;&gt;&lt;/input&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typefile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 文件开头的四个字节，生成一个 Blob 对象</span></span><br><span class="line">  <span class="keyword">let</span> slice = file.slice(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  <span class="comment">// 读取这四个字节</span></span><br><span class="line">  reader.readAsArrayBuffer(slice);</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> buffer = reader.result;</span><br><span class="line">    <span class="comment">// 将这四个字节的内容，视作一个32位整数</span></span><br><span class="line">    <span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</span><br><span class="line">    <span class="keyword">let</span> magic = view.getUint32(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 根据文件的前四个字节，判断它的类型</span></span><br><span class="line">    <span class="keyword">switch</span>(magic) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x89504E47</span>: file.verified_type = <span class="string">&#x27;image/png&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x47494638</span>: file.verified_type = <span class="string">&#x27;image/gif&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x25504446</span>: file.verified_type = <span class="string">&#x27;application/pdf&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x504b0304</span>: file.verified_type = <span class="string">&#x27;application/zip&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(file.name, file.verified_type);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/bom/arraybuffer.html">《ArrayBuffer 对象，Blob 对象》</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/arraybuffer">《ECMAScript 6 入门 ArrayBuffer》</a></li>
</ol>
<h2 id="四、关于我"><a href="#四、关于我" class="headerlink" title="四、关于我"></a>四、关于我</h2><blockquote>
<p>本文首发在 <a target="_blank" rel="noopener" href="http://www.pingan8787.com/">pingan8787个人博客</a>，如需转载请保留个人介绍。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#x69;&#x6e;&#x67;&#x61;&#x6e;&#x38;&#x37;&#x38;&#x37;&#64;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#x70;&#x69;&#x6e;&#x67;&#x61;&#x6e;&#x38;&#x37;&#x38;&#x37;&#64;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>ES小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>
<p><img src="http://images.pingan8787.com/2019_07_12guild_page.png" alt="bg">  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/12/16/187-%E3%80%90%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97%E3%80%91ArrayBuffer%E5%92%8CBlob%E5%AF%B9%E8%B1%A1/" data-id="ckts3ejtw004z4d9k37cpeu9y" data-title="187-【前端知乎系列】ArrayBuffer和Blob对象" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97/" rel="tag">前端知乎系列</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-186-【全栈修炼】RESTful架构及实践修炼宝典" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/25/186-%E3%80%90%E5%85%A8%E6%A0%88%E4%BF%AE%E7%82%BC%E3%80%91RESTful%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BF%AE%E7%82%BC%E5%AE%9D%E5%85%B8/" class="article-date">
  <time class="dt-published" datetime="2019-11-25T15:49:40.000Z" itemprop="datePublished">2019-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/25/186-%E3%80%90%E5%85%A8%E6%A0%88%E4%BF%AE%E7%82%BC%E3%80%91RESTful%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BF%AE%E7%82%BC%E5%AE%9D%E5%85%B8/">186-【全栈修炼】RESTful架构及实践修炼宝典</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="http://images.pingan8787.com/blog/RESTful.png" alt="RESTful API"></p>
<h2 id="一、概念介绍"><a href="#一、概念介绍" class="headerlink" title="一、概念介绍"></a>一、概念介绍</h2><h3 id="1-REST-概念"><a href="#1-REST-概念" class="headerlink" title="1. REST 概念"></a>1. REST 概念</h3><p>REST：（Representational State Transfer）即<strong>表现层状态转换</strong>，定义了<strong>资源</strong>的通用访问格式，是一种网络应用程序的<strong>设计风格</strong>和<strong>开发方式</strong>。</p>
<p>在概念中，需要理解以下几个名称：</p>
<ol>
<li>资源（Resource）</li>
</ol>
<p>即<strong>服务器上获取到的东西任何资源</strong>，一条用户记录，一个用户的密码，一张图片等等都是。</p>
<ol start="2">
<li>资源的表述（Representation）</li>
</ol>
<p>即<strong>资源格式</strong>，是 HTML、XML、JSON、纯文本、图片等等，可以用各种各样的格式来表述你获取到的资源。</p>
<ol start="3">
<li>状态转移（State Transfer）</li>
</ol>
<p>即<strong>URL定位资源</strong>，用 HTTP 动词（GET,POST,DELETE,DETC）描述操作。操作是动词，资源是名词。</p>
<ol start="4">
<li>统一接口（Uniform Interface）</li>
</ol>
<p>即通过统一的接口对资源进行操作。</p>
<h3 id="2-REST-特点"><a href="#2-REST-特点" class="headerlink" title="2. REST 特点"></a>2. REST 特点</h3><p>REST 通常基于使用 <code>HTTP</code> ， <code>URI</code> ，和 <code>XML</code> 以及 <code>HTML</code> 这些现有的广泛流行的协议和标准，每一种 URI 代表一种资源。</p>
<p>REST 通常使用 <code>JSON</code> 数据格式。</p>
<p>REST 基本架构的四个方法：</p>
<ul>
<li><p><strong>GET</strong> - 用于<strong>获取数据</strong></p>
</li>
<li><p><strong>PUT</strong> - 用于<strong>更新或添加数据</strong></p>
</li>
<li><p><strong>DELETE</strong> - 用于<strong>删除数据</strong></p>
</li>
<li><p><strong>POST</strong> - 用于<strong>添加数据</strong></p>
</li>
</ul>
<p>下面会通过一个场景介绍。</p>
<h3 id="3-REST-优点"><a href="#3-REST-优点" class="headerlink" title="3. REST 优点"></a>3. REST 优点</h3><ul>
<li>可更高效利用缓存来提高响应速度</li>
<li>通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性</li>
<li>浏览器即可作为客户端，简化软件需求</li>
<li>相对于其他叠加在HTTP协议之上的机制，REST的软件依赖性更小</li>
<li>不需要额外的资源发现机制</li>
<li>在软件技术演进中的长期的兼容性更好</li>
</ul>
<h2 id="二、实例介绍"><a href="#二、实例介绍" class="headerlink" title="二、实例介绍"></a>二、实例介绍</h2><p>REST 定义了资源的通用访问格式，接下来一个消费者为实例，介绍 RESTful API 定义：</p>
<ol>
<li>获取所有 users </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/users</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取指定 id 的 users</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/users/100</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>新建一条 users 记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /api/users</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>更新一条 users 记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /api/users/100</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>删除一条 users 记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /api/users/100</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>获取一个 users 的所有消费账单</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET  /api/users/100/bill</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>获取一个 user 指定时间的消费账单</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET  /api/users/100/bill?from=201910&amp;to=201911</span><br></pre></td></tr></table></figure>

<p>以上其中 RESTful 风格 API 几乎包含常见业务情况。</p>
<h2 id="三、Nodejs-实现-RESTful-API"><a href="#三、Nodejs-实现-RESTful-API" class="headerlink" title="三、Nodejs 实现 RESTful API"></a>三、Nodejs 实现 RESTful API</h2><h3 id="1-初始化-mock-数据"><a href="#1-初始化-mock-数据" class="headerlink" title="1. 初始化 mock 数据"></a>1. 初始化 mock 数据</h3><p>本案例使用 mock 数据来演示，如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;user1&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;leo&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;password&quot;</span> : <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;profession&quot;</span> : <span class="string">&quot;teacher&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">1</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">&quot;user2&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;pingan8787&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;password&quot;</span> : <span class="string">&quot;654321&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;profession&quot;</span> : <span class="string">&quot;librarian&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">2</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">&quot;user3&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;robin&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;password&quot;</span> : <span class="string">&quot;888888&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;profession&quot;</span> : <span class="string">&quot;clerk&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">3</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将实现以下 RESTful API ：</p>
<h3 id="2-获取用户列表"><a href="#2-获取用户列表" class="headerlink" title="2. 获取用户列表"></a>2. 获取用户列表</h3><p>这一步我们会创建 RESTful API 中的 <strong>/users</strong>，使用 GET 来<strong>读取用户的信息列表</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 读取用户的信息列表 的接口</span></span><br><span class="line">app.get(<span class="string">&#x27;/users&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   fs.readFile( __dirname + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;users.json&quot;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log( data );</span><br><span class="line">       res.end( data );</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;address, port&#125; = server.address();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;server run in: http://%s:%s&quot;</span>, address, port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-添加用户"><a href="#3-添加用户" class="headerlink" title="3. 添加用户"></a>3. 添加用户</h3><p>这一步我们会创建 RESTful API 中的 <strong>/users</strong>，使用 POST 来<strong>添加用户记录</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 省略之前文件 只展示需要实现的接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mock 一条要新增的数据</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">   <span class="string">&quot;user4&quot;</span> : &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span> : <span class="string">&quot;pingan&quot;</span>,</span><br><span class="line">      <span class="string">&quot;password&quot;</span> : <span class="string">&quot;password4&quot;</span>,</span><br><span class="line">      <span class="string">&quot;profession&quot;</span> : <span class="string">&quot;teacher&quot;</span>,</span><br><span class="line">      <span class="string">&quot;id&quot;</span>: <span class="number">4</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 添加用户记录 的接口</span></span><br><span class="line">app.post(<span class="string">&#x27;/users&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 读取已存在的数据</span></span><br><span class="line">   fs.readFile( __dirname + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;users.json&quot;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">       data = <span class="built_in">JSON</span>.parse( data );</span><br><span class="line">       data[<span class="string">&quot;user4&quot;</span>] = user[<span class="string">&quot;user4&quot;</span>];</span><br><span class="line">       <span class="built_in">console</span>.log( data );</span><br><span class="line">       res.end( <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-获取用户详情"><a href="#4-获取用户详情" class="headerlink" title="4. 获取用户详情"></a>4. 获取用户详情</h3><p>这一步我们在 RESTful API 中的 URI 后面加上 <strong>/users/:id</strong>，使用 GET 来<strong>获取指定用户详情</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 省略之前文件 只展示需要实现的接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 获取指定用户详情 的接口</span></span><br><span class="line">app.get(<span class="string">&#x27;/users/:id&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 首先我们读取已存在的用户</span></span><br><span class="line">   fs.readFile( __dirname + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;users.json&quot;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">       data = <span class="built_in">JSON</span>.parse( data );</span><br><span class="line">       <span class="keyword">const</span> user = data[<span class="string">&quot;user&quot;</span> + req.params.id] </span><br><span class="line">       <span class="built_in">console</span>.log( user );</span><br><span class="line">       res.end( <span class="built_in">JSON</span>.stringify(user));</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5-删除指定用户"><a href="#5-删除指定用户" class="headerlink" title="5. 删除指定用户"></a>5. 删除指定用户</h3><p>这一步我们会创建 RESTful API 中的 <strong>/users</strong>，使用 DELETE 来<strong>删除指定用户</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 省略之前文件 只展示需要实现的接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mock 一条要删除的用户id</span></span><br><span class="line"><span class="keyword">const</span> id = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">app.delete(<span class="string">&#x27;/users&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   fs.readFile( __dirname + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;users.json&quot;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">       data = <span class="built_in">JSON</span>.parse( data );</span><br><span class="line">       <span class="keyword">delete</span> data[<span class="string">&quot;user&quot;</span> + id];</span><br><span class="line">       <span class="built_in">console</span>.log( data );</span><br><span class="line">       res.end( <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="四、REST-最佳实践"><a href="#四、REST-最佳实践" class="headerlink" title="四、REST 最佳实践"></a>四、REST 最佳实践</h2><h3 id="1-URL-设计"><a href="#1-URL-设计" class="headerlink" title="1. URL 设计"></a>1. URL 设计</h3><h4 id="1-1-“动词-宾语”的操作指令结构"><a href="#1-1-“动词-宾语”的操作指令结构" class="headerlink" title="1.1 “动词 + 宾语”的操作指令结构"></a>1.1 “动词 + 宾语”的操作指令结构</h4><p>客户端发出的数据操作指令都是”<strong>动词 + 宾语</strong>“的结构。</p>
<p>如上面提到的，<code>GET /user</code> 这个命令，<code>GET</code> 是动词，<code>/user</code> 是宾语。根据 HTTP 规范，动词一律大写。</p>
<p>动词通常有以下五种 HTTP 方法：</p>
<p>GET：读取（Read）<br>POST：新建（Create）<br>PUT：更新（Update）<br>PATCH：更新（Update），通常是部分更新<br>DELETE：删除（Delete）</p>
<h4 id="1-2-宾语必须是名词"><a href="#1-2-宾语必须是名词" class="headerlink" title="1.2 宾语必须是名词"></a>1.2 宾语必须是名词</h4><p>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。</p>
<p>比如，<code>/users</code> 是正确的，因为 URL 是名词，而下面就都是错误的了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/getUsers</span><br><span class="line">/createUsers</span><br><span class="line">/deleteUsers</span><br></pre></td></tr></table></figure>

<h4 id="1-3-建议复数-URL"><a href="#1-3-建议复数-URL" class="headerlink" title="1.3 建议复数 URL"></a>1.3 建议复数 URL</h4><p>因为 URL 是名词，没有单复数的限制，但是还是建议如果是一个集合，就使用复数形式。如 <code>GET /users</code> 来读取所有用户列表。</p>
<h4 id="1-4-避免多级-URL"><a href="#1-4-避免多级-URL" class="headerlink" title="1.4 避免多级 URL"></a>1.4 避免多级 URL</h4><p>避免在多层级资源时，使用多级 URL。常见案例如<strong>获取某位用户的购买过的某一类商品</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /users/100/product/120</span><br></pre></td></tr></table></figure>

<p>这种 URL 语意不明，也不利拓展，建议只有第一级，其他级别用查询字符串来表达：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /users/100?product=120</span><br></pre></td></tr></table></figure>

<h3 id="2-准确的状态码表示"><a href="#2-准确的状态码表示" class="headerlink" title="2. 准确的状态码表示"></a>2. 准确的状态码表示</h3><p>HTTP 五大类状态码有100多种，每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。</p>
<p>这边列举几个经常使用的状态码介绍：</p>
<ul>
<li><p><strong>303 See Other</strong>：表示参考另一个 URL。</p>
</li>
<li><p><strong>400 Bad Request</strong>：服务器不理解客户端的请求，未做任何处理。</p>
</li>
<li><p><strong>401 Unauthorized</strong>：用户未提供身份验证凭据，或者没有通过身份验证。</p>
</li>
<li><p><strong>403 Forbidden</strong>：用户通过了身份验证，但是不具有访问资源所需的权限。</p>
</li>
<li><p><strong>404 Not Found</strong>：所请求的资源不存在，或不可用。</p>
</li>
<li><p><strong>405 Method Not Allowed</strong>：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</p>
</li>
<li><p><strong>410 Gone</strong>：所请求的资源已从这个地址转移，不再可用。</p>
</li>
<li><p><strong>415 Unsupported Media Type</strong>：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</p>
</li>
<li><p><strong>422 Unprocessable Entity</strong>：客户端上传的附件无法处理，导致请求失败。</p>
</li>
<li><p><strong>429 Too Many Requests</strong>：客户端的请求次数超过限额。</p>
</li>
<li><p><strong>500 Internal Server Error</strong>：客户端请求有效，服务器处理时发生了意外。</p>
</li>
<li><p><strong>503 Service Unavailable</strong>：服务器无法处理请求，一般用于网站维护状态。</p>
</li>
</ul>
<h3 id="3-服务端响应"><a href="#3-服务端响应" class="headerlink" title="3. 服务端响应"></a>3. 服务端响应</h3><h4 id="3-1-应该返回-JSON-对象"><a href="#3-1-应该返回-JSON-对象" class="headerlink" title="3.1 应该返回 JSON 对象"></a>3.1 应该返回 JSON 对象</h4><p>API 返回的数据格式应该是 JSON 一个对象。</p>
<h4 id="3-2-发生错误时，不要返回-200-状态码"><a href="#3-2-发生错误时，不要返回-200-状态码" class="headerlink" title="3.2 发生错误时，不要返回 200 状态码"></a>3.2 发生错误时，不要返回 200 状态码</h4><p>在发生错误时，如果还返回 200 状态码，前端需要解析返回数据才知道错误信息，这样实际上取消了状态码，是不恰当的。</p>
<p>正确的做法应该是在错误时，返回对应错误状态码，并将错误信息返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &quot;Invalid payoad.&quot;,</span><br><span class="line">  &quot;detail&quot;: &#123;</span><br><span class="line">     &quot;surname&quot;: &quot;This field is required.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">《维基百科 - 表现层状态转换》</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wy5612087/article/details/52149249">《RESTful风格的springMVC》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/nodejs/nodejs-restful-api.html">《Node.js RESTful API》</a></li>
<li><a href="www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html">《RESTful API 最佳实践》</a></li>
</ol>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><blockquote>
<p>本文首发在 <a target="_blank" rel="noopener" href="http://www.pingan8787.com/">pingan8787个人博客</a>，如需转载请联系本人。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#105;&#110;&#103;&#97;&#x6e;&#56;&#55;&#x38;&#55;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#x70;&#105;&#110;&#103;&#97;&#x6e;&#56;&#55;&#x38;&#55;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>ES小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>
<h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><p><img src="http://images.pingan8787.com/blog/2019_10_24guild_page.png" alt="bg">  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/25/186-%E3%80%90%E5%85%A8%E6%A0%88%E4%BF%AE%E7%82%BC%E3%80%91RESTful%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BF%AE%E7%82%BC%E5%AE%9D%E5%85%B8/" data-id="ckts3ejtv004w4d9k2v2s3e0i" data-title="186-【全栈修炼】RESTful架构及实践修炼宝典" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/" rel="tag">全栈开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-185-【JavaScript】详解JS函数柯里化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/25/185-%E3%80%90JavaScript%E3%80%91%E8%AF%A6%E8%A7%A3JS%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2019-11-25T12:30:41.000Z" itemprop="datePublished">2019-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/25/185-%E3%80%90JavaScript%E3%80%91%E8%AF%A6%E8%A7%A3JS%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/">185-【JavaScript】详解JS函数柯里化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="【Web技术】5-详解JS函数柯里化"><a href="#【Web技术】5-详解JS函数柯里化" class="headerlink" title="【Web技术】5- 详解JS函数柯里化"></a>【Web技术】5- 详解JS函数柯里化</h1><p>原文地址：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2975c25e4d71">https://www.jianshu.com/p/2975c25e4d71</a></p>
<p>第一次看到柯里化这个词的时候，还是在看一篇算法相关的博客提到把函数柯里化，那时一看这个词就感觉很高端，实际上当你了解了后才发现其实就是高阶函数的一个特殊用法。<br>果然是不管作用怎么样都要有个高端的名字才有用。</p>
<h3 id="首先看看柯里化到底是什么？"><a href="#首先看看柯里化到底是什么？" class="headerlink" title="首先看看柯里化到底是什么？"></a>首先看看柯里化到底是什么？</h3><blockquote>
<p>维基百科上说道：柯里化，英语：Currying(果然是满满的英译中的既视感)，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
</blockquote>
<p>看这个解释有一点抽象，我们就拿被做了无数次示例的add函数，来做一个简单的实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通的add函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingAdd</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)           <span class="comment">// 3</span></span><br><span class="line">curryingAdd(<span class="number">1</span>)(<span class="number">2</span>)   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>实际上就是把add函数的x，y两个参数变成了先用一个函数接收x然后返回一个函数去处理y参数。现在思路应该就比较清晰了，就是只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。<br>但是问题来了费这么大劲封装一层，到底有什么用处呢？没有好处想让我们程序员多干事情是不可能滴，这辈子都不可能.</p>
<h3 id="来列一列Currying有哪些好处呢？"><a href="#来列一列Currying有哪些好处呢？" class="headerlink" title="来列一列Currying有哪些好处呢？"></a>来列一列Currying有哪些好处呢？</h3><h5 id="1-参数复用"><a href="#1-参数复用" class="headerlink" title="1. 参数复用"></a>1. 参数复用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常正则验证字符串 reg.test(txt)</span></span><br><span class="line"><span class="comment">// 函数封装后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg, txt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">&#125;</span><br><span class="line">check(<span class="regexp">/\d+/g</span>, <span class="string">&#x27;test&#x27;</span>)       <span class="comment">//false</span></span><br><span class="line">check(<span class="regexp">/[a-z]+/g</span>, <span class="string">&#x27;test&#x27;</span>)    <span class="comment">//true</span></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingCheck</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hasNumber = curryingCheck(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="keyword">var</span> hasLetter = curryingCheck(<span class="regexp">/[a-z]+/g</span>)</span><br><span class="line">hasNumber(<span class="string">&#x27;test1&#x27;</span>)      <span class="comment">// true</span></span><br><span class="line">hasNumber(<span class="string">&#x27;testtest&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">hasLetter(<span class="string">&#x27;21212&#x27;</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面的示例是一个正则的校验，正常来说直接调用check函数就可以了，但是如果我有很多地方都要校验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便。</p>
<h5 id="2-提前确认"><a href="#2-提前确认" class="headerlink" title="2. 提前确认"></a>2. 提前确认</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> on = <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.attachEvent(<span class="string">&#x27;on&#x27;</span> + event, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> on = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.attachEvent(<span class="string">&#x27;on&#x27;</span> + event, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//换一种写法可能比较好理解一点，上面就是把isSupport这个参数给先确定下来了</span></span><br><span class="line"><span class="keyword">var</span> on = <span class="function"><span class="keyword">function</span>(<span class="params">isSupport, element, event, handler</span>) </span>&#123;</span><br><span class="line">    isSupport = isSupport || <span class="built_in">document</span>.addEventListener;</span><br><span class="line">    <span class="keyword">if</span> (isSupport) &#123;</span><br><span class="line">        <span class="keyword">return</span> element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> element.attachEvent(<span class="string">&#x27;on&#x27;</span> + event, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在做项目的过程中，封装一些dom操作可以说再常见不过，上面第一种写法也是比较常见，但是我们看看第二种写法，它相对一第一种写法就是自执行然后返回一个新的函数，这样其实就是提前确定了会走哪一个方法，避免每次都进行判断。</p>
<h5 id="3-延迟运行"><a href="#3-延迟运行" class="headerlink" title="3. 延迟运行"></a>3. 延迟运行</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像我们js中经常使用的bind，实现的机制就是Currying.<br>说了这几点好处之后，发现还有个问题，难道每次使用Currying都要对底层函数去做修改，</p>
<h3 id="有没有什么通用的封装方法？"><a href="#有没有什么通用的封装方法？" class="headerlink" title="有没有什么通用的封装方法？"></a>有没有什么通用的封装方法？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初步封装</span><br><span class="line">var currying = function(fn) &#123;</span><br><span class="line">    // args 获取第一个方法内的全部参数</span><br><span class="line">    var args = Array.prototype.slice.call(arguments, 1)</span><br><span class="line">    return function() &#123;</span><br><span class="line">        // 将后面方法里的全部参数和args进行合并</span><br><span class="line">        var newArgs = args.concat(Array.prototype.slice.call(arguments))</span><br><span class="line">        // 把合并后的参数通过apply作为fn的参数并执行</span><br><span class="line">        return fn.apply(this, newArgs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边首先是初步封装,通过闭包把初步参数给保存下来，然后通过获取剩下的arguments进行拼接，最后执行需要currying的函数。<br>但是好像还有些什么缺陷，这样返回的话其实只能多扩展一个参数，currying(a)(b)(c)这样的话，貌似就不支持了（不支持多参数调用），一般这种情况都会想到使用递归再进行封装一层。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持多参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">progressCurrying</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">var</span> len = fn.length;</span><br><span class="line">    <span class="keyword">var</span> args = args || [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="built_in">Array</span>.prototype.push.apply(args, _args);</span><br><span class="line">        <span class="comment">// 如果参数个数小于最初的fn.length，则递归调用，继续收集参数</span></span><br><span class="line">        <span class="keyword">if</span> (_args.length &lt; len) &#123;</span><br><span class="line">            <span class="keyword">return</span> progressCurrying.call(_this, fn, _args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 参数收集完毕，则执行fn</span></span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, _args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边其实是在初步的基础上，加上了递归的调用，只要参数个数小于最初的fn.length，就会继续执行递归。</p>
<h2 id="好处说完了，通用方法也有了，让我们来关注下curry的性能"><a href="#好处说完了，通用方法也有了，让我们来关注下curry的性能" class="headerlink" title="好处说完了，通用方法也有了，让我们来关注下curry的性能"></a>好处说完了，通用方法也有了，让我们来关注下curry的性能</h2><p>curry的一些性能问题你只要知道下面四点就差不多了：</p>
<ul>
<li>存取arguments对象通常要比存取命名参数要慢一点</li>
<li>一些老版本的浏览器在arguments.length的实现上是相当慢的</li>
<li>使用fn.apply( … ) 和 fn.call( … )通常比直接调用fn( … ) 稍微慢点</li>
<li>创建大量嵌套作用域和闭包函数会带来花销，无论是在内存还是速度上</li>
</ul>
<p>其实在大部分应用中，主要的性能瓶颈是在操作DOM节点上，这js的性能损耗基本是可以忽略不计的，所以curry是可以直接放心的使用。</p>
<h3 id="最后再扩展一道经典面试题"><a href="#最后再扩展一道经典面试题" class="headerlink" title="最后再扩展一道经典面试题"></a>最后再扩展一道经典面试题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个add方法，使计算结果能够满足如下预期：</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) = <span class="number">6</span>;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>) = <span class="number">10</span>;</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) = <span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span></span><br><span class="line">    <span class="keyword">var</span> _args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></span><br><span class="line">    <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _args.push(...arguments);</span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></span><br><span class="line">    _adder.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _adder;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)                <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>)             <span class="comment">// 10</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)          <span class="comment">// 15</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">6</span>)(<span class="number">1</span>)                <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<h3 id="参考的资料"><a href="#参考的资料" class="headerlink" title="参考的资料"></a>参考的资料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2013/02/js-currying/">https://www.zhangxinxu.com/wordpress/2013/02/js-currying/</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/58b316d78d6d810058678579">https://juejin.im/entry/58b316d78d6d810058678579</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.jobbole.com/77956/">http://blog.jobbole.com/77956/</a></li>
<li><a target="_blank" rel="noopener" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh/%E6%9F%AF%E9%87%8C%E5%8C%96">https://zh.wikipedia.org/zh/%E6%9F%AF%E9%87%8C%E5%8C%96</a></li>
</ul>
<h2 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h2><p><img src="http://images.pingan8787.com/2019_07_12guild_page.png" alt="2019_07_12guild_page"></p>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#105;&#110;&#103;&#x61;&#110;&#x38;&#55;&#x38;&#x37;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d;">&#x70;&#105;&#110;&#103;&#x61;&#110;&#x38;&#55;&#x38;&#x37;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>JS小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/25/185-%E3%80%90JavaScript%E3%80%91%E8%AF%A6%E8%A7%A3JS%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/" data-id="ckts3ejtu004u4d9k6mmras3y" data-title="185-【JavaScript】详解JS函数柯里化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-184-【Webpack】Webpack4之TreeShaking终极优化指南" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/22/184-%E3%80%90Webpack%E3%80%91Webpack4%E4%B9%8BTreeShaking%E7%BB%88%E6%9E%81%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/" class="article-date">
  <time class="dt-published" datetime="2019-11-22T15:40:03.000Z" itemprop="datePublished">2019-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/22/184-%E3%80%90Webpack%E3%80%91Webpack4%E4%B9%8BTreeShaking%E7%BB%88%E6%9E%81%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/">184-【Webpack】Webpack4之TreeShaking终极优化指南</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>几个月前，我的任务是将我们组的 Vue.js 项目构建配置升级到 Webpack 4。我们的主要目标之一是利用 tree-shaking 的优势，即 Webpack 去掉了实际上并没有使用的代码来减少包的大小。现在，tree-shaking 的好处将根据你的代码库而有所不同。由于我们的几个架构决策，我们从公司内部的其他库中提取了大量代码，而我们只使用了其中的一小部分。<br />我写这篇文章是因为恰当地优化 Webpack 并不简单。一开始我以为这是一种简单的魔法，但后来我花了一个月的时间在网上搜索我遇到的一系列问题的答案。我希望通过这篇文章，其他人会更容易地处理类似问题。<br><a name="iZe41"></a></p>
<h3 id="先说好处"><a href="#先说好处" class="headerlink" title="先说好处"></a>先说好处</h3><p>在讨论技术细节之前，让我先总结一下好处。不同的应用程序将看到不同程度的好处。主要的决定因素是应用程序中死代码的数量。如果你没有多少死代码，那么你就看不到 tree-shaking 的多少好处。我们项目里有<strong>很多</strong>死代码。<br />在我们部门，最大的问题是共享库的数量。从简单的自定义组件库，到企业标准组件库，再到莫名其妙地塞到一个库中的大量代码。很多都是技术债务，但一个大问题是我们所有的应用程序都在导入所有这些库，而实际上每个应用程序都只需要其中的一小部分<br />总的来说，一旦实现了 tree-shaking，我们的应用程序就会根据应用程序的不同，缩减率从25%到75%。平均缩减率为52%，主要是由这些庞大的共享库驱动的，它们是小型应用程序中的主要代码。<br />同样，具体情况会有所不同，但是如果你觉得你打的包中可能有很多不需要的代码，这就是如何消除它们的方法。<br><a name="ZHOjn"></a></p>
<h3 id="没有示例代码仓库"><a href="#没有示例代码仓库" class="headerlink" title="没有示例代码仓库"></a>没有示例代码仓库</h3><p>对不住了各位老铁，我做的项目是公司的财产，所以我不能分享代码到 GitHub 仓库了。但是，我将在本文中提供简化的代码示例来说明我的观点。<br />因此，废话少说，让我们来看看如何编写可实现 tree-shaking 的最佳 webpack 4 配置。<br><a name="a4qq7"></a></p>
<h3 id="什么是死代码"><a href="#什么是死代码" class="headerlink" title="什么是死代码"></a>什么是死代码</h3><p>很简单：就是 Webpack 没看到你使用的代码。Webpack 跟踪整个应用程序的 import/export 语句，因此，如果它看到导入的东西最终没有被使用，它会认为那是“死代码”，并会对其进行 tree-shaking 。<br />死代码并不总是那么明确的。下面是一些死代码和“活”代码的例子，希望能让你更明白。请记住，在某些情况下，Webpack 会将某些东西视为死代码，尽管它实际上并不是。请参阅《副作用》一节，了解如何处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入并赋值给 JavaScript 对象，然后在下面的代码中被用到</span></span><br><span class="line"><span class="comment">// 这会被看作“活”代码，不会做 tree-shaking</span></span><br><span class="line"><span class="keyword">import</span> Stuff <span class="keyword">from</span> <span class="string">&#x27;./stuff&#x27;</span>;</span><br><span class="line">doSomething(Stuff);</span><br><span class="line"><span class="comment">// 导入并赋值给 JavaScript 对象，但在接下来的代码里没有用到</span></span><br><span class="line"><span class="comment">// 这就会被当做“死”代码，会被 tree-shaking</span></span><br><span class="line"><span class="keyword">import</span> Stuff <span class="keyword">from</span> <span class="string">&#x27;./stuff&#x27;</span>;</span><br><span class="line">doSomething();</span><br><span class="line"><span class="comment">// 导入但没有赋值给 JavaScript 对象，也没有在代码里用到</span></span><br><span class="line"><span class="comment">// 这会被当做“死”代码，会被 tree-shaking</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./stuff&#x27;</span>;</span><br><span class="line">doSomething();</span><br><span class="line"><span class="comment">// 导入整个库，但是没有赋值给 JavaScript 对象，也没有在代码里用到</span></span><br><span class="line"><span class="comment">// 非常奇怪，这竟然被当做“活”代码，因为 Webpack 对库的导入和本地代码导入的处理方式不同。</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;my-lib&#x27;</span>;</span><br><span class="line">doSomething();</span><br></pre></td></tr></table></figure>
<p><a name="zUp5I"></a></p>
<h3 id="用支持-tree-shaking-的方式写-import"><a href="#用支持-tree-shaking-的方式写-import" class="headerlink" title="用支持 tree-shaking 的方式写 import"></a>用支持 tree-shaking 的方式写 import</h3><p>在编写支持 tree-shaking 的代码时，导入方式非常重要。你应该避免将整个库导入到单个 JavaScript 对象中。当你这样做时，你是在告诉 Webpack 你需要整个库， Webpack 就不会摇它。<br />以流行的库 Lodash 为例。一次导入整个库是一个很大的错误，但是导入单个的模块要好得多。当然，Lodash 还需要其他的步骤来做 tree-shaking，但这是个很好的起点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部导入 (不支持 tree-shaking)</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="comment">// 具名导入(支持 tree-shaking)</span></span><br><span class="line"><span class="keyword">import</span> &#123; debounce &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="comment">// 直接导入具体的模块 (支持 tree-shaking)</span></span><br><span class="line"><span class="keyword">import</span> debounce <span class="keyword">from</span> <span class="string">&#x27;lodash/lib/debounce&#x27;</span>;j</span><br></pre></td></tr></table></figure>
<p><a name="jtO7g"></a></p>
<h3 id="基本的-Webpack-配置"><a href="#基本的-Webpack-配置" class="headerlink" title="基本的 Webpack 配置"></a>基本的 Webpack 配置</h3><p>使用 Webpack 进行 tree-shaking 的第一步是编写 Webpack 配置文件。你可以对你的 webpack 做很多自定义配置，但是如果你想要对代码进行 tree-shaking，就需要以下几项。<br />首先，你必须处于生产模式。Webpack 只有在压缩代码的时候会 tree-shaking，而这只会发生在生产模式中。<br />其次，必须将优化选项 “usedExports” 设置为true。这意味着 Webpack 将识别出它认为没有被使用的代码，并在最初的打包步骤中给它做标记。<br />最后，你需要使用一个支持删除死代码的压缩器。这种压缩器将识别出 Webpack 是如何标记它认为没有被使用的代码，并将其剥离。TerserPlugin 支持这个功能，推荐使用。<br />下面是 Webpack 开启 tree-shaking 的基本配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base Webpack Config for Tree Shaking</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"> <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line"> <span class="attr">optimization</span>: &#123;</span><br><span class="line">  <span class="attr">usedExports</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">minimizer</span>: [</span><br><span class="line">   <span class="keyword">new</span> TerserPlugin(&#123;...&#125;)</span><br><span class="line">  ]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;j</span><br></pre></td></tr></table></figure>
<p><a name="ZFNp9"></a></p>
<h3 id="有什么副作用"><a href="#有什么副作用" class="headerlink" title="有什么副作用"></a>有什么副作用</h3><p>仅仅因为 Webpack 看不到一段正在使用的代码，并不意味着它可以安全地进行 tree-shaking。有些模块导入，只要被引入，就会对应用程序产生重要的影响。一个很好的例子就是全局样式表，或者设置全局配置的JavaScript 文件。<br />Webpack 认为这样的文件有“副作用”。具有副作用的文件不应该做 tree-shaking，因为这将破坏整个应用程序。Webpack 的设计者清楚地认识到不知道哪些文件有副作用的情况下打包代码的风险，因此默认地将所有代码视为有副作用。这可以保护你免于删除必要的文件，但这意味着 Webpack 的默认行为实际上是不进行 tree-shaking。<br />幸运的是，我们可以配置我们的项目，告诉 Webpack 它是没有副作用的，可以进行 tree-shaking。<br><a name="dqoWY"></a></p>
<h3 id="如何告诉-Webpack-你的代码无副作用"><a href="#如何告诉-Webpack-你的代码无副作用" class="headerlink" title="如何告诉 Webpack 你的代码无副作用"></a>如何告诉 Webpack 你的代码无副作用</h3><p><code>package.json</code> 有一个特殊的属性 <code>sideEffects</code>，就是为此而存在的。它有三个可能的值：<br /><code>true</code> 是默认值，如果不指定其他值的话。这意味着所有的文件都有副作用，也就是没有一个文件可以 tree-shaking。<br /><code>false</code> 告诉 Webpack 没有文件有副作用，所有文件都可以 tree-shaking。<br />第三个值 <code>[…]</code> 是文件路径数组。它告诉 webpack，除了数组中包含的文件外，你的任何文件都没有副作用。因此，除了指定的文件之外，其他文件都可以安全地进行 tree-shaking。<br />每个项目都必须将 <code>sideEffects</code> 属性设置为 <code>false</code> 或文件路径数组。在我公司的工作中，我们的基本应用程序和我提到的所有共享库都需要正确配置 <code>sideEffects</code> 标志。<br />下面是 <code>sideEffects</code> 标志的一些代码示例。尽管有 JavaScript 注释，但这是 JSON 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有文件都有副作用，全都不可 tree-shaking</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;sideEffects&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有文件有副作用，全都可以 tree-shaking</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;sideEffects&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有这些文件有副作用，所有其他文件都可以 tree-shaking，但会保留这些文件</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;sideEffects&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;./src/file1.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;./src/file2.js&quot;</span></span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="QH32d"></a></p>
<h3 id="全局-CSS-与副作用"><a href="#全局-CSS-与副作用" class="headerlink" title="全局 CSS 与副作用"></a>全局 CSS 与副作用</h3><p>首先，让我们在这个上下文中定义全局 CSS。全局 CSS 是直接导入到 JavaScript 文件中的样式表(可以是CSS、SCSS等)。它没有被转换成 CSS 模块或任何类似的东西。基本上，import 语句是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入全局 CSS</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./MyStylesheet.css&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>因此，如果你做了上面提到的副作用更改，那么在运行 webpack 构建时，你将立即注意到一个棘手的问题。以上述方式导入的任何样式表现在都将从输出中删除。这是因为这样的导入被 webpack 视为死代码，并被删除。<br />幸运的是，有一个简单的解决方案可以解决这个问题。Webpack 使用它的模块规则系统来控制各种类型文件的加载。每种文件类型的每个规则都有自己的 <code>sideEffects</code> 标志。这会覆盖之前为匹配规则的文件设置的所有 <code>sideEffects</code> 标志。<br />所以，为了保留全局 CSS 文件，我们只需要设置这个特殊的 <code>sideEffects</code> 标志为 <code>true</code>，就像这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局 CSS 副作用规则相关的 Webpack 配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"> <span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/regex/</span>,</span><br><span class="line">    use: [loaders],</span><br><span class="line">    <span class="attr">sideEffects</span>: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Webpack 的所有模块规则上都有这个属性。处理全局样式表的规则必须用上它，包括但不限于 CSS/SCSS/LESS/等等。<br><a name="t8VVx"></a></p>
<h3 id="什么是模块，模块为什么重要"><a href="#什么是模块，模块为什么重要" class="headerlink" title="什么是模块，模块为什么重要"></a>什么是模块，模块为什么重要</h3><p>现在我们开始进入秘境。表面上看，编译出正确的模块类型似乎是一个简单的步骤，但是正如下面几节将要解释的，这是一个会导致许多复杂问题的领域。这是我花了很长时间才弄明白的部分。<br />首先，我们需要了解一下模块。多年来，JavaScript 已经发展出了在文件之间以“模块”的形式有效导入/导出代码的能力。有许多不同的 JavaScript 模块标准已经存在了多年，但是为了本文的目的，我们将重点关注两个标准。一个是 “commonjs”，另一个是 “es2015”。下面是它们的代码形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commonjs</span></span><br><span class="line"><span class="keyword">const</span> stuff = <span class="built_in">require</span>(<span class="string">&#x27;./stuff&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = stuff;</span><br><span class="line"><span class="comment">// es2015 </span></span><br><span class="line"><span class="keyword">import</span> stuff <span class="keyword">from</span> <span class="string">&#x27;./stuff&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> stuff;</span><br></pre></td></tr></table></figure>
<p>默认情况下，Babel 假定我们使用 es2015 模块编写代码，并转换 JavaScript 代码以使用 commonjs 模块。这样做是为了与服务器端 JavaScript 库的广泛兼容性，这些 JavaScript 库通常构建在 NodeJS 之上(NodeJS 只支持 commonjs 模块)。但是，Webpack <strong>不支持</strong>使用 commonjs 模块来完成 tree-shaking。<br />现在，有一些插件(如 common-shake-plugin)声称可以让 Webpack 有能力对 commonjs 模块进行 tree-shaking，但根据我的经验，这些插件要么不起作用，要么在 es2015 模块上运行时，对 tree-shaking 的影响微乎其微。我不推荐这些插件。<br />因此，为了进行 tree-shaking，我们需要将代码编译到 es2015 模块。<br><a name="BGrtU"></a></p>
<h3 id="es2015-模块-Babel-配置"><a href="#es2015-模块-Babel-配置" class="headerlink" title="es2015 模块 Babel 配置"></a>es2015 模块 Babel 配置</h3><p>据我所知，Babel 不支持将其他模块系统编译成 es2015 模块。但是，如果你是前端开发人员，那么你可能已经在使用 es2015 模块编写代码了，因为这是全面推荐的方法。<br />因此，为了让我们编译的代码使用 es2015 模块，我们需要做的就是告诉 babel 不要管它们。为了实现这一点，我们只需将以下内容添加到我们的 babel.config.js 中(在本文中，你会看到我更喜欢JavaScript 配置而不是 JSON 配置)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es2015 模块的基本 Babel 配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"> <span class="attr">presets</span>: [</span><br><span class="line">  [</span><br><span class="line">   <span class="string">&#x27;[@babel/preset-env](http://twitter.com/babel/preset-env)&#x27;</span>,</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">modules</span>: <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>把 <code>modules</code> 设置为 <code>false</code>，就是告诉 babel 不要编译模块代码。这会让 Babel 保留我们现有的 es2015 import/export 语句。<br /><strong>划重点：</strong>所有可需要 tree-shaking 的代码必须以这种方式编译。因此，如果你有要导入的库，则必须将这些库编译为 es2015 模块以便进行 tree-shaking 。如果它们被编译为 commonjs，那么它们就不能做 tree-shaking ，并且将会被打包进你的应用程序中。许多库支持部分导入，lodash 就是一个很好的例子，它本身是 commonjs 模块，但是它有一个 lodash-es 版本，用的是 es2015模块。<br />此外，如果你在应用程序中使用内部库，也必须使用 es2015 模块编译。为了减少应用程序包的大小，必须将所有这些内部库修改为以这种方式编译。<br><a name="JaINI"></a></p>
<h3 id="不好意思，-Jest-罢工了"><a href="#不好意思，-Jest-罢工了" class="headerlink" title="不好意思， Jest 罢工了"></a>不好意思， Jest 罢工了</h3><p>其他测试框架情况类似，我们用的是 Jest。<br />不管怎么样，如果你走到了这一步，你会发现 Jest 测试开始失败了。你会像我当时一样，看到日志里出现各种奇怪的错误，慌的一批。别慌，我会带你一步一步解决。<br />出现这个结果的原因很简单：NodeJS。Jest 是基于 NodeJS 开发的，而 NodeJS 不支持 es2015 模块。为此有一些方法可以配置 Node，但是在 jest 上行不通。因此，我们卡在这里了：Webpack 需要 es2015 进行 tree shaking，但是 Jest 无法在这些模块上执行测试。<br />就是为什么我说进入了模块系统的“秘境”。这是整个过程中耗费我最多时间来搞清楚的部分。建议你仔细阅读这一节和后面几节，因为我会给出解决方案。<br />解决方案有两个主要部分。第一部分针对项目本身的代码，也就是跑测试的代码。这部分比较容易。第二部分针对库代码，也就是来自其他项目，被编译成 es2015 模块并引入到当前项目的代码。这部分比较复杂。<br><a name="7gWI4"></a></p>
<h3 id="解决项目本地-Jest-代码"><a href="#解决项目本地-Jest-代码" class="headerlink" title="解决项目本地 Jest 代码"></a>解决项目本地 Jest 代码</h3><p>针对我们的问题，babel 有一个很有用的特性：环境选项。通过配置可以运行在不同环境。在这里，开发和生产环境我们需要 es2015 模块，而测试环境需要 commonjs 模块。还好，Babel 配置起来非常容易：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分环境配置Babel </span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"> <span class="attr">env</span>: &#123;</span><br><span class="line">  <span class="attr">development</span>: &#123;</span><br><span class="line">   <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">     <span class="string">&#x27;[@babel/preset-env](http://twitter.com/babel/preset-env)&#x27;</span>,</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="attr">modules</span>: <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">    ]</span><br><span class="line">   ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">production</span>: &#123;</span><br><span class="line">   <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">     <span class="string">&#x27;[@babel/preset-env](http://twitter.com/babel/preset-env)&#x27;</span>,</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="attr">modules</span>: <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">    ]</span><br><span class="line">   ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">test</span>: &#123;</span><br><span class="line">   <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">     <span class="string">&#x27;[@babel/preset-env](http://twitter.com/babel/preset-env)&#x27;</span>,</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="attr">modules</span>: <span class="string">&#x27;commonjs&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line">    ]</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="string">&#x27;transform-es2015-modules-commonjs&#x27;</span> <span class="comment">// Not sure this is required, but I had added it anyway</span></span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设置好之后，所有的项目本地代码能够正常编译，Jest 测试能运行了。但是，使用 es2015 模块的第三方库代码依然不能运行。<br><a name="xqai7"></a></p>
<h3 id="解决-Jest-中的库代码"><a href="#解决-Jest-中的库代码" class="headerlink" title="解决 Jest 中的库代码"></a>解决 Jest 中的库代码</h3><p>库代码运行出错的原因非常明显，看一眼node_modules 目录就明白了。这里的库代码用的是 es2015 模块语法，为了进行 tree-shaking。这些库已经采用这种方式编译过了，因此当 Jest 在单元测试中试图读取这些代码时，就炸了。注意到没有，我们已经让 Babel 在测试环境中启用 commonjs 模块了呀，为什么对这些库不起作用呢？这是因为，Jest (尤其是 babel-jest) 在跑测试之前编译代码的时候，默认忽略任何来自node_modules 的代码。<br />这实际上是件好事。如果 Jest 需要重新编译所有库的话，将会大大增加测试处理时间。然而，虽然我们不想让它重新编译所有代码，但我们希望它重新编译使用 es2015 模块的库，这样才能在单元测试里使用。<br />幸好，Jest 在它的配置中为我们提供了解决方案。我想说，这部分确实让我想了很久，并且我感觉没必要搞得这么复杂，但这是我能想到的唯一解决方案。<br><a name="76QgG"></a></p>
<h3 id="配置-Jest-重新编译库代码"><a href="#配置-Jest-重新编译库代码" class="headerlink" title="配置 Jest 重新编译库代码"></a>配置 Jest 重新编译库代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新编译库代码的 Jest 配置 </span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> librariesToRecompile = [</span><br><span class="line"> <span class="string">&#x27;Library1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Library2&#x27;</span></span><br><span class="line">].join(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"> <span class="attr">transformIgnorePatterns</span>: [</span><br><span class="line">  <span class="string">`[\\\/]node_modules[\\\/](?!(<span class="subst">$&#123;librariesToRecompile&#125;</span>)).*$`</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">transform</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;^.+\.jsx?$&#x27;</span>: path.resolve(__dirname, <span class="string">&#x27;transformer.js&#x27;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上配置是 Jest 重新编译你的库所需要的。有两个主要部分，我会一一解释。<br /><code>transformIgnorePatterns</code> 是 Jest 配置的一个功能，它是一个正则字符串数组。任何匹配这些正则表达式的代码，都不会被 babel-jest 重新编译。默认是一个字符串“node_modules”。这就是为什么Jest 不会重新编译任何库代码。<br />当我们提供了自定义配置，就是告诉 Jest 重新编译的时候如何忽略代码。也就是为什么你刚才看到的变态的正则表达式有一个负向先行断言在里面，目的是为了匹配除了库以外的所有代码。换句话说，我们告诉 Jest 忽略 node_modules 中除了指定库之外的所有代码。<br />这又一次证明了 JavaScript 配置比 JSON 配置要好，因为我可以轻松地通过字符串操作，往正则表达式里插入库名字的数组拼接。<br />第二个是 transform 配置，他指向一个自定义的 babel-jest 转换器。我不敢100%确定这个是必须的，但我还是加上了。设置它用于在重新编译所有代码时加载我们的 Babel 配置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Babel-Jest 转换器</span></span><br><span class="line"><span class="keyword">const</span> babelJest = <span class="built_in">require</span>(<span class="string">&#x27;babel-jest&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cwd = process.cwd();</span><br><span class="line"><span class="keyword">const</span> babelConfig = <span class="built_in">require</span>(path.resolve(cwd, <span class="string">&#x27;babel.config&#x27;</span>));</span><br><span class="line"><span class="built_in">module</span>.exports = babelJest.createTransformer(babelConfig);</span><br></pre></td></tr></table></figure>
<p>这些都配置好后，你在测试代码应该又能跑了。记住了，任何使用库的 es2015 模块都需要这样配置，不然测试代码跑不动。<br><a name="MvK5l"></a></p>
<h3 id="Npm-Yarn-Link-就是魔鬼"><a href="#Npm-Yarn-Link-就是魔鬼" class="headerlink" title="Npm/Yarn Link 就是魔鬼"></a>Npm/Yarn Link 就是魔鬼</h3><p>接下来轮到另一个痛点了：链接库。使用 npm/yarn 链接的过程就是创建一个指向本地项目目录的符号链接。结果表明，Babel 在重新编译通过这种方式链接的库时，会抛出很多错误。我之所以花了这么长时间才弄清楚 Jest 这档子事儿，原因之一就是我一直通过这种方式链接我的库，出现了一堆错误。<br />解决办法就是：<strong>不要</strong>使用 npm/yarn link。用类似 “yalc” 这样的工具，它可以连接本地项目，同时能模拟正常的 npm 安装过程。它不但没有 Babel 重编译的问题，还能更好地处理传递性依赖。<br><a name="AmlhP"></a></p>
<h3 id="针对特定库的优化。"><a href="#针对特定库的优化。" class="headerlink" title="针对特定库的优化。"></a>针对特定库的优化。</h3><p>如果完成了以上所有步骤，你的应用基本上实现了比较健壮的 tree shaking。不过，为了进一步减少文件包大小，你还可以做一些事情。我会列举一些特定库的优化方法，但这绝对不是全部。它尤其能为我们提供灵感，做出一些更酷的事情。<br />MomentJS 是出了名的大体积库。幸好它可以剔除多语言包来减少体积。在下面的代码示例中，我排除了 momentjs 所有的多语言包，只保留了基本部分，体积明显小了很多。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 IgnorePlugin 移除多语言包</span></span><br><span class="line"><span class="keyword">const</span> &#123; IgnorePlugin &#125; <span class="keyword">from</span> <span class="string">&#x27;webpack&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"> <span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> IgnorePlugin(<span class="regexp">/^\.\/locale$/</span>, <span class="regexp">/moment/</span>)</span><br><span class="line"> ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Moment-Timezone 是 MomentJS 的老表，也是个大块头。它的体积基本上是一个带有时区信息的超大 JSON 文件导致的。我发现只要保留本世纪的年份数据，就可以将体积缩小90%。这种情况需要用到一个特殊的 Webpack 插件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MomentTimezone Webpack Plugin</span></span><br><span class="line"><span class="keyword">const</span> MomentTimezoneDataPlugin = <span class="built_in">require</span>(<span class="string">&#x27;moment-timezone-data-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"> <span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> MomentTimezoneDataPlugin(&#123;</span><br><span class="line">   <span class="attr">startYear</span>: <span class="number">2018</span>,</span><br><span class="line">   <span class="attr">endYear</span>: <span class="number">2100</span></span><br><span class="line">  &#125;)</span><br><span class="line"> ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Lodash 是另一个导致文件包膨胀的大块头。幸好有一个替代包 Lodash-es，它被编译成 es2015 模块，并带有 sideEffects 标志。用它替换 Lodash 可以进一步缩减包的大小。<br />另外，Lodash-es，react-bootstrap 以及其他库可以在 Babel transform imports 插件的帮助下实现瘦身。该插件从库的 index.js 文件读取 import 语句，并使其指向库中特定文件。这样就使 webpack 在解析模块树时更容易对库做 tree shaking。下面的例子演示了它是如何工作的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Babel Transform Imports</span></span><br><span class="line"><span class="comment">// Babel config</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"> <span class="attr">plugins</span>: [</span><br><span class="line">  [</span><br><span class="line">   <span class="string">&#x27;transform-imports&#x27;</span>,</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&#x27;lodash-es&#x27;</span>: &#123;</span><br><span class="line">     <span class="attr">transform</span>: <span class="string">&#x27;lodash/$&#123;member&#125;&#x27;</span>,</span><br><span class="line">     <span class="attr">preventFullImport</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;react-bootstrap&#x27;</span>: &#123;</span><br><span class="line">     <span class="attr">transform</span>: <span class="string">&#x27;react-bootstrap/es/$&#123;member&#125;&#x27;</span>, <span class="comment">// The es folder contains es2015 module versions of the files</span></span><br><span class="line">     <span class="attr">preventFullImport</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这些库不再支持全量导入，否则会报错</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash-es&#x27;</span>;</span><br><span class="line"><span class="comment">// 具名导入依然支持</span></span><br><span class="line"><span class="keyword">import</span> &#123; debounce &#125; <span class="keyword">from</span> <span class="string">&#x27;loash-es&#x27;</span>;</span><br><span class="line"><span class="comment">// 不过这些具名导入会被babel编译成这样子</span></span><br><span class="line"><span class="comment">// import debounce from &#x27;lodash-es/debounce&#x27;;</span></span><br></pre></td></tr></table></figure>
<p><a name="VyqeG"></a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>全文到此结束。这样的优化可以极大地缩减打包后的大小。随着前端架构开始有了新的方向（比如微前端），保持包大小最优化变得比以往更加重要。希望本文能给那些正在给应用程序做tree shaking的同学带来一些帮助。</p>
<h2 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h2><p><img src="http://images.pingan8787.com/2019_07_12guild_page.png" alt="2019_07_12guild_page"></p>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#105;&#x6e;&#103;&#x61;&#x6e;&#56;&#55;&#x38;&#x37;&#x40;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;">&#x70;&#105;&#x6e;&#103;&#x61;&#x6e;&#56;&#55;&#x38;&#x37;&#x40;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>JS小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/22/184-%E3%80%90Webpack%E3%80%91Webpack4%E4%B9%8BTreeShaking%E7%BB%88%E6%9E%81%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/" data-id="ckts3ejyg00ml4d9kbb2y9mvq" data-title="184-【Webpack】Webpack4之TreeShaking终极优化指南" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-183-【全栈修炼】CORS和CSRF修炼宝典" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/17/183-%E3%80%90%E5%85%A8%E6%A0%88%E4%BF%AE%E7%82%BC%E3%80%91CORS%E5%92%8CCSRF%E4%BF%AE%E7%82%BC%E5%AE%9D%E5%85%B8/" class="article-date">
  <time class="dt-published" datetime="2019-11-17T10:27:32.000Z" itemprop="datePublished">2019-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/17/183-%E3%80%90%E5%85%A8%E6%A0%88%E4%BF%AE%E7%82%BC%E3%80%91CORS%E5%92%8CCSRF%E4%BF%AE%E7%82%BC%E5%AE%9D%E5%85%B8/">183-【全栈修炼】CORS和CSRF修炼宝典</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>CORS 和 CSRF 太容易混淆了，看完本文，你就清楚了。</p>
<h2 id="一、CORS-和-CSRF-区别"><a href="#一、CORS-和-CSRF-区别" class="headerlink" title="一、CORS 和 CSRF 区别"></a>一、CORS 和 CSRF 区别</h2><p>先看下图：</p>
<p><img src="http://images.pingan8787.com/blog/CORS-CSRF-1.png" alt="CORS 和 CSRF 区别"></p>
<p>两者概念完全不同，另外常常我们也会看到 XSS ，这里一起介绍：</p>
<ol>
<li><p><strong>CORS</strong> ： Cross Origin Resourse-Sharing  跨站资源共享</p>
</li>
<li><p><strong>CSRF</strong> ： Cross-Site Request Forgery  跨站请求伪造</p>
</li>
<li><p><strong>XSS</strong> ： Cross Site Scrit 跨站脚本攻击（为与 CSS 区别，所以在安全领域叫 XSS）</p>
</li>
</ol>
<h2 id="二、CORS"><a href="#二、CORS" class="headerlink" title="二、CORS"></a>二、CORS</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><blockquote>
<p>跨来源资源共享（CORS），亦译为跨域资源共享，是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 请求方法以外也支持其他的 HTTP 请求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。<br>—— <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E4%BE%86%E6%BA%90%E8%B3%87%E6%BA%90%E5%85%B1%E4%BA%AB">维基百科</a></p>
</blockquote>
<p><strong>核心知识：</strong> CORS是一个W3C标准，它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code> 请求，从而克服 AJAX 只能同源使用的限制。</p>
<p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信，即为了解决<strong>跨域问题</strong>。</p>
<h3 id="2-CORS-请求类型"><a href="#2-CORS-请求类型" class="headerlink" title="2. CORS 请求类型"></a>2. CORS 请求类型</h3><p>浏览器将 CORS 请求分成两类：<strong>简单请求</strong>（simple request）和<strong>非简单请求</strong>（not-so-simple request）。</p>
<p><strong>简单请求</strong>一般包括下面两种情况：</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>请求方法</td>
<td>请求方法为：<code>HEAD</code> 或 <code>GET</code> 或 <code>POST</code>；</td>
</tr>
<tr>
<td>HTTP 头信息</td>
<td>HTTP 头信息不超出以下几种字段：<code>Accept</code><br/><code>Accept-Language</code><br/><code>Content-Language</code><br/><code>Last-Event-ID</code><br/><code>Content-Type</code>：只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></td>
</tr>
</tbody></table>
<p>凡是不同时满足上面两个条件，就属于<strong>非简单请求</strong>。</p>
<h3 id="3-简单请求的-CORS-流程"><a href="#3-简单请求的-CORS-流程" class="headerlink" title="3. 简单请求的 CORS 流程"></a>3. 简单请求的 CORS 流程</h3><p>当浏览器发现我们的 AJAX 请求是个<strong>简单请求</strong>，便会自动在<strong>头信息</strong>中，增加一个 <code>Origin</code> 字段。</p>
<p><code>Origin</code> 字段用来说明本次请求的来源（包括<strong>协议</strong> + <strong>域名</strong> + <strong>端口号</strong>），服务端根据这个值来决定是否同意此次请求。</p>
<p><img src="http://images.pingan8787.com/blog/CORS-CSRF-2.png" alt="简单请求的 CORS 流程"></p>
<p>当 <code>Origin</code> 指定的源不在许可范围，服务器会返回一个正常的 HTTP 回应，但浏览器会在响应头中发现 <code>Access-Control-Allow-Origin</code> 字段，便抛出异常。</p>
<p>当 <code>Origin</code> 指定的源在许可范围，服务器返回的响应头中会多出几个头信息字段：</p>
<p><img src="http://images.pingan8787.com/blog/CORS-CSRF-3.png" alt="简单请求的 CORS 流程"></p>
<p>除了上面图中的头信息，一般会有以下三个相关头信息：</p>
<ol>
<li><code>Access-Control-Allow-Origin</code></li>
</ol>
<p>该字段是必须的。表示许可范围的域名，通常有两种值：<strong>请求时 Origin 字段的值</strong>或者 <code>*</code>（星号）表示任意域名。</p>
<ol start="2">
<li><code>Access-Control-Allow-Credentials</code></li>
</ol>
<p>该字段可选。布尔值，表示是否允许在 CORS 请求之中发送 <code>Cookie</code> 。若不携带 <code>Cookie</code> 则不需要设置该字段。</p>
<p>当设置为 <code>true</code> 则  <code>Cookie</code> 包含在请求中，一起发送给服务器。还需要在 AJAX 请求中开启 <code>withCredentials</code> 属性，否则浏览器也不会发送 <code>Cookie</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>Access-Control-Expose-Headers</code></li>
</ol>
<p>该字段可选。可以设置需要获取的字段。因为默认 CORS 请求时，<code>XMLHttpRequest</code> 对象的<code>getResponseHeader()</code>方法只能拿到以下 6 个基本字段：</p>
<p><code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。</p>
<h3 id="4-非简单请求的-CORS-流程"><a href="#4-非简单请求的-CORS-流程" class="headerlink" title="4. 非简单请求的 CORS 流程"></a>4. 非简单请求的 CORS 流程</h3><p><strong>非简单请求</strong>情况如：请求方法是 <strong>PUT</strong> / <strong>DELETE</strong> 或者 <code>Content-Type:application/json</code> 类型的请求。</p>
<p>在非简单请求发出 CORS 请求时，会在正式通信之前增加一次 <strong>“预检”请求（OPTIONS方法）</strong>，来询问服务器，本次请求的域名是否在许可名单中，以及使用哪些头信息。</p>
<p>当 <strong>“预检”请求</strong> 通过以后，才会正式发起 AJAX 请求，否则报错。</p>
<h4 id="4-1-预检请求"><a href="#4-1-预检请求" class="headerlink" title="4.1 预检请求"></a>4.1 预检请求</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/cors</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span><span class="punctuation">: </span>PUT</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>“预检”请求</strong> 信息中包含两个特殊字段：</p>
<ol>
<li><code>Access-Control-Request-Method</code></li>
</ol>
<p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 <code>PUT</code>。</p>
<ol start="2">
<li><code>Access-Control-Request-Headers</code></li>
</ol>
<p>指定浏览器 CORS 请求额外发送的头信息字段，上例是 <code>X-Custom-Header</code>。</p>
<h4 id="4-2-预检响应"><a href="#4-2-预检响应" class="headerlink" title="4.2 预检响应"></a>4.2 预检响应</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当预检请求<strong>通过</strong>以后，在预检响应头中，会返回 <code>Access-Control-Allow-</code> 开头的信息，其中 <code>Access-Control-Allow-Origin</code> 表示许可范围，值也可以是 <code>*</code>。</p>
<p>当预检请求<strong>拒绝</strong>以后，在预检响应头中，不会返回 <code>Access-Control-Allow-</code> 开头的信息，并在控制台输出错误信息。</p>
<h2 id="三、CSRF"><a href="#三、CSRF" class="headerlink" title="三、CSRF"></a>三、CSRF</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h3><blockquote>
<p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。<br>—— <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">维基百科</a></p>
</blockquote>
<p><strong>核心知识：</strong> 跨站点请求伪造请求。</p>
<p><strong>简单理解：</strong> 攻击者盗用你的身份，以你的名义发送恶意请求。</p>
<p>常见场景：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账等等。</p>
<p>造成影响：个人隐私泄露以及财产安全。</p>
<h3 id="2-CSRF-攻击流程"><a href="#2-CSRF-攻击流程" class="headerlink" title="2. CSRF 攻击流程"></a>2. CSRF 攻击流程</h3><p><img src="http://images.pingan8787.com/blog/CORS-CSRF-4.png" alt="CSRF 攻击流程"></p>
<p>上面描述了 CSRF 攻击的流程，其中受害者完成两个步骤：</p>
<ol>
<li>登录受信任网站 A ，并在本地生成保存Cookie；</li>
<li>在不登出 A 情况下，访问病毒网站 B；</li>
</ol>
<p>可以理解为：若以上两个步骤没有都完成，则不会受到 CSRF 攻击。</p>
<h3 id="3-服务端防御-CSRF-攻击"><a href="#3-服务端防御-CSRF-攻击" class="headerlink" title="3. 服务端防御 CSRF 攻击"></a>3. 服务端防御 CSRF 攻击</h3><p>服务端防御的方式有很多，思想类似，都是在客户端页面增加<strong>伪随机数</strong>。</p>
<h4 id="3-1-Cookie-Hashing（所有表单都包含同一个伪随机数）"><a href="#3-1-Cookie-Hashing（所有表单都包含同一个伪随机数）" class="headerlink" title="3.1 Cookie Hashing（所有表单都包含同一个伪随机数）"></a>3.1 Cookie Hashing（所有表单都包含同一个伪随机数）</h4><p>最简单有效方式，因为攻击者理论上无法获取第三方的Cookie，所以表单数据伪造失败。以 php 代码为例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">//构造加密的Cookie信息</span></span><br><span class="line">    <span class="variable">$value</span> = <span class="string">&quot;LeoDefenseSCRF&quot;</span>;</span><br><span class="line">    setcookie(<span class="string">&quot;cookie&quot;</span>, <span class="variable">$value</span>, time()+<span class="number">3600</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在表单里增加Hash值，以认证这确实是用户发送的请求。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$hash</span> = md5(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;cookie&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;form method=<span class="string">&quot;POST&quot;</span> action=<span class="string">&quot;transfer.php&quot;</span>&gt;</span><br><span class="line">　　&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;toBankId&quot;</span>&gt;</span><br><span class="line">　　&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;money&quot;</span>&gt;</span><br><span class="line">　　&lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;hash&quot;</span> value=<span class="string">&quot;&lt;?=<span class="subst">$hash</span>;?&gt;&quot;</span>&gt;</span><br><span class="line">　　&lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>然后在服务器端进行Hash值验证。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;check&#x27;</span>])) &#123;</span><br><span class="line">　　     <span class="variable">$hash</span> = md5(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;cookie&#x27;</span>]);</span><br><span class="line">    　　 <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;check&#x27;</span>] == <span class="variable">$hash</span>) &#123;</span><br><span class="line">            doJob();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　<span class="comment">//...</span></span><br><span class="line">    　　&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个方法个人觉得已经<strong>可以杜绝99%的CSRF攻击了</strong>，那还有1%呢….由于用户的 Cookie 很容易由于网站的 XSS 漏洞而被盗取，这就另外的1%。</p>
<p>一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。</p>
<h4 id="3-2-验证码"><a href="#3-2-验证码" class="headerlink" title="3.2 验证码"></a>3.2 验证码</h4><p>思路是：每次用户提交都需要用户在表单中填写一个图片上的随机字符串，这个方案可以完全解决CSRF，但易用性差，并且验证码图片的使用涉及 MHTML 的Bug，可能在某些版本的微软IE中受影响。</p>
<h4 id="3-3-One-Time-Tokens-不同的表单包含一个不同的伪随机值"><a href="#3-3-One-Time-Tokens-不同的表单包含一个不同的伪随机值" class="headerlink" title="3.3 One-Time Tokens(不同的表单包含一个不同的伪随机值)"></a>3.3 One-Time Tokens(不同的表单包含一个不同的伪随机值)</h4><p>需要注意“<strong>并行会话的兼容</strong>”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。</p>
<p>php 实现如下：</p>
<ol>
<li>先是 <code>Token</code> 令牌生成函数(<code>gen_token()</code>)和 <code>Session</code> 令牌生成函数(<code>gen_stoken()</code>)：</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">gen_token</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$token</span> = md5(uniqid(rand(), <span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$token</span>;</span><br><span class="line">    &#125;</span><br><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">gen_stoken</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　<span class="variable">$pToken</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">　　　　<span class="keyword">if</span>(<span class="variable">$_SESSION</span>[STOKEN_NAME]  == <span class="variable">$pToken</span>)&#123;</span><br><span class="line">　　　　　　<span class="variable">$_SESSION</span>[STOKEN_NAME] = gen_token();</span><br><span class="line">　　　　&#125;    </span><br><span class="line">　　　　<span class="keyword">else</span>&#123; &#125;</span><br><span class="line">　　&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>WEB表单生成隐藏输入域的函数：　</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">gen_input</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        gen_stoken();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;input type=\&quot;hidden\&quot; name=\&quot;&quot;</span> . FTOKEN_NAME . <span class="string">&quot;\&quot;</span></span><br><span class="line"><span class="string">     　　     value=\&quot;&quot;</span> . <span class="variable">$_SESSION</span>[STOKEN_NAME] . <span class="string">&quot;\&quot;&gt; &quot;</span>;</span><br><span class="line">　　&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>WEB表单结构：</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    session_start();</span><br><span class="line">    <span class="keyword">include</span>(<span class="string">&quot;functions.php&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;form method=<span class="string">&quot;POST&quot;</span> action=<span class="string">&quot;transfer.php&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;toBankId&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;money&quot;</span>&gt;</span><br><span class="line">    <span class="meta">&lt;?</span> gen_input(); <span class="meta">?&gt;</span></span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Submit&quot;</span>&gt;</span><br><span class="line">&lt;/FORM&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>服务端核对令牌</li>
</ol>
<p>这一步很简单，不做详细介绍。</p>
<h2 id="四、XSS"><a href="#四、XSS" class="headerlink" title="四、XSS"></a>四、XSS</h2><p><strong>注意</strong>： 本文简单介绍 XSS 知识，具体详细可以阅读 <strong>FEWY</strong> 写的 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020402185">《跨站脚本攻击—XSS》</a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020402185%E3%80%82">https://segmentfault.com/a/1190000020402185。</a></p>
<h3 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1. 概念"></a>1. 概念</h3><blockquote>
<p>跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。<br>—— <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC">维基百科</a></p>
</blockquote>
<p>XSS 攻击，一般是指攻击者通过在网页中注入恶意脚本，当用户浏览网页时，恶意脚本执行，控制用户浏览器行为的一种攻击方式。</p>
<p>常见 XSS 危害有：</p>
<ul>
<li>窃取用户Cookie，获取用户隐私，盗取用户账号。</li>
<li>劫持用户（浏览器）会话，从而执行任意操作，例如进行非法转账、强制发表日志、发送电子邮件等。</li>
<li>强制弹出广告页面，刷流量，传播跨站脚本蠕虫，网页挂马等。</li>
<li>结合其他漏洞，如 CSRF 漏洞，实施进一步的攻击。</li>
</ul>
<h3 id="2-XSS-分类"><a href="#2-XSS-分类" class="headerlink" title="2. XSS 分类"></a>2. XSS 分类</h3><p><img src="http://images.pingan8787.com/blog/CORS-CSRF-5.png" alt="XSS 分类"></p>
<h3 id="3-XSS-防御"><a href="#3-XSS-防御" class="headerlink" title="3. XSS 防御"></a>3. XSS 防御</h3><h4 id="3-1-方法1：浏览器自带防御-（X-XSS-Protection-）"><a href="#3-1-方法1：浏览器自带防御-（X-XSS-Protection-）" class="headerlink" title="3.1 方法1：浏览器自带防御 （X-XSS-Protection ）"></a>3.1 方法1：浏览器自带防御 （X-XSS-Protection ）</h4><p>现今主流浏览器（Internet Explorer，Chrome 和 Safari）带有 HTTP <code>X-XSS-Protection</code> 响应头，当检测到跨站脚本攻击(XSS)时，浏览器将停止加载页面。</p>
<p><code>X-XSS-Protection</code> 响应头有以下 4 个值：</p>
<ul>
<li><code>X-XSS-Protection: 0</code></li>
</ul>
<p>禁止XSS过滤。     </p>
<ul>
<li><code>X-XSS-Protection: 1</code></li>
</ul>
<p>启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。  </p>
<ul>
<li><code>X-XSS-Protection: 1; mode=block</code></li>
</ul>
<p>启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。  </p>
<ul>
<li><code>X-XSS-Protection: 1; report=&lt;reporting-uri&gt;</code></li>
</ul>
<p>启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。 </p>
<p><strong>注意：</strong></p>
<p>这并不能完全防止反射型 XSS，而且也并不是所有浏览器都支持 <code>X-XSS-Protection</code>，存在兼容性问题。</p>
<p>它只对反射型 XSS 有一定的防御力，其原理也只是检查 URL 和 DOM 中元素的相关性。</p>
<h4 id="3-2-方法2：转义"><a href="#3-2-方法2：转义" class="headerlink" title="3.2 方法2：转义"></a>3.2 方法2：转义</h4><p>即将常用特殊字符进行转义，避免攻击者使用构造特殊字符来注入脚本。需要在客户端和服务端，都对用户输入的数据进行转义。</p>
<p>常见需要转义的特殊字符如 <code>&lt;</code>，<code>&gt;</code>，<code>&amp;</code>，<code>&quot;</code>，<code>&#39;</code>。</p>
<p>转义方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHTML</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>);</span><br><span class="line">    str = str..replace(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>);</span><br><span class="line">    str = str..replace(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line">    str = str..replace(<span class="regexp">/&quot;/g</span>, <span class="string">&quot;&amp;quot;&quot;</span>);</span><br><span class="line">    str = str..replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&quot;&amp;#39;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-方法3：过滤"><a href="#3-3-方法3：过滤" class="headerlink" title="3.3 方法3：过滤"></a>3.3 方法3：过滤</h4><p>常见于富文本内容，因为其需要保留 HTML，所以不能直接使用转义方法，而可以通过使用白名单，来允许特定的 HTML 标签及属性，来抵御 XSS 攻击。</p>
<h4 id="3-4-方法4：内容安全策略（CSP）"><a href="#3-4-方法4：内容安全策略（CSP）" class="headerlink" title="3.4 方法4：内容安全策略（CSP）"></a>3.4 方法4：内容安全策略（CSP）</h4><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/09/csp.html">内容安全策略（Content Security Policy，CSP）</a>，实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，大大增强了网页的安全性。</p>
<p>两种方法可以启用 CSP。</p>
<ol>
<li>通过 HTTP 头信息的 <code>Content-Security-Policy</code> 的字段：</li>
</ol>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span><span class="punctuation">: </span>script-src &#x27;self&#x27;; </span><br><span class="line">                         object-src &#x27;none&#x27;;</span><br><span class="line">                         style-src cdn.example.org third-party.org; </span><br><span class="line">                         child-src https:</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过网页的 <code>&lt;meta&gt;</code> 标签</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; style-src cdn.example.org third-party.org; child-src https:&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，CSP 做了如下配置：</p>
<ul>
<li>脚本： 只信任当前域名</li>
<li><code>&lt;object&gt;</code>标签： 不信任任何 URL，即不加载任何资源</li>
<li>样式表： 只信任 <code>cdn.example.org </code>和<code> third-party.org</code></li>
<li>页面子内容，如 <code>&lt;frame&gt;</code>、<code>&lt;iframe&gt;</code>： 必须使用HTTPS协议加载</li>
<li>其他资源： 没有限制</li>
<li>启用后，不符合 CSP 的外部资源就会被阻止加载。</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="www.ruanyifeng.com/blog/2016/04/cors.html">《跨域资源共享 CORS 详解》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lailailai/p/4528092.html">《CSRF &amp; CORS》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">《浅谈CSRF攻击方式》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020402185">《跨站脚本攻击—XSS》</a></li>
</ol>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><blockquote>
<p>本文首发在 <a target="_blank" rel="noopener" href="http://www.pingan8787.com/">pingan8787个人博客</a>，如需转载请联系本人。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#112;&#105;&#110;&#103;&#x61;&#x6e;&#x38;&#x37;&#56;&#55;&#x40;&#x71;&#x71;&#46;&#99;&#111;&#x6d;">&#112;&#105;&#110;&#103;&#x61;&#x6e;&#x38;&#x37;&#56;&#55;&#x40;&#x71;&#x71;&#46;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>ES小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>
<h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><p><img src="http://images.pingan8787.com/blog/2019_10_24guild_page.png" alt="bg">  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/17/183-%E3%80%90%E5%85%A8%E6%A0%88%E4%BF%AE%E7%82%BC%E3%80%91CORS%E5%92%8CCSRF%E4%BF%AE%E7%82%BC%E5%AE%9D%E5%85%B8/" data-id="ckts3ejtt004r4d9k75ty1j9v" data-title="183-【全栈修炼】CORS和CSRF修炼宝典" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/" rel="tag">全栈开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-182-【JavaScript】JavaScript中的位运算和权限设计" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/12/182-%E3%80%90JavaScript%E3%80%91JavaScript%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%E5%92%8C%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time class="dt-published" datetime="2019-11-12T15:00:46.000Z" itemprop="datePublished">2019-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/12/182-%E3%80%90JavaScript%E3%80%91JavaScript%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%E5%92%8C%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/">182-【JavaScript】JavaScript中的位运算和权限设计</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JavaScript-中的位运算和权限设计"><a href="#JavaScript-中的位运算和权限设计" class="headerlink" title="JavaScript 中的位运算和权限设计"></a>JavaScript 中的位运算和权限设计</h1><p>原文：<a target="_blank" rel="noopener" href="https://juejin.im/post/5dc36f39e51d4529ed292910">JavaScript 中的位运算和权限设计</a></p>
<h2 id="1-内容概要"><a href="#1-内容概要" class="headerlink" title="1. 内容概要"></a>1. 内容概要</h2><p>本文主要讨论以下两个问题：</p>
<ul>
<li><p>JavaScript 的位运算：先简单回顾下位运算，平时用的少，相信不少人和我一样忘的差不多了</p>
</li>
<li><p>权限设计：根据位运算的特点，设计一个权限系统（添加、删除、判断等）</p>
<h2 id="2-JavaScript-位运算"><a href="#2-JavaScript-位运算" class="headerlink" title="2. JavaScript 位运算"></a>2. JavaScript 位运算</h2><h3 id="2-1-Number"><a href="#2-1-Number" class="headerlink" title="2.1. Number"></a>2.1. Number</h3><p>在讲位运算之前，首先简单看下 JavaScript 中的 Number，下文需要用到。<br>在 JavaScript 里，数字均为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8">基于 IEEE 754 标准的双精度 64 位的浮点数</a>，引用维基百科的图片，它的结构长这样：<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/186051/1573570435363-8654c3d6-1978-4722-aa02-07ddad8000ba.webp#align=left&display=inline&height=96&originHeight=96&originWidth=594&search=&size=0&status=done&width=594"></p>
</li>
<li><p>sign bit（符号）: 用来表示正负号</p>
</li>
<li><p>exponent（指数）: 用来表示次方数</p>
</li>
<li><p>mantissa（尾数）: 用来表示精确度</p>
</li>
</ul>
<p>也就是说一个数字的范围只能在 -(2^53 -1) 至 2^53 -1 之间。</p>
<blockquote>
<p>既然讲到这里，就多说一句：0.1 + 0.2 算不准的原因也在于此。浮点数用二进制表达时是无穷的，且最多 53 位，必须截断，进而产生误差。最简单的解决办法就是放大一定倍数变成整数，计算完成后再缩小。不过更稳妥的办法是使用下文将会提到的 <a target="_blank" rel="noopener" href="https://mathjs.org/docs/datatypes/bignumbers.html#roundoff-errors">math.js</a> 等工具库。</p>
</blockquote>
<p>此外还有四种数字进制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 十进制</span><br><span class="line">123456789</span><br><span class="line">0</span><br><span class="line">// 二进制：前缀 0b，0B</span><br><span class="line">0b10000000000000000000000000000000 // 2147483648</span><br><span class="line">0b01111111100000000000000000000000 // 2139095040</span><br><span class="line">0B00000000011111111111111111111111 // 8388607</span><br><span class="line">// 八进制：前缀 0o，0O（以前支持前缀 0）</span><br><span class="line">0o755 // 493</span><br><span class="line">0o644 // 420</span><br><span class="line">// 十六进制：前缀 0x，0X</span><br><span class="line">0xFFFFFFFFFFFFFFFFF // 295147905179352830000</span><br><span class="line">0x123456789ABCDEF   // 81985529216486900</span><br><span class="line">0XA                 // 10</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>好了，Number 就说这么多，接下来看 JavaScript 中的位运算。</p>
<h3 id="2-2-位运算"><a href="#2-2-位运算" class="headerlink" title="2.2. 位运算"></a>2.2. 位运算</h3><p>按位操作符将其操作数当作 32 位的比特序列（由 0 和 1 组成）操作，返回值依然是标准的 JavaScript 数值。JavaScript 中的按位操作符有：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">按位与（AND）</td>
<td align="left"><code>a &amp; b</code></td>
<td align="left">对于每一个比特位，只有两个操作数相应的比特位都是 1 时，结果才为 1，否则为 0。</td>
</tr>
<tr>
<td align="left">按位或（OR）</td>
<td align="left">`a</td>
<td align="left">b`</td>
</tr>
<tr>
<td align="left">按位异或（XOR）</td>
<td align="left"><code>a ^ b</code></td>
<td align="left">对于每一个比特位，当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0。</td>
</tr>
<tr>
<td align="left">按位非（NOT）</td>
<td align="left"><code>~a</code></td>
<td align="left">反转操作数的比特位，即 0 变成 1，1 变成 0。</td>
</tr>
<tr>
<td align="left">左移（Left shift）</td>
<td align="left"><code>a &lt;&lt; b</code></td>
<td align="left">将 a 的二进制形式向左移 b (&lt; 32) 比特位，右边用 0 填充。</td>
</tr>
<tr>
<td align="left">有符号右移</td>
<td align="left"><code>a &gt;&gt; b</code></td>
<td align="left">将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位。</td>
</tr>
<tr>
<td align="left">无符号右移</td>
<td align="left"><code>a &gt;&gt;&gt; b</code></td>
<td align="left">将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位，并使用 0 在左侧填充。</td>
</tr>
</tbody></table>
<p>下面举几个例子，主要看下 <code>AND</code> 和 <code>OR</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 例子1</span><br><span class="line">    A = 10001001</span><br><span class="line">    B = 10010000</span><br><span class="line">A | B = 10011001</span><br><span class="line"># 例子2</span><br><span class="line">    A = 10001001</span><br><span class="line">    C = 10001000</span><br><span class="line">A | C = 10001001</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 例子1</span><br><span class="line">    A = 10001001</span><br><span class="line">    B = 10010000</span><br><span class="line">A &amp; B = 10000000</span><br><span class="line"># 例子2</span><br><span class="line">    A = 10001001</span><br><span class="line">    C = 10001000</span><br><span class="line">A &amp; C = 10001000</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="3-位运算在权限系统中的使用"><a href="#3-位运算在权限系统中的使用" class="headerlink" title="3. 位运算在权限系统中的使用"></a>3. 位运算在权限系统中的使用</h2><p>传统的权限系统里，存在很多关联关系，如用户和权限的关联，用户和角色的关联。系统越大，关联关系越多，越难以维护。而引入位运算，可以巧妙的解决该问题。<br>在讲“位运算在权限系统中的使用”之前，我们先假定两个前提，<strong>下文所有的讨论都是基于这两个前提的</strong>：</p>
<ol>
<li>每种权限码都是唯一的（这是显然的）</li>
<li>所有权限码的二进制数形式，有且只有一位值为 1，其余全部为 0（<code>2^n</code>）</li>
</ol>
<p>如果用户权限和权限码，全部使用二级制数字表示，再结合上面 <code>AND</code> 和 <code>OR</code> 的例子，分析位运算的特点，不难发现：</p>
<ul>
<li><code>|</code> 可以用来赋予权限</li>
<li><code>&amp;</code> 可以用来校验权限</li>
</ul>
<p>为了讲的更明白，这里用 Linux 中的实例分析下，Linux 的文件权限分为读、写和执行，有字母和数字等多种表现形式：</p>
<table>
<thead>
<tr>
<th align="left">权限</th>
<th align="left">字母表示</th>
<th align="left">数字表示</th>
<th align="left">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读</td>
<td align="left">r</td>
<td align="left">4</td>
<td align="left">0b100</td>
</tr>
<tr>
<td align="left">写</td>
<td align="left">w</td>
<td align="left">2</td>
<td align="left">0b010</td>
</tr>
<tr>
<td align="left">执行</td>
<td align="left">x</td>
<td align="left">1</td>
<td align="left">0b001</td>
</tr>
</tbody></table>
<p>可以看到，权限用 1、2、4（也就是 <code>2^n</code>）表示，转换为二进制后，都是只有一位是 1，其余为 0。我们通过几个例子看下，如何利用二进制的特点执行权限的添加，校验和删除。</p>
<h3 id="3-1-添加权限"><a href="#3-1-添加权限" class="headerlink" title="3.1. 添加权限"></a>3.1. 添加权限</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let r = 0b100</span><br><span class="line">let w = 0b010</span><br><span class="line">let x = 0b001</span><br><span class="line">// 给用户赋全部权限（使用前面讲的 | 操作）</span><br><span class="line">let user = r | w | x</span><br><span class="line">console.log(user)</span><br><span class="line">// 7</span><br><span class="line">console.log(user.toString(2))</span><br><span class="line">// 111</span><br><span class="line">//     r = 0b100</span><br><span class="line">//     w = 0b010</span><br><span class="line">//     r = 0b001</span><br><span class="line">// r|w|x = 0b111</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>可以看到，执行 <code>r | w | x</code> 后，<code>user</code> 的三位都是 1，表明拥有了全部三个权限。</p>
<blockquote>
<p>Linux 下出现权限问题时，最粗暴的解决方案就是 <code>chmod 777 xxx</code>，这里的 <code>7</code> 就代表了：可读，可写，可执行。而三个 <code>7</code> 分别代表：文件所有者，文件所有者所在组，所有其他用户。</p>
</blockquote>
<h3 id="3-2-校验权限"><a href="#3-2-校验权限" class="headerlink" title="3.2. 校验权限"></a>3.2. 校验权限</h3><p>刚才演示了权限的添加，下面演示权限校验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let r = 0b100</span><br><span class="line">let w = 0b010</span><br><span class="line">let x = 0b001</span><br><span class="line">// 给用户赋 r w 两个权限</span><br><span class="line">let user = r | w</span><br><span class="line">// user = 6</span><br><span class="line">// user = 0b110 (二进制)</span><br><span class="line">console.log((user &amp; r) === r) // true  有 r 权限</span><br><span class="line">console.log((user &amp; w) === w) // true  有 w 权限</span><br><span class="line">console.log((user &amp; x) === x) // false 没有 x 权限</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>如前所料，通过 <code>用户权限 &amp; 权限 code === 权限 code</code> 就可以判断出用户是否拥有该权限。</p>
<h3 id="3-3-删除权限"><a href="#3-3-删除权限" class="headerlink" title="3.3. 删除权限"></a>3.3. 删除权限</h3><p>我们讲了用 <code>|</code> 赋予权限，使用 <code>&amp;</code> 判断权限，那么删除权限呢？删除权限的本质其实是<strong>将指定位置上的 1 重置为 0</strong>。上个例子里用户权限是 <code>0b110</code>，拥有读和写两个权限，现在想删除读的权限，本质上就是将第三位的 1 重置为 0，变为 <code>0b010</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let r = 0b100</span><br><span class="line">let w = 0b010</span><br><span class="line">let x = 0b001</span><br><span class="line">let user = 0b010;</span><br><span class="line">console.log((user &amp; r) === r) // false 没有 r 权限</span><br><span class="line">console.log((user &amp; w) === w) // true  有 w 权限</span><br><span class="line">console.log((user &amp; x) === x) // false 没有 x 权限</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>那么具体怎么操作呢？其实有两种方案，最简单的就是异或 <code>^</code>，按照上文的介绍“当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0”，所以异或其实是 toggle 操作，无则增，有则减：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let r    = 0b100</span><br><span class="line">let w    = 0b010</span><br><span class="line">let x    = 0b001</span><br><span class="line">let user = 0b110 // 有 r w 两个权限</span><br><span class="line">// 执行异或操作，删除 r 权限</span><br><span class="line">user = user ^ r</span><br><span class="line">console.log((user &amp; r) === r) // false 没有 r 权限</span><br><span class="line">console.log((user &amp; w) === w) // true  有 w 权限</span><br><span class="line">console.log((user &amp; x) === x) // false 没有 x 权限</span><br><span class="line">console.log(user.toString(2)) // 现在 user 是 0b010</span><br><span class="line">// 再执行一次异或操作</span><br><span class="line">user = user ^ r</span><br><span class="line">console.log((user &amp; r) === r) // true  有 r 权限</span><br><span class="line">console.log((user &amp; w) === w) // true  有 w 权限</span><br><span class="line">console.log((user &amp; x) === x) // false 没有 x 权限</span><br><span class="line">console.log(user.toString(2)) // 现在 user 又变回 0b110</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>那么如果单纯的想删除权限（而不是无则增，有则减）怎么办呢？答案是执行 <code>&amp;(~code)</code>，先取反，再执行与操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let r    = 0b100</span><br><span class="line">let w    = 0b010</span><br><span class="line">let x    = 0b001</span><br><span class="line">let user = 0b110 // 有 r w 两个权限</span><br><span class="line">// 删除 r 权限</span><br><span class="line">user = user &amp; (~r)</span><br><span class="line">console.log((user &amp; r) === r) // false 没有 r 权限</span><br><span class="line">console.log((user &amp; w) === w) // true  有 w 权限</span><br><span class="line">console.log((user &amp; x) === x) // false 没有 x 权限</span><br><span class="line">console.log(user.toString(2)) // 现在 user 是 0b010</span><br><span class="line">// 再执行一次</span><br><span class="line">user = user &amp; (~r)</span><br><span class="line">console.log((user &amp; r) === r) // false 没有 r 权限</span><br><span class="line">console.log((user &amp; w) === w) // true  有 w 权限</span><br><span class="line">console.log((user &amp; x) === x) // false 没有 x 权限</span><br><span class="line">console.log(user.toString(2)) // 现在 user 还是 0b010，并不会新增</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="4-局限性和解决办法"><a href="#4-局限性和解决办法" class="headerlink" title="4. 局限性和解决办法"></a>4. 局限性和解决办法</h2><p>前面我们回顾了 JavaScript 中的 Number 和位运算，并且了解了基于位运算的权限系统原理和 Linux 文件系统权限的实例。<br>上述的所有都有前提条件：1、<strong>每种权限码都是唯一的</strong>；2、<strong>每个权限码的二进制数形式，有且只有一位值为 1（<code>2^n</code>）</strong>。也就是说，权限码只能是 1, 2, 4, 8,…,1024,…而上文提到，一个数字的范围只能在 -(2^53 -1) 和 2^53 -1 之间，JavaScript 的按位操作符又是将其操作数当作 <strong>32 位</strong>比特序列的。那么同一个应用下可用的权限数就非常有限了。这也是该方案的局限性。<br>为了突破这个限制，这里提出一个叫“权限空间”的概念，既然权限数有限，那么不妨就多开辟几个空间来存放。<br>基于权限空间，我们定义两个格式：</p>
<ol>
<li><strong>权限 code</strong>，字符串，形如 <code>index,pos</code>。其中 <code>pos</code> 表示 32 位二进制数中 1 的位置（其余全是 0）； <code>index</code> 表示<strong>权限空间</strong>，用于突破 JavaScript 数字位数的限制，是从 0 开始的正整数，每个权限code都要归属于一个权限空间。<code>index</code> 和 <code>pos</code> 使用英文逗号隔开。</li>
<li><strong>用户权限</strong>，字符串，形如 <code>1,16,16</code>。英文逗号分隔每一个<strong>权限空间</strong>的权限值。例如 <code>1,16,16</code> 的意思就是，权限空间 0 的权限值是 1，权限空间 1 的权限值是 16，权限空间 2 的权限是 16。</li>
</ol>
<p>干说可能不好懂，直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">// 用户的权限 code</span><br><span class="line">let userCode = &quot;&quot;</span><br><span class="line">// 假设系统里有这些权限</span><br><span class="line">// 纯模拟，正常情况下是按顺序的，如 0,0 0,1 0,2 ...，尽可能占满一个权限空间，再使用下一个</span><br><span class="line">const permissions = &#123;</span><br><span class="line">  SYS_SETTING: &#123;</span><br><span class="line">    value: &quot;0,0&quot;,   // index = 0, pos = 0</span><br><span class="line">    info: &quot;系统权限&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  DATA_ADMIN: &#123;</span><br><span class="line">    value: &quot;0,8&quot;,</span><br><span class="line">    info: &quot;数据库权限&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  USER_ADD: &#123;</span><br><span class="line">    value: &quot;0,22&quot;,</span><br><span class="line">    info: &quot;用户新增权限&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  USER_EDIT: &#123;</span><br><span class="line">    value: &quot;0,30&quot;,</span><br><span class="line">    info: &quot;用户编辑权限&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  USER_VIEW: &#123;</span><br><span class="line">    value: &quot;1,2&quot;,   // index = 1, pos = 2</span><br><span class="line">    info: &quot;用户查看权限&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  USER_DELETE: &#123;</span><br><span class="line">    value: &quot;1,17&quot;,</span><br><span class="line">    info: &quot;用户删除权限&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  POST_ADD: &#123;</span><br><span class="line">    value: &quot;1,28&quot;,</span><br><span class="line">    info: &quot;文章新增权限&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  POST_EDIT: &#123;</span><br><span class="line">    value: &quot;2,4&quot;,</span><br><span class="line">    info: &quot;文章编辑权限&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  POST_VIEW: &#123;</span><br><span class="line">    value: &quot;2,19&quot;,</span><br><span class="line">    info: &quot;文章查看权限&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  POST_DELETE: &#123;</span><br><span class="line">    value: &quot;2,26&quot;,</span><br><span class="line">    info: &quot;文章删除权限&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 添加权限</span><br><span class="line">const addPermission = (userCode, permission) =&gt; &#123;</span><br><span class="line">  const userPermission = userCode ? userCode.split(&quot;,&quot;) : []</span><br><span class="line">  const [index, pos] = permission.value.split(&quot;,&quot;)</span><br><span class="line">  userPermission[index] = (userPermission[index] || 0) | Math.pow(2, pos)</span><br><span class="line">  return userPermission.join(&quot;,&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 删除权限</span><br><span class="line">const delPermission = (userCode, permission) =&gt; &#123;</span><br><span class="line">  const userPermission = userCode ? userCode.split(&quot;,&quot;) : []</span><br><span class="line">  const [index, pos] = permission.value.split(&quot;,&quot;)</span><br><span class="line">  userPermission[index] = (userPermission[index] || 0) &amp; (~Math.pow(2, pos))</span><br><span class="line">  return userPermission.join(&quot;,&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否有权限</span><br><span class="line">const hasPermission = (userCode, permission) =&gt; &#123;</span><br><span class="line">  const userPermission = userCode ? userCode.split(&quot;,&quot;) : []</span><br><span class="line">  const [index, pos] = permission.value.split(&quot;,&quot;)</span><br><span class="line">  const permissionValue = Math.pow(2, pos)</span><br><span class="line">  return (userPermission[index] &amp; permissionValue) === permissionValue</span><br><span class="line">&#125;</span><br><span class="line">// 列出用户拥有的全部权限</span><br><span class="line">const listPermission = userCode =&gt; &#123;</span><br><span class="line">  const results = []</span><br><span class="line">  if (!userCode) &#123;</span><br><span class="line">    return results</span><br><span class="line">  &#125;</span><br><span class="line">  Object.values(permissions).forEach(permission =&gt; &#123;</span><br><span class="line">    if (hasPermission(userCode, permission)) &#123;</span><br><span class="line">      results.push(permission.info)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return results</span><br><span class="line">&#125;</span><br><span class="line">const log = () =&gt; &#123;</span><br><span class="line">  console.log(`userCode: $&#123;JSON.stringify(userCode, null, &quot; &quot;)&#125;`)</span><br><span class="line">  console.log(`权限列表: $&#123;listPermission(userCode).join(&quot;; &quot;)&#125;`)</span><br><span class="line">  console.log(&quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">userCode = addPermission(userCode, permissions.SYS_SETTING)</span><br><span class="line">log()</span><br><span class="line">// userCode: &quot;1&quot;</span><br><span class="line">// 权限列表: 系统权限</span><br><span class="line">userCode = addPermission(userCode, permissions.POST_EDIT)</span><br><span class="line">log()</span><br><span class="line">// userCode: &quot;1,,16&quot;</span><br><span class="line">// 权限列表: 系统权限; 文章编辑权限</span><br><span class="line">userCode = addPermission(userCode, permissions.USER_EDIT)</span><br><span class="line">log()</span><br><span class="line">// userCode: &quot;1073741825,,16&quot;</span><br><span class="line">// 权限列表: 系统权限; 用户编辑权限; 文章编辑权限</span><br><span class="line">userCode = addPermission(userCode, permissions.USER_DELETE)</span><br><span class="line">log()</span><br><span class="line">// userCode: &quot;1073741825,131072,16&quot;</span><br><span class="line">// 权限列表: 系统权限; 用户编辑权限; 用户删除权限; 文章编辑权限</span><br><span class="line">userCode = delPermission(userCode, permissions.USER_EDIT)</span><br><span class="line">log()</span><br><span class="line">// userCode: &quot;1,131072,16&quot;</span><br><span class="line">// 权限列表: 系统权限; 用户删除权限; 文章编辑权限</span><br><span class="line">userCode = delPermission(userCode, permissions.USER_EDIT)</span><br><span class="line">log()</span><br><span class="line">// userCode: &quot;1,131072,16&quot;</span><br><span class="line">// 权限列表: 系统权限; 用户删除权限; 文章编辑权限</span><br><span class="line">userCode = delPermission(userCode, permissions.USER_DELETE)</span><br><span class="line">userCode = delPermission(userCode, permissions.SYS_SETTING)</span><br><span class="line">userCode = delPermission(userCode, permissions.POST_EDIT)</span><br><span class="line">log()</span><br><span class="line">// userCode: &quot;0,0,0&quot;</span><br><span class="line">// 权限列表: </span><br><span class="line">userCode = addPermission(userCode, permissions.SYS_SETTING)</span><br><span class="line">log()</span><br><span class="line">// userCode: &quot;1,0,0&quot;</span><br><span class="line">// 权限列表: 系统权限</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>除了通过引入<strong>权限空间</strong>的概念突破二进制运算的位数限制，还可以使用 <a target="_blank" rel="noopener" href="http://mathjs.org/">math.js</a> 的 <code>bignumber</code>，直接运算超过 32 位的二进制数，具体可以看它的文档，这里就不细说了。</p>
<h2 id="5-适用场景和问题"><a href="#5-适用场景和问题" class="headerlink" title="5. 适用场景和问题"></a>5. 适用场景和问题</h2><p>如果按照当前使用最广泛的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E8%A7%92%E8%89%B2%E7%82%BA%E5%9F%BA%E7%A4%8E%E7%9A%84%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6">RBAC</a> 模型设计权限系统，那么一般会有这么几个实体：应用，权限，角色，用户。用户权限可以直接来自权限，也可以来自角色：</p>
<ul>
<li>一个应用下有多个权限</li>
<li>权限和角色是多对多的关系</li>
<li>用户和角色是多对多的关系</li>
<li>用户和权限是多对多的关系</li>
</ul>
<p>在此种模型下，一般会有用户与权限，用户与角色，角色与权限的对应关系表。想象一个商城后台权限管理系统，可能会有上万，甚至十几万店铺（应用），每个店铺可能会有数十个用户，角色，权限。随着业务的不断发展，刚才提到的那三张对应关系表会越来越大，越来越难以维护。<br>而进制转换的方法则可以省略对应关系表，减少查询，节省空间。当然，省略掉对应关系不是没有坏处的，例如下面几个问题：</p>
<ul>
<li>如何高效的查找我的权限？</li>
<li>如何高效的查找拥有某权限的所有用户？</li>
<li>如何控制权限的有效期？</li>
</ul>
<p>所以进制转换的方案比较适合刚才提到的应用极其多，而每个应用中用户，权限，角色数量较少的场景。</p>
<h2 id="6-其他方案"><a href="#6-其他方案" class="headerlink" title="6. 其他方案"></a>6. 其他方案</h2><p>除了二进制方案，当然还有其他方案可以达到类似的效果，例如直接使用一个1和0组成的字符串，权限点对应index，1表示拥有权限，0表示没有权限。举个例子：添加 0、删除 1、编辑 2，用户A拥有添加和编辑的权限，则 userCode 为 101；用户B拥有全部权限，userCode 为 111。这种方案比二进制转换简单，但是浪费空间。<br>还有利用质数的方案，权限点全部为质数，用户权限为他所拥有的全部权限点的乘积。如：权限点是 2、3、5、7、11，用户权限是 5 * 7 * 11 = 385。这种方案麻烦的地方在于获取质数（新增权限点）和质因数分解（判断权限），权限点特别多的时候就快成 RSA 了，如果只有增删改查个别几个权限，倒是可以考虑。</p>
<h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Numbers_and_dates">MDN：JavaScript 数字和日期</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8">双精度浮点类型</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">MDN：按位操作符</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/11f331d97ec2">【小知识大道理】被忽视的位运算</a></li>
<li><a target="_blank" rel="noopener" href="http://jerryzou.com/posts/do-you-really-want-use-bit-operators-in-JavaScript/">为什么不要在 JavaScript 中使用位操作符？</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/MKljuxfDMmopr_MrnYljGw">角色权限设计的100种解法</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/shijiaqi1066/p/3793894.html">权限系统与RBAC模型概述</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yingchunhua365/article/details/14090461">权限设计及算法</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E8%A7%92%E8%89%B2%E7%82%BA%E5%9F%BA%E7%A4%8E%E7%9A%84%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6">基于角色的访问控制</a></li>
</ul>
<h2 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h2><p><img src="http://images.pingan8787.com/2019_07_12guild_page.png" alt="2019_07_12guild_page"></p>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#112;&#x69;&#x6e;&#103;&#97;&#x6e;&#56;&#55;&#x38;&#x37;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;">&#112;&#x69;&#x6e;&#103;&#97;&#x6e;&#56;&#55;&#x38;&#x37;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>JS小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/12/182-%E3%80%90JavaScript%E3%80%91JavaScript%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%E5%92%8C%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/" data-id="ckts3ejyf00mj4d9k2a3y00jo" data-title="182-【JavaScript】JavaScript中的位运算和权限设计" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-181-【React】精读《react-easy-state源码》" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/09/181-%E3%80%90React%E3%80%91%E7%B2%BE%E8%AF%BB%E3%80%8Areact-easy-state%E6%BA%90%E7%A0%81%E3%80%8B/" class="article-date">
  <time class="dt-published" datetime="2019-11-09T02:18:08.000Z" itemprop="datePublished">2019-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/09/181-%E3%80%90React%E3%80%91%E7%B2%BE%E8%AF%BB%E3%80%8Areact-easy-state%E6%BA%90%E7%A0%81%E3%80%8B/">181-【React】精读《react-easy-state源码》</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://juejin.im/post/5caa9c71e51d452b4043e2d8">《精读《react-easy-state 源码》》</a></p>
</blockquote>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p><code>react-easy-state</code> 是个比较有趣的库，利用 <code>Proxy</code> 创建了一个非常易用的全局数据流管理方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; store, view &#125; <span class="keyword">from</span> <span class="string">&quot;react-easy-state&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = store(&#123; <span class="attr">num</span>: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> increment = <span class="function">() =&gt;</span> counter.num++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> view(<span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>&#123;counter.num&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure>

<p>上手非常轻松，通过 <code>store</code> 创建一个数据对象，这个对象被任何 React 组件使用时，都会自动建立双向绑定，<strong>任何对这个对象的修改，都会让使用了这个对象的组件重渲染</strong>。</p>
<p>当然，为了实现这一点，需要对所有组件包裹一层 <code>view</code>。</p>
<h2 id="2-精读"><a href="#2-精读" class="headerlink" title="2. 精读"></a>2. 精读</h2><p>这个库利用了 <a target="_blank" rel="noopener" href="https://github.com/nx-js/observer-util">nx-js/observer-util</a> 做 <code>Reaction</code> 基础 API，其他核心功能分别是 <code>store</code> <code>view</code> <code>batch</code>，所以我们就从这四个点进行解读。</p>
<h3 id="Reaction"><a href="#Reaction" class="headerlink" title="Reaction"></a>Reaction</h3><p>这个单词名叫 “反应”，是实现双向绑定库的最基本功能单元。</p>
<p>拥有最基本的两个单词和一个概念：<code>observable</code> <code>observe</code> 与自动触发执行的特性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, observe &#125; <span class="keyword">from</span> <span class="string">&quot;@nx-js/observer-util&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = observable(&#123; <span class="attr">num</span>: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> countLogger = observe(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(counter.num));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会自动触发 countLogger 函数内回调函数的执行。</span></span><br><span class="line">counter.num++;</span><br></pre></td></tr></table></figure>

<p>在第 35 期精读<a target="_blank" rel="noopener" href="https://github.com/dt-fe/weekly/blob/master/35.%E7%B2%BE%E8%AF%BB%E3%80%8Adob%20-%20%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E3%80%8B.md#%E6%8A%BD%E4%B8%9D%E5%89%A5%E8%8C%A7%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E8%BF%BD%E8%B8%AA"> 精读《dob - 框架实现》</a> “抽丝剥茧，实现依赖追踪” 一节中有详细介绍实现原理，这里就不赘述了。</p>
<p>有了一个具有反应特性的函数，与一个可以 “触发反应” 的对象，那么实现双向绑定更新 View 就不远了。</p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p><code>react-easy-state</code> 的 <code>store</code> 就是 <code>observable(obj)</code> 包装一下，唯一不同是，由于支持本地数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; view, store &#125; <span class="keyword">from</span> <span class="string">&#x27;react-easy-state&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> view(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = store(&#123; <span class="attr">num</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  <span class="keyword">const</span> increment = <span class="function">() =&gt;</span> counter.num++</span><br><span class="line">  <span class="keyword">return</span> <span class="xml">&lt;button=&#123;increment&#125;&gt;&#123;counter.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>所以当监测到在 React 组件内部创建 <code>store</code> 且是 <code>Hooks</code> 环境时，会返回：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> useMemo(<span class="function">() =&gt;</span> observable(obj), []);</span><br></pre></td></tr></table></figure>

<p>这是因为 React Hooks 场景下的 Function Component 每次渲染都会重新创建 <code>Store</code>，会导致死循环。因此利用 <code>useMemo</code> 并将依赖置为 <code>[] </code>使代码在所有渲染周期内，只在初始化执行一次。</p>
<p>更多 Hooks 深入解读，可以阅读 <a target="_blank" rel="noopener" href="https://github.com/dt-fe/weekly/blob/master/96.%E7%B2%BE%E8%AF%BB%E3%80%8AuseEffect%20%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%E3%80%8B.md">精读《useEffect 完全指南》</a>。</p>
<h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>根据 Function Component 与 Class Component 的不同，分别进行两种处理，本文主要介绍对 Function Component 的处理方式，因为笔者推荐使用 Function Component 风格。</p>
<p>首先最外层会套上 <code>memo</code>，这类似 <code>PureComponent</code> 的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> memo(<span class="comment">/**/</span>);</span><br></pre></td></tr></table></figure>

<p>然后构造一个 <code>forceUpdate</code> 用来强制渲染组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [, forceUpdate] = useState();</span><br></pre></td></tr></table></figure>

<p>之后，只要利用 <code>observe</code> 包裹组件即可，需要注意两点：</p>
<ol>
<li><strong>使用刚才创建的 <code>forceUpdate</code> 在 <code>store</code> 修改时调用。</strong></li>
<li><code>observe</code> 初始化不要执行，因为初始化组件自己会渲染一次，再渲染一次就会造成浪费。</li>
</ol>
<p>所以作者通过 <code>scheduler</code> <code>lazy</code> 两个参数完成了这两件事：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> render = useMemo(</span><br><span class="line">  <span class="function">() =&gt;</span></span><br><span class="line">    observe(Comp, &#123;</span><br><span class="line">      <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> setState(&#123;&#125;),</span><br><span class="line">      <span class="attr">lazy</span>: <span class="literal">true</span></span><br><span class="line">    &#125;),</span><br><span class="line">  []</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> render;</span><br></pre></td></tr></table></figure>

<p>最后别忘了在组件销毁时取消监听：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> unobserve(render);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<h3 id="batch"><a href="#batch" class="headerlink" title="batch"></a>batch</h3><p>这也是双向绑定数据流必须解决的经典问题，批量更新合并。</p>
<p>由于修改对象就触发渲染，<strong>这个过程太自动化了，以至于我们都没有机会告诉工具，连续的几次修改能否合并起来只触发一次渲染</strong>。 尤其是 <code>For</code> 循环修改变量时，如果不能合并更新，在某些场景下代码几乎是不可用的。</p>
<p>所以 <code>batch</code> 就是为解决这个问题诞生的，让我们有机会控制合并更新的时机：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; view, store, batch &#125; <span class="keyword">from</span> <span class="string">&quot;react-easy-state&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = store(&#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutateUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this makes sure the state changes will cause maximum one re-render,</span></span><br><span class="line">  <span class="comment">// no matter where this function is getting invoked from</span></span><br><span class="line">  batch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    user.name = <span class="string">&quot;Ann&quot;</span>;</span><br><span class="line">    user.age = <span class="number">32</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> view(<span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    name: &#123;user.name&#125;, age: &#123;user.age&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<p><code>react-easy-state</code> 通过 <code>scheduler</code> 模块完成 <code>batch</code> 功能，核心代码只有五行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">batch</span>(<span class="params">fn, ctx, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  unstable_batchedUpdates(<span class="function">() =&gt;</span> (result = fn.apply(ctx, args)));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 <code>unstable_batchedUpdates</code>，可以保证在其内执行的函数都不会触发更新，也就是之前创建的 <code>forceUpdate</code> 虽然被调用，但是失效了，等回调执行完毕时再一起批量更新。</p>
<p>同时代码里还对 <code>setTimeout</code> <code>setInterval</code> <code>addEventListener</code> <code>WebSocket</code> 等公共方法进行了 <code>batch</code> 包装，让这些回调函数中自带 <code>batch</code> 效果。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>好了，<code>react-easy-state</code> 神奇的效果解释完了，希望大家在使用第三方库的时候都能理解背后的原理。</p>
<p>PS：最后，笔者目前不推荐在 Function Component 模式下使用任何三方数据流库，因为官方功能已经足够好用了！</p>
<p>讨论地址是：<a target="_blank" rel="noopener" href="https://github.com/dt-fe/weekly/issues/144">精读《react-easy-state》</a></p>
<h2 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h2><p><img src="http://images.pingan8787.com/2019_07_12guild_page.png" alt="2019_07_12guild_page"></p>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#x69;&#110;&#103;&#x61;&#x6e;&#56;&#55;&#x38;&#55;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#x70;&#x69;&#110;&#103;&#x61;&#x6e;&#56;&#55;&#x38;&#55;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>JS小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/09/181-%E3%80%90React%E3%80%91%E7%B2%BE%E8%AF%BB%E3%80%8Areact-easy-state%E6%BA%90%E7%A0%81%E3%80%8B/" data-id="ckts3ejts004n4d9k5yuddzo8" data-title="181-【React】精读《react-easy-state源码》" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB/" rel="tag">源码精读</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-180-【React】在React中使用ShadowDOM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/04/180-%E3%80%90React%E3%80%91%E5%9C%A8React%E4%B8%AD%E4%BD%BF%E7%94%A8ShadowDOM/" class="article-date">
  <time class="dt-published" datetime="2019-11-04T13:16:17.000Z" itemprop="datePublished">2019-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/04/180-%E3%80%90React%E3%80%91%E5%9C%A8React%E4%B8%AD%E4%BD%BF%E7%94%A8ShadowDOM/">180-【React】在React中使用ShadowDOM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/717933">《在 React 中使用 Shadow DOM》</a></p>
<blockquote>
<p>本文作者：houfeng<br>原文地址：<a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/717933">https://yq.aliyun.com/articles/717933</a></p>
</blockquote>
<h2 id="1-Shadow-DOM-是什么"><a href="#1-Shadow-DOM-是什么" class="headerlink" title="1. Shadow DOM 是什么"></a>1. Shadow DOM 是什么</h2><p><strong>Shadow DOM</strong> 是什么？我们先来打开 Chrome 的 DevTool，并在 <strong>‘Settings -&gt; Preferences -&gt; Elements’</strong> 中把 <strong>‘ Show user agent shadow DOM’</strong> 打上勾。然后，打开一个支持 HTML5 播放的视频网站。比如 Youtube：</p>
<p><img src="http://images.pingan8787.com/blog/2019110401.png" alt="2019110401"></p>
<p>可以看到 <code>video</code> 内部有一个 <code>#shadow-root</code> ，在 ShadowRoot 之下还能看到 <code>div</code> 这样的普通 HTML 标签。我们能知道 <code>video</code> 会有「播放/暂停按钮、进度条、视频时间显示、音量控制」等控件，那其实，就是由 <code>ShadowRoot</code> 中的这些子元素构成的。而我们最常用的 input 其实也附加了 Shadow DOM，比如，我们在 Chrome 中尝试给一个 <code>Input</code> 加上 placeholder ，通过 DevTools 便能看到，其实文字是在 <code>ShadowRoot</code> 下的一个 <code>Id</code> 为 <code>palcehoder</code> 的 <code>div</code> 中。</p>
<p><img src="http://images.pingan8787.com/blog/2019110402.png" alt="2019110402"></p>
<p>Shadow DOM 允许在文档（Document）渲染时插入一棵「子 DOM  树」，并且这棵子树不在主 DOM 树中，同时为子树中的 DOM 元素和 CSS 提供了封装的能力。Shadow DOM 使得子树 DOM 与主文档的 DOM 保持分离，子 DOM 树中的 CSS 不会影响到主 DOM 树的内容，如下图所示：</p>
<p><img src="http://images.pingan8787.com/blog/2019110403.png" alt="2019110403"></p>
<p>这里有几个需要了解和 Shadow DOM 相关的技术概念：</p>
<ul>
<li><code>Shadow host</code>： 一个常规 DOM 节点，Shadow DOM 会被附加到这个节点上。</li>
<li><code>Shadow tree</code>：Shadow DOM 内部的 DOM 树。</li>
<li><code>Shadow boundary</code>：Shadow DOM 结束的地方，也是常规 DOM 开始的地方。</li>
<li><code>Shadow root</code>:  Shadow tree 的根节点。</li>
</ul>
<h2 id="2-Shadwo-DOM-有何用"><a href="#2-Shadwo-DOM-有何用" class="headerlink" title="2. Shadwo DOM 有何用"></a>2. Shadwo DOM 有何用</h2><h3 id="2-1-浏览器内建的原生组件"><a href="#2-1-浏览器内建的原生组件" class="headerlink" title="2.1. 浏览器内建的原生组件"></a>2.1. 浏览器内建的原生组件</h3><p>Shadow DOM 最大的用处应该是隔离外部环境用于封装组件。估计浏览器的开发者们也意识到通过 HTML/CSS 来实现浏览器内建的原生组件更容易，如上边提到的浏览器原生组件 <code>input</code>，<code>video</code>，还有 <code>textarea</code>，<code>select</code>，<code>audio</code> 等，也都是由 HTML/CSS 渲染出来的。</p>
<h3 id="2-2-Web-Components"><a href="#2-2-Web-Components" class="headerlink" title="2.2. Web Components"></a>2.2. Web Components</h3><p>Web Components 允许开发者创建可重用的自定义元素，它们可以一起使用来创建封装功能的自定义元素，并可以像浏览器原生的元素一样在任何地方重用，而不必担心样式和 DOM 的冲突问题，主要由三项主要技术组成：</p>
<ul>
<li><code>Custom Elements</code>（自定义元素）：一组 JavaScript API，允许您定义 Custom Elements 及其行为，然后可以在您的用户界面中按照需要使用它们。</li>
<li><code>HTML Templates</code>（ HTML 模板）： <code>template</code> 和 <code>slot</code> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。</li>
<li><code>Shadow DOM</code>（影子 DOM）：一组 JavaScript API 用于将「影子 DOM 树」附加到元素上，与主文档 DOM 树隔离，并能控制其关联的功能。通过这种方式，可以保持元素的私有，并能不用担心「样式」与文档的其他部分发生冲突。</li>
</ul>
<p>在 <strong>Web Components</strong> 中的一个重要特性是「封装」，可以将「HTML 标签结构、CSS 样式、行为」隐藏起来，并从页面上的其他代码中分离开来，这样不同的功能不会混在一起，代码看起来也会更加干净整洁，其中 Shadow DOM 便是 DOM 和 CSS 封装所依赖的关键特性。</p>
<h3 id="2-3-其他需要隔离的场景"><a href="#2-3-其他需要隔离的场景" class="headerlink" title="2.3 其他需要隔离的场景"></a>2.3 其他需要隔离的场景</h3><p>不少人大概会听说过「微前端」，微前端作为一种「架构风格」，其中可由多个「可独立交付的前端子应用」组合成一个大的整体。那么在「微前端架构」下，每一个独立的子应用间及子应用间的如何保证不会冲突？样式不会相互覆盖？那么，是否可以将每个「子应用」通过 Shadow DOM 进行隔离？答案是肯定的，我就在部分项目中有过实践。</p>
<p>其他，在需要进行 DOM/CSS 隔离的场景，都有可能是 Shadow DOM 的用武之地。比如像 「阿里云购物车」这种需要「嵌入集成」到不同产品售卖页的「公共组件」，就很需要避免和宿主页面的样式冲突，即不影响宿主页面，也不要受宿主页面的影响。</p>
<p><img src="http://images.pingan8787.com/blog/2019110404.png" alt="2019110404"></p>
<h2 id="3-主流浏览器的支持情况"><a href="#3-主流浏览器的支持情况" class="headerlink" title="3. 主流浏览器的支持情况"></a>3. 主流浏览器的支持情况</h2><p>其中 Chrome，Opera 和 Safari 默认就支持 Shadow DOM，而 Firefox 从 63 版本开始已经支持，可以看到支持最好的是 Chrome，而 IE 直到 11 也都是不支持的，微软的另一款浏览器 Edge 要换成和 Chrome 相同内核了，那换核后的 Edge 肯定会支持 Shadow DOM 了。</p>
<p><img src="http://images.pingan8787.com/blog/2019110405.png" alt="2019110405"></p>
<p>各浏览器支持详细情况，请参考 <a target="_blank" rel="noopener" href="https://caniuse.com/#feat=shadowdomv1">https://caniuse.com/#feat=shadowdomv1</a></p>
<h2 id="4-如何创建-Shadow-DOM"><a href="#4-如何创建-Shadow-DOM" class="headerlink" title="4. 如何创建 Shadow DOM"></a>4. 如何创建 Shadow DOM</h2><p>Shadow DOM 必须附加在一个元素上，可以是通过 HTML 声明的一个元素，也可以是通过脚本动态创建的元素。可以是原生的元素，如 <code>div</code>、<code>p </code>，也可以是「自定义元素」如 <code>my-element</code> ，语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shadowroot = element.attachShadow(shadowRootInit); </span><br></pre></td></tr></table></figure>

<p>参考如下例所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Shadow Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Shadow Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;host&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> host = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#host&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 通过 attachShadow 向元素附加 Shadow DOM</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> shodowRoot = host.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 向 shodowRoot 中添加一些内容</span></span></span><br><span class="line"><span class="javascript">      shodowRoot.innerHTML = <span class="string">`&lt;style&gt;*&#123;color:red;&#125;&lt;/style&gt;&lt;h2&gt;haha!&lt;/h2&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过这个简单的示例可以看到「在 Shadow DOM 中定义的样式，并不会影响到主文档中的元素」，如下图</p>
<p><img src="http://images.pingan8787.com/blog/2019110406.png" alt="2019110406"></p>
<p><code>Element.attachShadow</code>  的参数 <code>shadowRootInit</code>  的 <code>mode</code>  选项用于设定「封装模式」。它有两个可选的值 ：</p>
<ul>
<li><strong>“open”</strong> ：可 <code>Host</code> 元素上通过 <code>host.shadowRoot</code>  获取 <code>shadowRoot</code> 引用，这样任何代码都可以通过 <code>shadowRoot</code> 来访问的子 DOM 树。</li>
<li>**”closed”**：在 <code>Host</code> 元素上通过 <code>host.shadowRoot</code>  获取的是 <code>null</code>，我们只能通过 <code>Element.attachShadow</code> 的返回值拿到 <code>shadowRoot</code> 的引用（通常可能隐藏在类中）。例如，浏览器内建的 input、video 等就是关闭的，我们没有办法访问它们。</li>
</ul>
<h2 id="5-哪些元素可以附加-Shadow-DOM"><a href="#5-哪些元素可以附加-Shadow-DOM" class="headerlink" title="5. 哪些元素可以附加 Shadow DOM"></a>5. 哪些元素可以附加 Shadow DOM</h2><p>并非所有 HTML 元素都可以开启 Shadow DOM 的，只有一组有限的元素可以附加 Shadow DOM。有时尝试将 Shadow DOM 树附加到某些元素将会导致 <code>DOMException</code> 错误，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>).attachShadow(&#123;<span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span>&#125;);    </span><br><span class="line"><span class="comment">// =&gt; DOMException</span></span><br></pre></td></tr></table></figure>

<p>用 <code>&lt;img&gt;</code> 这样的非容器素作为 Shadow Host 是不合理的，因此这段代码将抛出 DOMException 错误。此外因为安全原因一些元素也不能附加 Shadow DOM（比如 A 元素），会出现错误的另一个原因是浏览器已经用该元素附加了 Shadow DOM，比如 Input 等。</p>
<p>下表列出了所有支持的元素：</p>
<p><img src="http://images.pingan8787.com/blog/2019110407.png" alt="2019110407"></p>
<h2 id="6-在-React-中如何应用-Shadow-DOM"><a href="#6-在-React-中如何应用-Shadow-DOM" class="headerlink" title="6. 在 React 中如何应用 Shadow DOM"></a>6. 在 React 中如何应用 Shadow DOM</h2><p>在基于 React 的项目中应该如何使用 Shadow DOM 呢？比如你正在基于 React 编写一个面向不同产品或业务，可嵌入集成使用的公共组件，比如你正在基于 React 做一个「微前端架构」应用的设计或开发。</p>
<p>我们在编写 React 应用时一般不希望到处是 DOM 操作，因为这很不 React (形容词)。那是否能封装成一下用更 React (形容词) 的组件风格去使用 Shadow DOM 呢? </p>
<h3 id="6-1-尝试写一个-React-组件"><a href="#6-1-尝试写一个-React-组件" class="headerlink" title="6.1. 尝试写一个 React 组件:"></a>6.1. 尝试写一个 React 组件:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowView</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  attachShadow = <span class="function">(<span class="params">host: Element</span>) =&gt;</span> &#123;</span><br><span class="line">    host.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">&quot;open&quot;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.attachShadow&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;children&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ShadowView</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>这儿是隔离的<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ShadowView</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>跑起来看看效果，一定会发现「咦？什么也没有显示」：</p>
<p><img src="http://images.pingan8787.com/blog/2019110408.png" alt="2019110408"></p>
<p>在这里需要稍注意一下，在一个元素上附加了 Shadow DOM 后，元素原本的「子元素」将不会再显示，并且这些子元素也不在 Shadow DOM 中，只有 <code>host.shadowRoot</code>  的子元素才是「子 DOM 树」中一部分。也就是说这个「子 DOM 树」的「根节点」是 <code>host.shadowRoot</code> 而非 <code>host</code>。 <code>host.shadowRoot</code> 是 ShadowRoot 的实例，而 <code>ShadowRoot</code> 则继承于 <code>DocumentFragment</code>，可通过原生 DOM API 操作其子元素。</p>
<p>我们需通过<code> Element.attachShadow</code> 附加到元素，然后就能拿到附加后的 ShadowRoot 实例。 针对 ShadowRoot 这样一个原生 DOM Node 的的引用，除了利用 <code>ReactDOM.render</code> 或 <code>ReactDOM.createPortal</code>  ，我们并不能轻易的将<code> React.Element</code> 渲染到其中，除非直接接操作 DOM。</p>
<h3 id="6-2-基于直接操作-DOM-改造一版"><a href="#6-2-基于直接操作-DOM-改造一版" class="headerlink" title="6.2. 基于直接操作 DOM 改造一版:"></a>6.2. 基于直接操作 DOM 改造一版:</h3><p>在 React 中通过 <code>ref</code> 拿到真实的 DOM 引用后，是否能通过原生的 DOM  API，将 <code>host</code> 的 <code>children</code> 移动到 <code>host.shadowRoot</code> 中？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于直接操作 DOM 的方式改造的一版</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowView</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  attachShadow = <span class="function">(<span class="params">host: Element</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> shadowRoot = host.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">&quot;open&quot;</span> &#125;);</span><br><span class="line">    <span class="comment">//将所有 children 移到 shadowRoot 中</span></span><br><span class="line">    [].slice.call(host.children).forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">      shadowRoot.appendChild(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.attachShadow&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;children&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证一下</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">message</span>: <span class="string">&#x27;...&#x27;</span> &#125;;</span><br><span class="line">  onBtnClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">message</span>: <span class="string">&#x27;haha&#x27;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; message &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ShadowView</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onBtnClick&#125;</span>&gt;</span>内部单击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ShadowView</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onBtnClick&#125;</span>&gt;</span>外部单击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>在浏览器中看看效果，可以看到是可以正常显示的。但与此同时会发现一个问题「隔离在 ShadowRoot 中的元素上的事件无法被触发了」，这是什么原因呢？</p>
<p>是由于 React 的「合成事件机制」的导致的，我们知道在 React 中「事件」并不会直接绑定到具体的 DOM 元素上，而是通过在 <code>document</code> 上绑定的 <code>ReactEventListener</code> 来管理， 当时元素被单击或触发其他事件时，事件被 <code>dispatch</code> 到 <code>document</code> 时将由 React 进行处理并触发相应合成事件的执行。</p>
<p>那为什么合成事件在 Shadow DOM 中不能被正常触发？是因为当在 Shadow DOM 外部捕获时浏览器会对事件进行「重定向」，也就是说在 Shadow DOM 中发生的事件在外部捕获时将会使用 host 元素作为事件源。这将让 React 在处理合成事件时，不认为 ShadowDOM 中元素基于 JSX 语法绑定的事件被触发了。</p>
<p><img src="http://images.pingan8787.com/blog/2019110409.png" alt="2019110409"></p>
<h3 id="6-3-尝试利用-ReactDOM-render-改造一下"><a href="#6-3-尝试利用-ReactDOM-render-改造一下" class="headerlink" title="6.3. 尝试利用 ReactDOM.render 改造一下:"></a>6.3. 尝试利用 ReactDOM.render 改造一下:</h3><p><code>ReactDOM.render</code> 的第二个参数，可传入一个 DOM 元素。那是不是能通过 <code>ReactDOM.render</code> 将 <code>React Eements</code> 渲染到 Shodaw DOM 中呢？看一下如下尝试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换用 ReactDOM.render 实现</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowView</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  attachShadow = <span class="function">(<span class="params">host: Element</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> shadowRoot = host.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">&quot;open&quot;</span> &#125;);</span><br><span class="line">    ReactDOM.render(children, shadowRoot);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.attachShadow&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 试试效果如何</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">message</span>: <span class="string">&#x27;...&#x27;</span> &#125;;</span><br><span class="line">  onBtnClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">message</span>: <span class="string">&#x27;haha&#x27;</span> &#125;);</span><br><span class="line">    alert(<span class="string">&#x27;haha&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; message &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ShadowView</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onBtnClick&#125;</span>&gt;</span>单击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ShadowView</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>


<p>可以看到通过 <code>ReactDOM.render</code> 进行 <code>children</code> 的渲染，是能够正常渲染到 <code>Shadow Root</code> 中，并且在 Shadow DOM 中合成事件也是能正常触发执行的。</p>
<p>为什么此时「隔离在 Shadow DOM 中的元素事件」能够被触发了呢？ 因为在 React 在发现渲染的目标在 ShadowRoot 中时，将会将事件绑定在通过 <code>Element.getRootNode()</code> 获取的 <code>DocumentFragment</code> 的 <code>RootNode</code> 上。</p>
<p><img src="http://images.pingan8787.com/blog/2019110410.png" alt="2019110410"></p>
<p>看似一切顺利，但却会发现父组件的 state 更新时，而 ShadowView 组件并没有更新。如上边的示例，其中的 message 显示的还是旧的，而原因就在我们使用 <code>ReactDOM.render</code> 时，Shadow DOM 的元素和父组件不在一个 React 渲染上下文中了。</p>
<h3 id="6-4-利用-ReactDOM-createPortal-实现一版："><a href="#6-4-利用-ReactDOM-createPortal-实现一版：" class="headerlink" title="6.4. 利用 ReactDOM.createPortal 实现一版："></a>6.4. 利用 ReactDOM.createPortal 实现一版：</h3><p>我们知道 <code>createPortal</code> 的出现为「弹窗、提示框」等脱离文档流的组件开发提供了便利，替换了之前不稳定的 API <code>unstable_renderSubtreeIntoContainer</code>。</p>
<p><code>ReactDOM.createPortal</code> 有一个特性是「通过 <code>createPortal</code> 渲染的 DOM，事件可以从 Portal 的入口端冒泡上来」，这一特性很关键，没有父子关系的 DOM ，合成事件能冒泡过来，那通过  <code>createPortal</code> 渲染到 Shadow DOM 中的元素的事件也能正常触发吧？并且能让所有元素的渲染在一个上下文中。那就基于 <code>createPortal</code> 实现一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 ReactDOM.createPortal 的实现</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ShadowContent</span>(<span class="params">&#123; root, children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ReactDOM.createPortal(children, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowView</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">root</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">  setRoot = <span class="function"><span class="params">eleemnt</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> root = eleemnt.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">&quot;open&quot;</span> &#125;);</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; root &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; root &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.setRoot&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;root &amp;&amp; <span class="tag">&lt;<span class="name">ShadowContent</span> <span class="attr">root</span>=<span class="string">&#123;root&#125;</span> &gt;</span></span></span><br><span class="line"><span class="xml">        &#123;children&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ShadowContent</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 试试如何</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">message</span>: <span class="string">&#x27;...&#x27;</span> &#125;;</span><br><span class="line">  onBtnClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">message</span>: <span class="string">&#x27;haha&#x27;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; message &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ShadowView</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onBtnClick&#125;</span>&gt;</span>单击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ShadowView</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="http://images.pingan8787.com/blog/2019110411.png" alt="2019110411"></p>
<p>Wow! 一切正常，有一个小问题是 <code>createPortal</code> 不支持 React 16 以下的版本，但大多数情况下这并不是个什么大问题。</p>
<h2 id="7-面向-React-的-ShadowView-组件"><a href="#7-面向-React-的-ShadowView-组件" class="headerlink" title="7. 面向 React 的 ShadowView 组件"></a>7. 面向 React 的 ShadowView 组件</h2><p>上边提到了几种在 React 中实现 Shadwo DOM 组件的方法，而 ShadowView 是一个写好的可开箱即用的面向 React 的 Shadow DOM 容器组件，利用 ShadowView 可以像普通组件一样方便的在 React 应用中创建启用 Shadow DOM 的容器元素。</p>
<p>ShadowView 目前完整兼容支持 React 15/16，组件的「事件处理、组件渲染更新」等行为在两个版中都是一致的。</p>
<p>GitHub: <a target="_blank" rel="noopener" href="https://github.com/Houfeng/shadow-view">https://github.com/Houfeng/shadow-view</a></p>
<h3 id="7-1-安装组件"><a href="#7-1-安装组件" class="headerlink" title="7.1. 安装组件"></a>7.1. 安装组件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i shadow-view --save</span><br></pre></td></tr></table></figure>

<h3 id="7-2-使用组件"><a href="#7-2-使用组件" class="headerlink" title="7.2. 使用组件"></a>7.2. 使用组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ShadowView &#125; <span class="keyword">from</span> <span class="string">&quot;shadow-view&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ShadowView</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">styleContent</span>=<span class="string">&#123;</span>`*&#123;<span class="attr">color:red</span>;&#125;`&#125; </span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">styleSheets</span>=<span class="string">&#123;[</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            &#x27;<span class="attr">your_style1_url.css</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="xml">          &#x27;<span class="attr">your_style2_url.css</span>&#x27;</span></span></span><br><span class="line"><span class="tag"><span class="xml">        ]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">        &gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">style</span>&gt;</span>&#123;`在这儿也可写内部样式`&#125;<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一个测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ShadowView</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="7-3-组件属性"><a href="#7-3-组件属性" class="headerlink" title="7.3. 组件属性"></a>7.3. 组件属性</h3><p><img src="http://images.pingan8787.com/blog/2019110412.png" alt="2019110412"></p>
<p><img src="http://images.pingan8787.com/2019_07_12guild_page.png" alt="2019_07_12guild_page"></p>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#112;&#x69;&#x6e;&#x67;&#x61;&#110;&#56;&#x37;&#x38;&#55;&#64;&#113;&#113;&#x2e;&#x63;&#111;&#109;">&#112;&#x69;&#x6e;&#x67;&#x61;&#110;&#56;&#x37;&#x38;&#55;&#64;&#113;&#113;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>JS小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/04/180-%E3%80%90React%E3%80%91%E5%9C%A8React%E4%B8%AD%E4%BD%BF%E7%94%A8ShadowDOM/" data-id="ckts3ejye00mh4d9k6h7s7tay" data-title="180-【React】在React中使用ShadowDOM" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-179-【全栈修炼】OAuth2修炼宝典" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/30/179-%E3%80%90%E5%85%A8%E6%A0%88%E4%BF%AE%E7%82%BC%E3%80%91OAuth2%E4%BF%AE%E7%82%BC%E5%AE%9D%E5%85%B8/" class="article-date">
  <time class="dt-published" datetime="2019-10-30T04:08:29.000Z" itemprop="datePublished">2019-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/30/179-%E3%80%90%E5%85%A8%E6%A0%88%E4%BF%AE%E7%82%BC%E3%80%91OAuth2%E4%BF%AE%E7%82%BC%E5%AE%9D%E5%85%B8/">179-【全栈修炼】OAuth2修炼宝典</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、OAuth-概念"><a href="#一、OAuth-概念" class="headerlink" title="一、OAuth 概念"></a>一、OAuth 概念</h2><blockquote>
<p>开放授权（OAuth）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。 —— 维基百科</p>
</blockquote>
<p>严格来说，OAuth2 不是一个标准协议，而<strong>是一个安全的授权框架</strong>。其详细描述系统中不同角色，用户，服务前端应用（如 API ）以及客户端（如网站或APP）之间如何<strong>实现相互认证</strong>。</p>
<p>当前 OAuth 协议版本是 OAuth2.0，需要注意的是，OAuth2.0 并不向下兼容 OAuth1.0。</p>
<p>在生活中，比较常见的 OAuth2 的使用场景是<strong>授权登录</strong>，并且也广泛应用于 web、桌面应用和移动 APP 的<strong>第三方服务提供授权登录验证机制，以实现不同应用直接数据访问的权限</strong>。</p>
<h2 id="二、OAuth2-重点名词介绍"><a href="#二、OAuth2-重点名词介绍" class="headerlink" title="二、OAuth2 重点名词介绍"></a>二、OAuth2 重点名词介绍</h2><p>在 OAuth2 标准中定义了以下四种角色：</p>
<ul>
<li>资源拥有者 (<strong>Resource Owner</strong>)：</li>
</ul>
<p>代表授权客户端访问本身资源信息的用户（User）；</p>
<ul>
<li>客户端 (<strong>Client</strong>)：</li>
</ul>
<p>代表意图访问受限资源的第三方应用。</p>
<ul>
<li>资源服务器 (<strong>Resource Server</strong>)：</li>
</ul>
<p>代表托管了受保护的用户账号信息的服务器，它与认证服务器，可以是同一台服务器，也可以是不同的服务器；</p>
<ul>
<li>授权服务器 (<strong>Authorization Server</strong>)：</li>
</ul>
<p>代表验证用户身份然后为客户端派发资源访问令牌的服务器，即服务提供商专门用来处理认证的服务器；</p>
<h2 id="三、OAuth2-运行流程"><a href="#三、OAuth2-运行流程" class="headerlink" title="三、OAuth2 运行流程"></a>三、OAuth2 运行流程</h2><h3 id="1-流程分析"><a href="#1-流程分析" class="headerlink" title="1. 流程分析"></a>1. 流程分析</h3><p><img src="http://images.pingan8787.com/blog/20191028-OAuth2-01.png" alt="20191028-OAuth2-01.png"></p>
<p>（配图来自<strong>阮一峰大佬</strong>）</p>
<p>大致流程概括就是：</p>
<ul>
<li>（A）Authrization Request</li>
</ul>
<p>用户打开客户端以后，客户端要求用户给予授权。</p>
<ul>
<li>（B）Authorization Grant（Get）</li>
</ul>
<p>用户同意给予客户端授权。</p>
<ul>
<li>（C）Authorization Grant（Post）</li>
</ul>
<p>客户端向<strong>授权服务器</strong>发送它自己的客户端<strong>身份标识</strong>和上一步中获得的授权（authorization grant），向认证服务器申请令牌。</p>
<ul>
<li>（D）Access Token（Get）</li>
</ul>
<p>认证服务器对客户端进行认证以后，确认无误，同意发放令牌（access token），授权阶段至此全部结束。</p>
<ul>
<li>（E）Access Token（Post &amp;&amp; Validate）</li>
</ul>
<p>客户端使用令牌，向资源服务器申请获取资源。</p>
<ul>
<li>（F）Protected Resource（Get）</li>
</ul>
<p>资源服务器确认令牌无误，同意向客户端开放资源。</p>
<p>理解完上面整个流程以后，我们再看看下面这张图，能更加清晰理解 OAuth2 的整个运行流程：</p>
<p><img src="http://images.pingan8787.com/blog/20191028-OAuth2-02.png" alt="20191028-OAuth2-02.png"></p>
<p>（配图来自公众号<strong>前端修仙之路</strong>）</p>
<p>从整个流程可以看出，在 B 步骤最为关键，即<strong>需要获取到用户对客户端的授权</strong>（如我们在微信扫码登录时，点击“确定”按钮的步骤）。</p>
<p>有了这个授权以后，客户端才能拿到令牌，进而凭令牌向资源服务器获取资源。</p>
<h3 id="2-案例：微信登录"><a href="#2-案例：微信登录" class="headerlink" title="2. 案例：微信登录"></a>2. 案例：微信登录</h3><p>另外，微信登录的实现流程也类似：</p>
<p><img src="http://images.pingan8787.com/blog/20191028-OAuth2-03.png" alt="20191028-OAuth2-03.png"></p>
<p>（配图来自<strong>微信官方文档</strong>）</p>
<p>其整体流程为： </p>
<ol>
<li><p>第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会<strong>拉起应用或重定向到第三方网站</strong>，并且带上授权临时票据 <code>code</code> 参数；</p>
</li>
<li><p>通过 <code>code</code> 参数加上 <code>AppID</code> 和 <code>AppSecret</code> 等，通过 API 换取 <code>access_token</code> ；</p>
</li>
<li><p>通过 <code>access_token</code> 进行接口调用，<strong>获取用户基本数据资源或帮助用户实现基本操作</strong>。</p>
</li>
</ol>
<h3 id="3-OAuth2-优缺点"><a href="#3-OAuth2-优缺点" class="headerlink" title="3. OAuth2 优缺点"></a>3. OAuth2 优缺点</h3><ul>
<li>优点：</li>
</ul>
<p>适合快速开发实施，代码量少，API需要被不同APP使用，且每个APP使用方式也不同的情况。</p>
<ul>
<li>缺点：</li>
</ul>
<p>学习和理解的成本比较大，并且 OAuth2 不是一个严格的标准协议，在实施过程中更容易出错。</p>
<h2 id="四、OAuth2-四种授权模式"><a href="#四、OAuth2-四种授权模式" class="headerlink" title="四、OAuth2 四种授权模式"></a>四、OAuth2 四种授权模式</h2><p>通过前面描述，可以知道<strong>OAuth 的核心就是向第三方应用颁发令牌。</strong></p>
<p>OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。即以下四种授权方式：</p>
<ul>
<li>授权码（authorization-code）</li>
<li>隐藏式（implicit）</li>
<li>密码式（password）</li>
<li>客户端凭证（client credentials）</li>
</ul>
<p><strong>注意：</strong></p>
<p>不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：<strong>客户端 ID（client ID）</strong>和<strong>客户端密钥（client secret）</strong>。</p>
<p>这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p>
<h3 id="1-授权码（authorization-code）"><a href="#1-授权码（authorization-code）" class="headerlink" title="1. 授权码（authorization code）"></a>1. 授权码（authorization code）</h3><p>即<strong>第三方应用先申请一个授权码，然后再用该码获取令牌</strong>。</p>
<p>适用于<strong>有后端的 Web 应用</strong>，授权码通过前端传送，<strong>令牌则是储存在后端</strong>，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<p>这种方式也是<strong>最常用的流程，安全性最高</strong>。</p>
<h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p><img src="http://images.pingan8787.com/blog/20191028-OAuth2-04.png" alt="20191028-OAuth2-04.png"></p>
<p>（配图来自<strong>阮一峰大佬</strong>）</p>
<h4 id="步骤分析"><a href="#步骤分析" class="headerlink" title="步骤分析"></a>步骤分析</h4><ol>
<li>用户从 A 网站跳转到 B 网站，请求用户确认授权，以获取授权码，其发送链接示意如下：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">       response_type=code&amp;</span><br><span class="line">       client_id=CLIENT_ID&amp;</span><br><span class="line">       redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">       scope=<span class="built_in">read</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<p><code>response_type</code> 参数表示要求返回授权码（code）;</p>
<p><code>client_id</code> 参数让 B 知道是谁在请求;</p>
<p><code>redirect_uri</code> 参数是 B 接受或拒绝请求后的跳转网址;</p>
<p><code>scope</code> 参数表示要求的授权范围（这里是只读）;</p>
<ol start="2">
<li>在 B 网站中，当用户同意授权 A 网站，则 B 网站会携带授权码，重定向到 <code>redirect_uri</code> 参数指定的网址，就像下面这样：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://a.com/callback?code=AUTHORIZATION_CODE</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>A 网站获取授权码以后，在 A 网站后端中向 B 网站请求令牌：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/token?</span><br><span class="line">       client_id=CLIENT_ID&amp;</span><br><span class="line">       client_secret=CLIENT_SECRET&amp;</span><br><span class="line">       grant_type=authorization_code&amp;</span><br><span class="line">       code=AUTHORIZATION_CODE&amp;</span><br><span class="line">       redirect_uri=CALLBACK_URL</span><br></pre></td></tr></table></figure>

<p><code>client_id</code> 参数和 <code>client_secret</code> 参数用来让 B 确认 A 的身份（ <code>client_secret</code> 参数是保密的，因此只能在后端发请求）;</p>
<p><code>grant_type</code> 参数的值是 <code>AUTHORIZATION_CODE</code> ，表示<strong>采用的授权方式是授权码</strong>;</p>
<p><code>code</code> 参数是上一步拿到的授权码;</p>
<p><code>redirect_uri</code> 参数是令牌颁发后的回调网址;</p>
<ol start="4">
<li>B 网站接受请求并验证身份，身份验证通过后，会发放令牌。向<code>redirect_uri</code> 指定的网址，发送包含令牌 <code>access_token</code> 字段的JSON数据，流程完毕。</li>
</ol>
<h3 id="2-隐藏式（implicit）"><a href="#2-隐藏式（implicit）" class="headerlink" title="2. 隐藏式（implicit）"></a>2. 隐藏式（implicit）</h3><p>即<strong>隐藏授权码步骤，直接向前端发放令牌</strong>，也称授权码隐藏式。</p>
<h4 id="整体流程-1"><a href="#整体流程-1" class="headerlink" title="整体流程"></a>整体流程</h4><p><img src="http://images.pingan8787.com/blog/20191028-OAuth2-05.png" alt="20191028-OAuth2-05.png"></p>
<p>（配图来自<strong>阮一峰大佬</strong>）</p>
<h4 id="步骤分析-1"><a href="#步骤分析-1" class="headerlink" title="步骤分析"></a>步骤分析</h4><ol>
<li>用户从 A 网站跳转到 B 网站，要求授权用户数据给 A 网站使用。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=<span class="built_in">read</span></span><br></pre></td></tr></table></figure>
<p><code>response_type</code> 参数为 <code>token</code>，表示<strong>要求直接返回令牌</strong>。</p>
<ol start="2">
<li>用户在 B 网站同意授权给 A 网站。</li>
</ol>
<p>当用户同意授权后，会跳转到 <code>redirect_uri</code> 参数指定的重定向地址，并将令牌作为 <code>URL</code> 参数传递给 A 网站。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://a.com/callback<span class="comment">#token=ACCESS_TOKEN</span></span><br></pre></td></tr></table></figure>

<p><code>token</code> 参数就是令牌，A 网站因此直接在前端拿到令牌。</p>
<p><strong>注意：</strong></p>
<p>这里的令牌位置是 <code>URL</code> 锚点（即 <code>#</code> 号），而不是查询字符串，这是因为锚点不会发到服务器，避免泄露令牌的风险。</p>
<p><strong>适用场景：</strong></p>
<p>由于直接传递令牌不安全，因此常常适用在对安全要求不高的场景，并且令牌有效期非常短，例如会话期间（session）有效，关闭浏览器便失效。</p>
<h3 id="3-密码式（password）"><a href="#3-密码式（password）" class="headerlink" title="3. 密码式（password）"></a>3. 密码式（password）</h3><p>即：<strong>对于信任的应用，可以携带约定的用户名和密码进行令牌申请</strong>。</p>
<h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><p><img src="http://images.pingan8787.com/blog/20191028-OAuth2-07.png" alt="20191028-OAuth2-07.png"></p>
<ol>
<li>A 网站使用 B 网站提供的用户名和密码，向 B 网站发起令牌请求。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://oauth.b.com/token?</span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=USERNAME&amp;</span><br><span class="line">  password=PASSWORD&amp;</span><br><span class="line">  client_id=CLIENT_ID</span><br></pre></td></tr></table></figure>

<p><code>grant_type</code> 参数是授权方式，这里的 <code>password</code> 表示”密码式”；<br><code>username</code> 和 <code>password</code> 是 B 的用户名和密码。</p>
<ol start="2">
<li>B 网站验证身份后直接将令牌存在 JSON 数据中，作为 HTTP 相应返回令牌给 A 网站。</li>
</ol>
<p><strong>适用场景：</strong></p>
<p>风险较大，一般适用在对应用高度信任的情况。</p>
<h3 id="4-客户端凭证（client-credentials）"><a href="#4-客户端凭证（client-credentials）" class="headerlink" title="4. 客户端凭证（client credentials）"></a>4. 客户端凭证（client credentials）</h3><p>即：<strong>给出凭证让对方确认并提供令牌</strong>。</p>
<h4 id="流程分析-1"><a href="#流程分析-1" class="headerlink" title="流程分析"></a>流程分析</h4><ol>
<li>A 应用在命令行向 B 发出请求。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://oauth.b.com/token?</span><br><span class="line">  grant_type=client_credentials&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET</span><br></pre></td></tr></table></figure>

<p><code>grant_type</code> 参数等于 <code>client_credentials</code> 表示采用凭证式；<br><code>client_id</code> 和 <code>client_secret</code> 用来让 B 确认 A 的身份。</p>
<ol start="2">
<li>B 网站验证身份后返回令牌。</li>
</ol>
<p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p>
<p><strong>适用场景：</strong></p>
<p>通过命令行请求令牌。</p>
<h4 id="流程分析-2"><a href="#流程分析-2" class="headerlink" title="流程分析"></a>流程分析</h4><p><img src="http://images.pingan8787.com/blog/20191028-OAuth2-06.png" alt="20191028-OAuth2-06.png"></p>
<h2 id="五、使用令牌"><a href="#五、使用令牌" class="headerlink" title="五、使用令牌"></a>五、使用令牌</h2><p>当网站获取到令牌以后，接下来每个 API 请求都需要带上令牌，其做法是在请求的头信息中，将令牌添加 <code>Authorization</code> 字段中。</p>
<h2 id="六、更新令牌"><a href="#六、更新令牌" class="headerlink" title="六、更新令牌"></a>六、更新令牌</h2><p>当令牌有效期到了，OAuth2 允许用户自动更新令牌，而不用让用户重新授权获取新令牌。</p>
<p><strong>具体流程：</strong></p>
<p>在 B 网站发放令牌时，一次性发放 2 个令牌，一个用于获取数据，一个用于获取新的令牌（<code>refresh token</code> 字段）。令牌到期后，用户使用 <code>refresh token</code> 发送请求去更新令牌：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/token?</span><br><span class="line">  grant_type=refresh_token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET&amp;</span><br><span class="line">  refresh_token=REFRESH_TOKEN</span><br></pre></td></tr></table></figure>
<p><code>grant_type</code> 参数为 <code>refresh_token</code> 表示要求更新令牌;<br><code>client_id</code> 参数和 <code>client_secret</code> 参数用于确认身份;<br><code>refresh_token</code> 参数就是用于更新令牌的令牌。</p>
<p>B 网站验证通过以后，就会颁发新的令牌。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li>部门内部培训资料</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Wddpct/p/8976480.html">《OAuth 2 深入介绍》</a></li>
<li><a href="www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">《阮一峰 理解OAuth 2.0》</a></li>
<li><a href="www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">《阮一峰 OAuth 2.0 的四种方式》</a></li>
</ol>
<h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><blockquote>
<p>本文首发在 <a target="_blank" rel="noopener" href="http://www.pingan8787.com/">pingan8787个人博客</a>，如需转载请联系本人。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#105;&#110;&#x67;&#x61;&#x6e;&#56;&#55;&#x38;&#x37;&#64;&#113;&#113;&#x2e;&#99;&#111;&#x6d;">&#x70;&#105;&#110;&#x67;&#x61;&#x6e;&#56;&#55;&#x38;&#x37;&#64;&#113;&#113;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>ES小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>
<h3 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h3><p><img src="http://images.pingan8787.com/blog/2019_10_24guild_page.png" alt="bg">  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/30/179-%E3%80%90%E5%85%A8%E6%A0%88%E4%BF%AE%E7%82%BC%E3%80%91OAuth2%E4%BF%AE%E7%82%BC%E5%AE%9D%E5%85%B8/" data-id="ckts3ejtr004k4d9k11eh94cz" data-title="179-【全栈修炼】OAuth2修炼宝典" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/" rel="tag">全栈开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-178-【MobX】MobX简单入门教程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/24/178-%E3%80%90MobX%E3%80%91MobX%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2019-10-24T14:52:16.000Z" itemprop="datePublished">2019-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/24/178-%E3%80%90MobX%E3%80%91MobX%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">178-【MobX】MobX简单入门教程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="http://images.pingan8787.com/blog/20191024MobX_Cover.png" alt="Cover"></p>
<h1 id="一、MobX-介绍"><a href="#一、MobX-介绍" class="headerlink" title="一、MobX 介绍"></a>一、MobX 介绍</h1><p>首先看下官网介绍： </p>
<blockquote>
<p>MobX 是一个经过战火洗礼的库，它通过透明的函数响应式编程(transparently applying functional reactive programming - TFRP)使得状态管理变得简单和可扩展。MobX背后的哲学很简单:<br>任何源自应用状态的东西都应该自动地获得。<br>其中包括UI、数据序列化、服务器通讯，等等。</p>
</blockquote>
<p>核心重点就是：<strong>MobX 通过响应式编程实现简单高效，可扩展的状态管理</strong>。</p>
<img src="http://images.pingan8787.com/blog/mobx.png" width="120px"/>

<h2 id="React-和-Mobx-关系"><a href="#React-和-Mobx-关系" class="headerlink" title="React 和 Mobx 关系"></a>React 和 Mobx 关系</h2><p>React 和 MobX 相辅相成，相互合作。</p>
<p>官网介绍：</p>
<blockquote>
<p>React 通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而MobX提供机制来存储和更新应用状态供 React 使用。</p>
</blockquote>
<h2 id="Mobx-工作流程"><a href="#Mobx-工作流程" class="headerlink" title="Mobx 工作流程"></a>Mobx 工作流程</h2><p>这里先了解下大概整理流程，接下来会结合代码，介绍每一个部分。</p>
<p><img src="http://images.pingan8787.com/blog/2019102303.png" alt="2019102303.png"></p>
<h2 id="本文概要"><a href="#本文概要" class="headerlink" title="本文概要"></a>本文概要</h2><p>本文使用的是 MobX 5 版本，主要将从以下几个方面介绍 MobX 的使用：</p>
<ol>
<li>配置 Webpack 的 MobX 开发环境</li>
<li>MobX 常用 API 介绍（主要介绍与<strong>可观察数据</strong>相关的操作）</li>
<li>MobX 简单实例</li>
</ol>
<p><img src="http://images.pingan8787.com/blog/20191024cover.png" alt="cover"></p>
<h1 id="二、配置-Webpack-的-MobX-开发环境"><a href="#二、配置-Webpack-的-MobX-开发环境" class="headerlink" title="二、配置 Webpack 的 MobX 开发环境"></a>二、配置 Webpack 的 MobX 开发环境</h1><ul>
<li>安装 webpack 和 babel 依赖包：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm i webpack webpack-cli babel-core babel-preset-env babel-loader -D</span><br></pre></td></tr></table></figure>

<ul>
<li>安装 MobX 相关依赖包：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnpm i mobx-react -D</span><br><span class="line">cnpm i babel-plugin-transform-class-properties -D </span><br><span class="line">cnpm i babel-plugin-transform-decorators-legacy -D </span><br></pre></td></tr></table></figure>

<ul>
<li>webpack.config.js 中添加配置：</li>
</ul>
<p>注意：<code>transform-decorators-legacy</code> 一定放在第一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: path.resolve(__dirname, <span class="string">&#x27;src/index.js&#x27;</span>),</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>:  path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [&#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: &#123;</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                    <span class="attr">presets</span>: [<span class="string">&#x27;env&#x27;</span>],</span><br><span class="line">                    <span class="attr">plugins</span>: [<span class="string">&#x27;transform-decorators-legacy&#x27;</span>, <span class="string">&#x27;transform-class-properties&#x27;</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;inline-source-map&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure>


<h1 id="三、MobX-常用-API-介绍"><a href="#三、MobX-常用-API-介绍" class="headerlink" title="三、MobX 常用 API 介绍"></a>三、MobX 常用 API 介绍</h1><h2 id="1-设置可观察数据（observable）"><a href="#1-设置可观察数据（observable）" class="headerlink" title="1. 设置可观察数据（observable）"></a>1. 设置可观察数据（observable）</h2><h3 id="1-1-observable"><a href="#1-1-observable" class="headerlink" title="1.1 (@)observable"></a>1.1 (@)observable</h3><p><code>observable</code> 是一种让数据的变化可以被观察的方法，底层是通过把该属性转化成 <code>getter</code> / <code>setter</code> 来实现的。。</p>
<p><code>observable</code> 值可以是 JS原始数据类型、引用类型、普通对象、类实例、数组和映射。</p>
<h4 id="observable-使用"><a href="#observable-使用" class="headerlink" title="observable 使用"></a>observable 使用</h4><ul>
<li>对于<strong>JS原始类型</strong>（<code>Number</code>/<code>String</code>/<code>Boolean</code>）， 使用<code>observable.box()</code>方法设置:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = observable.box(<span class="number">99</span>)</span><br><span class="line"><span class="keyword">const</span> str = observable.box(<span class="string">&#x27;leo&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bool = observable.box(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取原始值  get()</span></span><br><span class="line"><span class="built_in">console</span>.log(num.get(),str.get(),bool.get())   <span class="comment">// 99 &quot;leo&quot; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原始值  set(params)</span></span><br><span class="line">num.set(<span class="number">100</span>);</span><br><span class="line">str.set(<span class="string">&#x27;pingan&#x27;</span>);</span><br><span class="line">bool.set(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num.get(),str.get(),bool.get())  <span class="comment">// 100 &quot;pingan&quot; false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于<strong>数组</strong>、<strong>对象类型</strong>，使用 <code>observable()</code> 方法设置：   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = observable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line">list[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">list.push(<span class="number">5</span>) <span class="comment">// 可以调用数组方法</span></span><br><span class="line"><span class="built_in">console</span>.log(list[<span class="number">0</span>], list[<span class="number">1</span>], list[<span class="number">2</span>], list[<span class="number">3</span>]) <span class="comment">// 1 2 3 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = observable(&#123;<span class="attr">a</span>: <span class="string">&#x27;11&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;22&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.a, obj.b) <span class="comment">// 11 22</span></span><br><span class="line">obj.a = <span class="string">&quot;leo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a, obj.b) <span class="comment">// leo 22</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>需要注意的是：</strong>应该避免<strong>下标越界</strong>去方法数组中的值，这样的数据将不会被 MobX 所监视：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = observable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="built_in">console</span>.log(list[<span class="number">9</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>因此在实际开发中，需要注意数组长度的判断。</p>
<ul>
<li>对于<strong>映射</strong>（Map）类型，使用 <code>observable.map()</code> 方法设置：   </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = observable.map(&#123; <span class="attr">key</span>: <span class="string">&quot;value&quot;</span>&#125;);</span><br><span class="line">map.set(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;new value&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&#x27;key&#x27;</span>))  <span class="comment">// true</span></span><br><span class="line">map.delete(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&#x27;key&#x27;</span>))  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="observable-使用-1"><a href="#observable-使用-1" class="headerlink" title="@observable 使用"></a>@observable 使用</h4><p>MobX 也提供使用装饰器 <code>@observable</code> 来将其转换成可观察的，可以使用在实例的字段和属性上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leo</span> </span>&#123;</span><br><span class="line">    @observable arr = [<span class="number">1</span>];</span><br><span class="line">    @observable obj = &#123;&#125;;</span><br><span class="line">    @observable map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    @observable str = <span class="string">&#x27;leo&#x27;</span>;</span><br><span class="line">    @observable num = <span class="number">100</span>;</span><br><span class="line">    @observable bool = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> leo = <span class="keyword">new</span> Leo()</span><br><span class="line"><span class="built_in">console</span>.log(leo.arr[<span class="number">0</span>]) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>


<p>相比于前面使用 <code>observable.box() </code>方法对<strong>JS原始类型</strong>（<code>Number</code>/<code>String</code>/<code>Boolean</code>）进行定义，装饰器 <code>@observable</code> 则可以直接定义这些类型。</p>
<p>原因是装饰器 <code>@observable</code> 更进一步封装了 <code>observable.box()</code>。</p>
<h2 id="2-响应可观察数据的变化"><a href="#2-响应可观察数据的变化" class="headerlink" title="2. 响应可观察数据的变化"></a>2. 响应可观察数据的变化</h2><h3 id="2-1-computed"><a href="#2-1-computed" class="headerlink" title="2.1 (@)computed"></a>2.1 (@)computed</h3><p><strong>计算值</strong>(computed values)是可以根据现有的状态或其它计算值进行组合计算的值。可以使实际可修改的状态尽可能的小。 </p>
<p>此外计算值还是<strong>高度优化过</strong>的，所以尽可能的多使用它们。</p>
<p><strong>可以简单理解为：</strong>它是<strong>相关状态变化时自动更新的值</strong>，可以将多个可观察数据合并成一个可观察数据，并且只有在<strong>被使用时才会自动更新</strong>。</p>
<h4 id="知识点：使用方式"><a href="#知识点：使用方式" class="headerlink" title="知识点：使用方式"></a>知识点：使用方式</h4><ul>
<li><strong>使用方式1：声明式创建</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable, computed&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">    @observable price = <span class="number">0</span>;</span><br><span class="line">    @observable amount = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">price = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed <span class="keyword">get</span> <span class="title">total</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.price * <span class="built_in">this</span>.amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Money()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m.total) <span class="comment">// 2</span></span><br><span class="line">m.price = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.total) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用方式2：使用 decorate 引入</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;decorate, observable, computed&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">    price = <span class="number">0</span>;</span><br><span class="line">    amount = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">price = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">total</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.price * <span class="built_in">this</span>.amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">decorate(Money, &#123;</span><br><span class="line">    <span class="attr">price</span>: observable,</span><br><span class="line">    <span class="attr">amount</span>: observable,</span><br><span class="line">    <span class="attr">total</span>: computed</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Money()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m.total) <span class="comment">// 2</span></span><br><span class="line">m.price = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.total) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用方式3：使用 observable.object 创建</strong></li>
</ul>
<p><code>observable.object</code> 和 <code>extendObservable</code> 都会自动将 <code>getter</code> 属性推导成<strong>计算属性</strong>，所以下面这样就足够了:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Money = observable.object(&#123;</span><br><span class="line">    <span class="attr">price</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">amount</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">total</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.price * <span class="built_in">this</span>.amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Money.total) <span class="comment">// 0</span></span><br><span class="line">Money.price = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(Money.total) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意点</strong></li>
</ul>
<p>如果任何影响计算值的值发生变化了，计算值将根据状态自动进行变化。</p>
<p>如果前一个计算中使用的数据没有更改，计算属性将不会重新运行。 如果某个其它计算属性或 reaction 未使用该计算属性，也不会重新运行。 在这种情况下，它将被暂停。</p>
<h4 id="知识点：computed-的-setter"><a href="#知识点：computed-的-setter" class="headerlink" title="知识点：computed 的 setter"></a>知识点：computed 的 setter</h4><p><code>computed</code> 的 <code>setter</code> 不能用来改变<strong>计算属性的值</strong>，而是用来它里面的成员，来使得 <code>computed</code> 发生变化。</p>
<p>这里我们使用 <code>computed</code> 的第一种声明方式为例，其他几种方式实现起来类似：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable, computed&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">    @observable price = <span class="number">0</span>;</span><br><span class="line">    @observable amount = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">price = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed <span class="keyword">get</span> <span class="title">total</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.price * <span class="built_in">this</span>.amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">total</span>(<span class="params">n</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.price = n + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Money()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m.total) <span class="comment">// 2</span></span><br><span class="line">m.price = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.total) <span class="comment">// 20</span></span><br><span class="line">m.total = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.total) <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>

<p>从上面实现方式可以看出，<code>set total</code> 方法中接收一个参数 <code>n</code> 作为 <code>price</code> 的新值，我们调用 <code>m.total</code> 后设置了新的 <code>price</code>，于是 <code>m.total</code> 的值也随之发生改变。 </p>
<p><strong>注意：</strong><br>一定在 geeter 之后定义 setter，一些 typescript 版本会认为声明了两个名称相同的属性。</p>
<h4 id="知识点：computed-expression-函数"><a href="#知识点：computed-expression-函数" class="headerlink" title="知识点：computed(expression) 函数"></a>知识点：computed(expression) 函数</h4><p>一般可以通过下面两种方法观察变化，并获取计算值：</p>
<ul>
<li>方法1： 将 <code>computed</code> 作为函数调用，在返回的对象使用 <code>.get()</code> 来获取计算的当前值。</li>
<li>方法2： 使用 <code>observe(callback)</code> 来观察值的改变，其计算后的值在 <code>.newValue</code> 上。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable, computed&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> leo = observable.box(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> upperCaseName = computed(<span class="function">() =&gt;</span> leo.get().toUpperCase())</span><br><span class="line"><span class="keyword">let</span> disposer = upperCaseName.observe(<span class="function"><span class="params">change</span> =&gt;</span> <span class="built_in">console</span>.log(change.newValue))</span><br><span class="line">leo.set(<span class="string">&#x27;pingan&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>更详细的 <code>computed</code> 参数可以查看文档：<a target="_blank" rel="noopener" href="https://cn.mobx.js.org/refguide/computed-decorator.html">《Computed 选项》</a>。</p>
<h4 id="知识点：错误处理"><a href="#知识点：错误处理" class="headerlink" title="知识点：错误处理"></a>知识点：错误处理</h4><p>计算值在计算期间抛出异常，则此异常会被捕获，并<strong>在读取其值的时候抛出异常</strong>。</p>
<p>抛出异常<strong>不会中断跟踪</strong>，所有计算值可以从异常中恢复。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable, computed&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> x = observable.box(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> y = observable.box(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> div = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(y.get() === <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;y 为0了&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> x.get() / y.get()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">div.get() <span class="comment">// 5</span></span><br><span class="line">y.set(<span class="number">0</span>)  <span class="comment">// ok</span></span><br><span class="line">div.get() <span class="comment">// 报错，y 为0了</span></span><br><span class="line"></span><br><span class="line">y.set(<span class="number">5</span>)</span><br><span class="line">div.get() <span class="comment">// 恢复正常，返回 2</span></span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>用法：</p>
<ul>
<li><code>computed(() =&gt; expression)</code></li>
<li><code>computed(() =&gt; expression, (newValue) =&gt; void)</code></li>
<li><code>computed(() =&gt; expression, options)</code></li>
<li><code>@computed(&#123;equals: compareFn&#125;) get classProperty() &#123; return expression; &#125;</code></li>
<li><code>@computed get classProperty() &#123; return expression; &#125;</code></li>
</ul>
<p>还有各种选项可以控制 <code>computed</code> 的行为。包括:</p>
<ul>
<li><code>equals: (value, value) =&gt; boolean</code> 用来重载默认检测规则的比较函数。 内置比较器有: <code>comparer.identity</code>, <code>comparer.default</code>, <code>comparer.structural</code>；</li>
<li><code>requiresReaction: boolean</code> 在重新计算衍生属性之前，等待追踪的 <code>observables</code> 值发生变化；</li>
<li><code>get: () =&gt; value)</code> 重载计算属性的 <code>getter</code>；</li>
<li><code>set: (value) =&gt; void</code> 重载计算属性的 <code>setter</code>；</li>
<li><code>keepAlive: boolean</code> 设置为 <code>true</code> 以自动保持计算值活动，而不是在没有观察者时暂停；</li>
</ul>
<h3 id="2-2-autorun"><a href="#2-2-autorun" class="headerlink" title="2.2 autorun"></a>2.2 autorun</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>autorun</code> 直译就是<strong>自动运行</strong>的意思，那么我们要知道这两个问题：</p>
<ul>
<li>自动运行什么？</li>
</ul>
<p>即：自动运行传入 <code>autorun</code> 的参数函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, autorun &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    @observable str = <span class="string">&#x27;leo&#x27;</span>;</span><br><span class="line">    @observable num = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Store()</span><br><span class="line">autorun(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;store.str&#125;</span>--<span class="subst">$&#123;store.num&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// leo--123</span></span><br></pre></td></tr></table></figure>

<p>可以看出 <code>autorun</code> 自动被运行一次，并输出 <code>leo--123</code> 的值，显然这还不是自动运行。</p>
<ul>
<li>怎么触发自动运行？</li>
</ul>
<p><strong>当修改 autorun 中任意一个可观察数据</strong>即可触发自动运行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 紧接上部分代码</span></span><br><span class="line"></span><br><span class="line">store.str = <span class="string">&#x27;pingan&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// leo--123</span></span><br><span class="line"><span class="comment">// pingan--123</span></span><br></pre></td></tr></table></figure>

<p>现在可以看到控制台输出这两个日志，证明 <code>autorun</code> 已经被执行两次。</p>
<h4 id="知识点：观察-computed-的数据"><a href="#知识点：观察-computed-的数据" class="headerlink" title="知识点：观察 computed 的数据"></a>知识点：观察 computed 的数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, autorun &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    @observable str = <span class="string">&#x27;leo&#x27;</span>;</span><br><span class="line">    @observable num = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    @computed <span class="keyword">get</span> <span class="title">all</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;store.str&#125;</span>--<span class="subst">$&#123;store.num&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Store()</span><br><span class="line">autorun(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(store.all)</span><br><span class="line">&#125;)</span><br><span class="line">store.str = <span class="string">&#x27;pingan&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// leo--123</span></span><br><span class="line"><span class="comment">// pingan--123</span></span><br></pre></td></tr></table></figure>

<p>可以看出，这样将 <code>computed</code> 的值在 <code>autorun</code> 中进行观察，也是可以达到一样的效果，这也是我们实际开发中常用到的。</p>
<h4 id="知识点：computed-与-autorun-区别"><a href="#知识点：computed-与-autorun-区别" class="headerlink" title="知识点：computed 与 autorun 区别"></a>知识点：computed 与 autorun 区别</h4><p><strong>相同点：</strong></p>
<p>都是响应式调用的表达式；</p>
<p><strong>不同点：</strong></p>
<ul>
<li><code>@computed</code> 用于响应式的产生一个可以被其他 observer 使用的<strong>值</strong>；</li>
<li><code>autorun</code> 不产生新的值，而是<strong>达到一个效果</strong>（如：打印日志，发起网络请求等命令式的副作用）；</li>
<li><code>@computed</code>中，如果一个计算值不再被观察了，MobX 可以自动地将其<strong>垃圾回收</strong>，而 <code>autorun</code> 中的值必须要手动清理才行。</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><code>autorun</code> 默认会执行一次，以获取哪些可观察数据被引用。</p>
<p><code>autorun</code> 的作用是在<strong>可观察数据被修改之后</strong>，<strong>自动去执行依赖可观察数据的行为</strong>，这个行为一直就是传入 <code>autorun</code> 的函数。</p>
<h3 id="2-3-when"><a href="#2-3-when" class="headerlink" title="2.3 when"></a>2.3 when</h3><p>接收两个函数参数，第一个函数<strong>必须根据可观察数据来返回一个布尔值</strong>，当该布尔值为 <code>true</code> 时，才会去执行第二个函数，并且只会执行一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, when &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leo</span> </span>&#123;</span><br><span class="line">    @observable str = <span class="string">&#x27;leo&#x27;</span>;</span><br><span class="line">    @observable num = <span class="number">123</span>;</span><br><span class="line">    @observable bool = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> leo = <span class="keyword">new</span> Leo()</span><br><span class="line">when(<span class="function">() =&gt;</span> leo.bool, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;这是true&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">leo.bool = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 这是true</span></span><br></pre></td></tr></table></figure>

<p>可以看出当 <code>leo.bool</code> 设置成 <code>true</code> 以后，<code>when</code> 的第二个方法便执行了。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li><p>第一个参数，必须是根据<strong>可观察数据</strong>来返回的布尔值，而不是普通变量的布尔值。</p>
</li>
<li><p>如果第一个参数默认值为 <code>true</code>，则 <code>when</code> 函数会默认执行一次。</p>
</li>
</ol>
<h3 id="2-4-reaction"><a href="#2-4-reaction" class="headerlink" title="2.4 reaction"></a>2.4 reaction</h3><p>接收两个函数参数，第一个函数<strong>引用可观察数据，并返回一个可观察数据</strong>，作为第二个函数的参数。</p>
<p><code>reaction</code> <strong>第一次渲染的时候，会先执行一次第一个函数</strong>，这样 MobX 就会知道哪些可观察数据被引用了。随后在这些数据被修改的时候，执行第二个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, reaction &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leo</span> </span>&#123;</span><br><span class="line">    @observable str = <span class="string">&#x27;leo&#x27;</span>;</span><br><span class="line">    @observable num = <span class="number">123</span>;</span><br><span class="line">    @observable bool = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> leo = <span class="keyword">new</span> Leo()</span><br><span class="line">reaction(<span class="function">() =&gt;</span> [leo.str, leo.num], <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;)</span><br><span class="line">leo.str = <span class="string">&#x27;pingan&#x27;</span></span><br><span class="line">leo.num = <span class="number">122</span></span><br><span class="line"><span class="comment">// [&quot;pingan&quot;, 122]</span></span><br><span class="line"><span class="comment">// [&quot;pingan&quot;, 122]</span></span><br></pre></td></tr></table></figure>

<p>这里我们依次修改 <code>leo.str</code> 和 <code>leo.num</code> 两个变量，会发现 <code>reaction</code> 方法被执行<strong>两次</strong>，在控制台输出<strong>两次</strong>结果 <code>[&quot;pingan&quot;, 122]</code> ，因为可观察数据 <code>str</code> 和 <code>num</code> <strong>分别</strong>被修改了一次。</p>
<p><strong>实际使用场景：</strong></p>
<p>当我们没有获取到数据的时候，没有必要去执行存缓存逻辑，当第一次获取到数据以后，就执行存缓存的逻辑。</p>
<h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><ul>
<li><p><code>computed</code> 可以将多个可观察数据组合成一个可观察数据；</p>
</li>
<li><p><code>autorun</code> 可以自动追踪所引用的可观察数据，并在数据发生变化时自动触发；</p>
</li>
<li><p><code>when</code> 可以设置自动触发变化的时机，是 <code>autorun</code> 的一个变种情况；</p>
</li>
<li><p><code>reaction</code> 可以通过分离可观察数据声明，以副作用的方式对 <code>autorun</code> 做出改进；</p>
</li>
</ul>
<p>它们各有特点，互为补充，都能在合适场景中发挥重要作用。</p>
<h2 id="3-修改可观察数据"><a href="#3-修改可观察数据" class="headerlink" title="3. 修改可观察数据"></a>3. 修改可观察数据</h2><p>在上一部分内容中，我们了解到，对可观察的数据做出反应的时候，需要我们手动修改可观察数据的值。这种修改是通过直接向变量赋值来实现的，虽然简单易懂，但是这样会带来一个较为严重的副作用，就是<strong>每次的修改</strong>都会触发 <code>autorun</code> 或者 <code>reaction</code> <strong>运行一次</strong>。多数情况下，这种高频的触发是完全没有必要的。</p>
<p>比如用户对视图的一次点击操作需要很多修改 N 个状态变量，但是视图的更新只需要一次就够了。</p>
<p>为了优化这个问题， MobX 引入了 <code>action</code> 。</p>
<h3 id="3-1-action"><a href="#3-1-action" class="headerlink" title="3.1 (@)action"></a>3.1 (@)action</h3><p><code>action</code> 是修改任何状态的行为，使用 <code>action</code> 的好处是能<strong>将多次修改可观察状态合并成一次</strong>，从而减少触发 <code>autorun</code> 或者 <code>reaction</code> 的次数。</p>
<p>可以理解成<strong>批量操作</strong>，即一次动作中包含多次修改可观察状态，此时只会在动作结束后，做一次性重新计算和反应。</p>
<p><code>action</code> 也有两种使用方法，这里以 <code>decorate</code> 方式来介绍。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, computed, reaction, action&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    @observable string = <span class="string">&#x27;leo&#x27;</span>;</span><br><span class="line">    @observable number = <span class="number">123</span>;</span><br><span class="line">    @action <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.string = <span class="string">&#x27;pingan&#x27;</span></span><br><span class="line">        <span class="built_in">this</span>.number = <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Store()</span><br><span class="line">reaction(<span class="function">() =&gt;</span> [store.string, store.number], <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;)</span><br><span class="line">store.bar() <span class="comment">// [&quot;pingan&quot;, 100]</span></span><br></pre></td></tr></table></figure>

<p>当我们连续去修改 <code>store.string</code> 和 <code>store.number</code> 两个变量后，再运行 <code>store.bar()</code> 会发现，控制台值输出一次 <code>[&quot;pingan&quot;, 100]</code> ，这就说明 <code>reaction</code> 只被执行一次。</p>
<h4 id="知识点：action-bound"><a href="#知识点：action-bound" class="headerlink" title="知识点：action.bound"></a>知识点：action.bound</h4><p>另外 <code>action</code> 还有一种特殊使用方法：<code>action.bound</code>，常常用来作为一个 <code>callback</code> 的方法参数，并且执行效果也是一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, computed, reaction, action&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    @observable string = <span class="string">&#x27;leo&#x27;</span>;</span><br><span class="line">    @observable number = <span class="number">123</span>;</span><br><span class="line">    @action.bound <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.string = <span class="string">&#x27;pingan&#x27;</span></span><br><span class="line">        <span class="built_in">this</span>.number = <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Store()</span><br><span class="line">reaction(<span class="function">() =&gt;</span> [store.string, store.number], <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> bar = store.bar;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">fun</span>)</span>&#123;</span><br><span class="line">    fun()</span><br><span class="line">&#125;</span><br><span class="line">foo(bar) <span class="comment">//[&quot;pingan&quot;, 100]</span></span><br></pre></td></tr></table></figure>

<h4 id="知识点：runInAction-name-thunk"><a href="#知识点：runInAction-name-thunk" class="headerlink" title="知识点：runInAction(name?, thunk)"></a>知识点：runInAction(name?, thunk)</h4><p><code>runInAction</code> 是个简单的工具函数，它接收代码块并在(异步的)动作中执行。这对于即时创建和执行动作非常有用，例如在<strong>异步过程</strong>中。<code>runInAction(f)</code> 是 <code>action(f)()</code> 的语法糖。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, computed, reaction, action&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    @observable string = <span class="string">&#x27;leo&#x27;</span>;</span><br><span class="line">    @observable number = <span class="number">123</span>;</span><br><span class="line">    @action.bound <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.string = <span class="string">&#x27;pingan&#x27;</span></span><br><span class="line">        <span class="built_in">this</span>.number = <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Store()</span><br><span class="line">reaction(<span class="function">() =&gt;</span> [store.string, store.number], <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;)</span><br><span class="line">runInAction(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    store.string = <span class="string">&#x27;pingan&#x27;</span></span><br><span class="line">    store.number = <span class="number">100</span></span><br><span class="line">&#125;)<span class="comment">//[&quot;pingan&quot;, 100]</span></span><br></pre></td></tr></table></figure>

<h1 id="四、-Mobx-React-简单实例"><a href="#四、-Mobx-React-简单实例" class="headerlink" title="四、 Mobx-React 简单实例"></a>四、 Mobx-React 简单实例</h1><p>这里以简单计数器为例，实现点击按钮，数值累加的简单操作，如图：</p>
<p><img src="http://images.pingan8787.com/blog/2019102301.png" alt="2019102301.png"></p>
<p>在这个案例中，我们引用 <code>mobx-react</code> 库来实现，很明显可以看出 <code>mobx-react</code> 是作为 <code>mobx</code> 和 <code>react</code> 之前的桥梁。</p>
<p>它将 <code>react</code> 组件转化为对可观察数据的反应，也就是将组件的 <code>render</code> 方法包装成 <code>autorun</code> 方法，使得状态变化时能自动重新渲染。</p>
<p>详细可以查看：<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/mobx-react">https://www.npmjs.com/package/mobx-react</a> 。</p>
<p>接下来开始我们的案例：</p>
<h2 id="1-安装依赖和配置webpack"><a href="#1-安装依赖和配置webpack" class="headerlink" title="1. 安装依赖和配置webpack"></a>1. 安装依赖和配置webpack</h2><p>由于配置和前面第二节介绍差不多，所以这里会以第二节的配置为基础，添加配置。</p>
<p>首先安装 <code>mobx-react</code> 依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm i mobx-react -D</span><br></pre></td></tr></table></figure>

<p>修改<code> webpack.config.js</code>，在 <code>presets</code> 配置中添加 <code>react</code> 进来：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// ... 省略其他</span><br><span class="line"><span class="deletion">- entry: path.resolve(__dirname, &#x27;src/index.js&#x27;),</span></span><br><span class="line"><span class="addition">+ entry: path.resolve(__dirname, &#x27;src/index.jsx&#x27;),</span></span><br><span class="line">module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: /\.jsx?$/,</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader: &#x27;babel-loader&#x27;,</span><br><span class="line">            options: &#123;</span><br><span class="line"><span class="deletion">-                 presets: [&#x27;env&#x27;],</span></span><br><span class="line"><span class="addition">+                 presets: [&#x27;env&#x27;, &#x27;react&#x27;],</span></span><br><span class="line">                plugins: [&#x27;transform-decorators-legacy&#x27;, &#x27;transform-class-properties&#x27;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="2-初始化-React-项目"><a href="#2-初始化-React-项目" class="headerlink" title="2. 初始化 React 项目"></a>2. 初始化 React 项目</h2><p>这里初始化一下我们本次项目的简单骨架：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.jsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; observable, action&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;observer, PropTypes <span class="keyword">as</span> observablePropTypes&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Store();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Foo</span> /&gt;</span></span>, <span class="built_in">document</span>.querySelector(<span class="string">&quot;#root&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>这些组件对应到我们最后页面效果如图：</p>
<p><img src="http://images.pingan8787.com/blog/2019102302.png" alt="2019102302.png"></p>
<h2 id="2-实现-Store-类"><a href="#2-实现-Store-类" class="headerlink" title="2. 实现 Store 类"></a>2. 实现 Store 类</h2><p><code>Store</code> 类用于存储数据。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    @observable cache = &#123; <span class="attr">queue</span>: [] &#125;</span><br><span class="line">    @action.bound <span class="function"><span class="title">refresh</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.cache.queue.push(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-实现-Bar-和-Foo-组件"><a href="#3-实现-Bar-和-Foo-组件" class="headerlink" title="3. 实现 Bar 和 Foo 组件"></a>3. 实现 Bar 和 Foo 组件</h2><p>实现代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@observer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        <span class="attr">queue</span>: observablePropTypes.observableArray</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> queue = <span class="built_in">this</span>.props.queue;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;queue.length&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        <span class="attr">cache</span>: observablePropTypes.observableObject</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.props.cache;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.props.refresh&#125;</span>&gt;</span>点击 + 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span> 当前数值：<span class="tag">&lt;<span class="name">Bar</span> <span class="attr">queue</span>=<span class="string">&#123;cache.queue&#125;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意： </p>
<ol>
<li><p>可观察数据类型中的数组，实际上并不是数组类型，这里需要用 <code>observablePropTypes.observableArray</code> 去声明它的类型，对象也是一样。</p>
</li>
<li><p><code>@observer</code> 在需要<strong>根据数据变换，而改变UI的组件去引用</strong>，另外建议<strong>有使用到相关数据的类</strong>都引用。</p>
</li>
<li><p>事实上，我们只需要记住 <code>observer</code> 方法，将所有 <code>React</code> 组件用 <code>observer</code> 修饰，就是 <code>react-mobx</code> 的用法。</p>
</li>
</ol>
<h2 id="4-使用-Foo-组件"><a href="#4-使用-Foo-组件" class="headerlink" title="4. 使用 Foo 组件"></a>4. 使用 Foo 组件</h2><p>最后我们使用 <code>Foo</code> 组件，需要给它传递两个参数，这样 <code>Bar</code> 组件才能拿到并使用：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Foo</span> <span class="attr">cache</span>=<span class="string">&#123;store.cache&#125;</span> <span class="attr">refresh</span>=<span class="string">&#123;store.refresh&#125;/</span>&gt;</span></span>, </span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&quot;#root&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>本文参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cn.mobx.js.org/">《MobX 官方文档》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.imooc.com/learn/1012">茵风泳月《MobX 入门基础教程》</a></li>
</ul>
<h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><blockquote>
<p>本文首发在 <a target="_blank" rel="noopener" href="http://www.pingan8787.com/">pingan8787个人博客</a>，如需转载请保留个人介绍。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#105;&#110;&#103;&#97;&#x6e;&#56;&#x37;&#x38;&#x37;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;">&#x70;&#105;&#110;&#103;&#97;&#x6e;&#56;&#x37;&#x38;&#x37;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>ES小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>
<h3 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h3><p><img src="http://images.pingan8787.com/blog/2019_10_24guild_page.png" alt="bg">  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/24/178-%E3%80%90MobX%E3%80%91MobX%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" data-id="ckts3ejyc00me4d9k7hwxc1dh" data-title="178-【MobX】MobX简单入门教程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/" rel="tag">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS%E5%8A%A8%E7%94%BB/" rel="tag">CSS动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome/" rel="tag">Chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6-ES7-ES8/" rel="tag">ES6/ES7/ES8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eslint/" rel="tag">Eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Express/" rel="tag">Express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GraphQL/" rel="tag">GraphQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/H5/" rel="tag">H5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP%E5%8D%8F%E8%AE%AE/" rel="tag">HTTP协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hybrid/" rel="tag">Hybrid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NPM/" rel="tag">NPM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Numpy/" rel="tag">Numpy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/" rel="tag">Tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TyeScript/" rel="tag">TyeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vuejs/" rel="tag">Vuejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/" rel="tag">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/demo/" rel="tag">demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" rel="tag">人工智能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/" rel="tag">全栈开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2/" rel="tag">前端探索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97/" rel="tag">前端知乎系列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/" rel="tag">常用技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" rel="tag">微前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" rel="tag">构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB/" rel="tag">源码精读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%83%AD%E9%97%A8/" rel="tag">热门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/" rel="tag">生活杂记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" rel="tag">网络请求</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E6%B8%A9%E5%9F%BA%E7%A1%80/" rel="tag">重温基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Angular/" style="font-size: 11.88px;">Angular</a> <a href="/tags/CSS/" style="font-size: 18.13px;">CSS</a> <a href="/tags/CSS%E5%8A%A8%E7%94%BB/" style="font-size: 12.5px;">CSS动画</a> <a href="/tags/Chrome/" style="font-size: 10px;">Chrome</a> <a href="/tags/ES6-ES7-ES8/" style="font-size: 10.63px;">ES6/ES7/ES8</a> <a href="/tags/Eslint/" style="font-size: 10px;">Eslint</a> <a href="/tags/Express/" style="font-size: 10px;">Express</a> <a href="/tags/GraphQL/" style="font-size: 10px;">GraphQL</a> <a href="/tags/H5/" style="font-size: 10px;">H5</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/HTTP/" style="font-size: 11.88px;">HTTP</a> <a href="/tags/HTTP%E5%8D%8F%E8%AE%AE/" style="font-size: 11.25px;">HTTP协议</a> <a href="/tags/Hybrid/" style="font-size: 10.63px;">Hybrid</a> <a href="/tags/JavaScript/" style="font-size: 19.38px;">JavaScript</a> <a href="/tags/NPM/" style="font-size: 10px;">NPM</a> <a href="/tags/Nodejs/" style="font-size: 11.25px;">Nodejs</a> <a href="/tags/Numpy/" style="font-size: 10.63px;">Numpy</a> <a href="/tags/Python/" style="font-size: 17.5px;">Python</a> <a href="/tags/React/" style="font-size: 12.5px;">React</a> <a href="/tags/Tensorflow/" style="font-size: 10.63px;">Tensorflow</a> <a href="/tags/TyeScript/" style="font-size: 10px;">TyeScript</a> <a href="/tags/TypeScript/" style="font-size: 11.25px;">TypeScript</a> <a href="/tags/Vuejs/" style="font-size: 14.38px;">Vuejs</a> <a href="/tags/WebSocket/" style="font-size: 10px;">WebSocket</a> <a href="/tags/Webpack/" style="font-size: 15.63px;">Webpack</a> <a href="/tags/demo/" style="font-size: 10.63px;">demo</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">中间件</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 16.25px;">人工智能</a> <a href="/tags/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/" style="font-size: 11.25px;">全栈开发</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 20px;">前端开发</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2/" style="font-size: 11.25px;">前端探索</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97/" style="font-size: 10.63px;">前端知乎系列</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 18.75px;">原创</a> <a href="/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/" style="font-size: 10.63px;">常用技术</a> <a href="/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">微前端</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 13.75px;">总结</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">机器学习</a> <a href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" style="font-size: 10.63px;">构建工具</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10.63px;">正则表达式</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 10px;">源码</a> <a href="/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB/" style="font-size: 10px;">源码精读</a> <a href="/tags/%E7%83%AD%E9%97%A8/" style="font-size: 10px;">热门</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/" style="font-size: 10px;">生活杂记</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.13px;">算法</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 10px;">编译原理</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" style="font-size: 10px;">网络请求</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.38px;">读书笔记</a> <a href="/tags/%E9%87%8D%E6%B8%A9%E5%9F%BA%E7%A1%80/" style="font-size: 16.88px;">重温基础</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 10px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/28/227-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8SVG%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/">227-【总结】如何优雅的在微信小程序使用SVG字体图标</a>
          </li>
        
          <li>
            <a href="/2021/07/28/226-%E3%80%90HTTP%E3%80%91%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9F/">226-【HTTP】如何优雅的管理HTTP请求和响应拦截器？</a>
          </li>
        
          <li>
            <a href="/2021/07/28/225-%E3%80%90Vue%E3%80%91%E4%BB%8E%E6%89%8B%E5%86%99Vue3%E7%9A%84Reactivity%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%85%A5Vue3%E6%BA%90%E7%A0%81/">225-【Vue】从手写Vue3的Reactivity开始深入Vue3源码</a>
          </li>
        
          <li>
            <a href="/2021/05/30/224-%E3%80%90Chrome%E3%80%915%E4%B8%AAChrome%E8%B0%83%E8%AF%95%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7/">224-【Chrome】5个Chrome调试混合应用的技巧</a>
          </li>
        
          <li>
            <a href="/2021/03/19/223-%E3%80%90%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2%E3%80%91%E6%8E%A2%E7%B4%A2Snabbdom%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">223-【前端探索】探索Snabbdom模块系统原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>