<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>193-【中间件】从koa和redux看如何设计中间件 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="编者按：本文作者林向东，360奇舞团前端工程师。中间件是一种实现「关注点分离」的设计模式，有多种实现方式，本文仅探讨koa&#x2F;redux是如何设计中间件。该模式有两个特点：  中间件middle是一个函数 middle有个next参数，也是函数，代表下个要执行的中间件。12345678910111213function m1(next) &amp;#123;  console.log(&quot;m1&amp;qu">
<meta property="og:type" content="article">
<meta property="og:title" content="193-【中间件】从koa和redux看如何设计中间件">
<meta property="og:url" content="http://example.com/2020/01/21/193-%E3%80%90%E4%B8%AD%E9%97%B4%E4%BB%B6%E3%80%91%E4%BB%8Ekoa%E5%92%8Credux%E7%9C%8B%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%AD%E9%97%B4%E4%BB%B6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="编者按：本文作者林向东，360奇舞团前端工程师。中间件是一种实现「关注点分离」的设计模式，有多种实现方式，本文仅探讨koa&#x2F;redux是如何设计中间件。该模式有两个特点：  中间件middle是一个函数 middle有个next参数，也是函数，代表下个要执行的中间件。12345678910111213function m1(next) &amp;#123;  console.log(&quot;m1&amp;qu">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-20T16:01:36.000Z">
<meta property="article:modified_time" content="2021-09-20T03:31:47.631Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="前端开发">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-193-【中间件】从koa和redux看如何设计中间件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/21/193-%E3%80%90%E4%B8%AD%E9%97%B4%E4%BB%B6%E3%80%91%E4%BB%8Ekoa%E5%92%8Credux%E7%9C%8B%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2020-01-20T16:01:36.000Z" itemprop="datePublished">2020-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      193-【中间件】从koa和redux看如何设计中间件
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>编者按：本文作者林向东，360奇舞团前端工程师。<br />中间件是一种实现「关注点分离」的设计模式，有多种实现方式，本文仅探讨koa/redux是如何设计中间件。该模式有两个特点：</p>
<ul>
<li>中间件middle是一个函数</li>
<li>middle有个next参数，也是函数，代表下个要执行的中间件。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function m1(next) &#123;</span><br><span class="line">  console.log(&quot;m1&quot;);</span><br><span class="line">  next();</span><br><span class="line">  console.log(&quot;v1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function m2(next) &#123;</span><br><span class="line">  console.log(&quot;m2&quot;);</span><br><span class="line">  next();</span><br><span class="line">  console.log(&quot;v2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function m3() &#123;</span><br><span class="line">  console.log(&quot;m3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如上所示：中间件 m1-&gt;m2-&gt;m3执行，打印结果为 m1-&gt;m2-&gt;m3-&gt;v2-&gt;v1。这种模式有个形象的名字，_洋葱模型_。但现在我们暂时忘记这些名字，就想想如何实现中间件（函数）的联动吧。有两种思路，第一是递归；第二是链式调用。<br><a name="5nPjD"></a><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2>设置一个数组按顺序存储函数，根据 index 值，按顺序一个个执行，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  function dispath(index) &#123;</span><br><span class="line">    if (index === arr.length) return;</span><br><span class="line">    const route = arr[index];</span><br><span class="line">    const next = () =&gt; dispath(index + 1); // 递归执行数组中下一个函数</span><br><span class="line">    return route(next);</span><br><span class="line">  &#125;</span><br><span class="line">  dispath(0);</span><br><span class="line">&#125;</span><br><span class="line">compose(middles); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
<a name="l3Vp1"></a><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2>将函数当作成参数传给上一个中间件，这样前一个中间件执行完就可以执行下一个中间件。<br><a name="Cxp1T"></a><h3 id="1、直接调用："><a href="#1、直接调用：" class="headerlink" title="1、直接调用："></a>1、直接调用：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1(() =&gt; m2(() =&gt; m3())); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br><span class="line">// m2的参数next是 () =&gt; m3()</span><br><span class="line">// m1的参数next是 () =&gt; m2(() =&gt; m3())</span><br></pre></td></tr></table></figure>
此种方法虽然可行，但是 m1，m2，m3 都是写死的，不是公共方法。<br><a name="SVJwr"></a><h3 id="2、构建next的函数createFn："><a href="#2、构建next的函数createFn：" class="headerlink" title="2、构建next的函数createFn："></a>2、构建next的函数createFn：</h3>我们观察到在传递参数时，m3 和 m2 都变成函数再传入，那这个变成函数的过程是否能提取：如下，参数 middle 是中间件，参数 next 是接下来要执行的函数。转换后 next 变成 middle 的参数。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createFn(middle, next) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    middle(next);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 需要先将后面的中间件变成我们需要的 next 函数：</span><br><span class="line">const fn3 = createFn(m3, null);</span><br><span class="line">const fn2 = createFn(m2, fn3);</span><br><span class="line">const fn1 = createFn(m1, fn2);</span><br><span class="line">fn1(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
这里 fn3/fn2/fn1 也是固定的，但我们看出这些中间状态变量，可以隐藏掉，统一用 next 代替：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let next = () =&gt; &#123;&#125;;</span><br><span class="line">next = createFn(m3, null);</span><br><span class="line">next = createFn(m2, next);</span><br><span class="line">next = createFn(m1, next);</span><br><span class="line">next(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
优化如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let next = () =&gt; &#123;&#125;;</span><br><span class="line">// 倒序</span><br><span class="line">for (let i = middles.length; i &gt;= 0; i--) &#123;</span><br><span class="line">  next = createFn(middles[i], next);</span><br><span class="line">&#125;</span><br><span class="line">next(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
<a name="iM3ym"></a><h3 id="3、redux-的-reduceRight"><a href="#3、redux-的-reduceRight" class="headerlink" title="3、redux 的 reduceRight"></a>3、redux 的 reduceRight</h3>仔细观察上面这种倒序，且每次拿上次的值进行计算的方法，是不是很像 reduceRight。（好吧，或许我们看不出来，但是早期 redux 就是这么实现的，我们直接拿过来研究）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduceRight(</span><br><span class="line">    (a, b) =&gt; &#123;</span><br><span class="line">      // b是middle，a是next，</span><br><span class="line">      return () =&gt; b(a); // 每次返回的是一个函数，执行这个函数为middle(next)，即b(a)</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; &#123;&#125; // 初始化的a值，空函数</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middles);</span><br><span class="line">mid(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
<a name="q7qBo"></a><h3 id="4、redux-的-reduce"><a href="#4、redux-的-reduce" class="headerlink" title="4、redux 的 reduce"></a>4、redux 的 reduce</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduce((a, b) =&gt; &#123;</span><br><span class="line">    return (...arg) =&gt; a(() =&gt; b(...arg)); // a 是 next函数，b是middle函数</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middles);</span><br><span class="line">mid(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
改成这种正序的方式，反而不好理解。尝试解释一下：a 是 next 函数，b 是 middle 函数。(…arg) =&gt; a(() =&gt; b(…arg)) 这简直就是我们最初这种写法 m1(() =&gt; m2(() =&gt; m3())) 的直接映射。摘抄一下这篇参考一作者的解释，感兴趣的同学可自行推导一下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 第 1 次 reduce 的返回值，下一次将作为 a</span><br><span class="line">arg =&gt; fn1(() =&gt; fn2(arg));</span><br><span class="line">// 第 2 次 reduce 的返回值，下一次将作为 a</span><br><span class="line">arg =&gt; (arg =&gt; fn1(() =&gt; fn2(arg)))(() =&gt; fn3(arg));</span><br><span class="line">// 等价于...</span><br><span class="line">arg =&gt; fn1(() =&gt; fn2(() =&gt; fn3(arg)));</span><br><span class="line">// 执行最后返回的函数连接中间件，返回值等价于...</span><br><span class="line">fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; &#123;&#125;)));</span><br></pre></td></tr></table></figure>
明白reduceRight到reduce转换不是最关键的，关键的是明白上面几种写法让我们能链式调用函数。<br><a name="i1JRO"></a><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2>设计一个中间件模式，怎么能少得了参数的传递。我们先想想<strong>如何组织我们中间件</strong>：很明显，我们通过 next 执行下个中间件，那么传值给下个中间件就是给 next 添加参数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function m1(next) &#123;</span><br><span class="line">  console.log(&quot;m1&quot;);</span><br><span class="line">  next(&quot;v2&quot;); // 将&#x27;v2&#x27;传给下个中间件m2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
那么 m2 该怎么获取这个值呢？因为 next 代表 m2 执行后的值，next 传递参数就是说 m2 需要返回函数，该函数的参数就是传递的值，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function m2(next) &#123;</span><br><span class="line">  return function(action) &#123;</span><br><span class="line">    // 这个action就是上一个函数传来的&#x27;v2&#x27;</span><br><span class="line">    next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这种写法等价于：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const m2 = next =&gt; action =&gt; &#123;</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
所以按照上面这种方式组织我们的中间件，我们就既能链式执行又能传递参数。如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const m1 = next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;m1&quot;, action);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br><span class="line">const m2 = next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;m2&quot;, action);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br><span class="line">const m3 = next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;m3&quot;, action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
那我们如何实现呢？<br><a name="CdlL8"></a><h3 id="1、直接调用：-1"><a href="#1、直接调用：-1" class="headerlink" title="1、直接调用："></a>1、直接调用：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1(arg =&gt; m2(() =&gt; m3()(arg))(arg))(&quot;666&quot;);</span><br><span class="line">// 打印：m1,m2,m3都打印666</span><br></pre></td></tr></table></figure>
<a name="uEuf6"></a><h3 id="2、创建createFn函数："><a href="#2、创建createFn函数：" class="headerlink" title="2、创建createFn函数："></a>2、创建createFn函数：</h3>createFn返回的函数添加了参数action，代表了中间件之间的参数。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 我们给返回的函数加上参数action并执行</span><br><span class="line">function createFn(middle, next) &#123;</span><br><span class="line">  return function (action) &#123;</span><br><span class="line">    middle(next)(action);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">let next = () =&gt; &#123;&#125;;</span><br><span class="line">for (let i = middles.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">  next = createFn(middles[i], next);</span><br><span class="line">&#125;</span><br><span class="line">next(&quot;666&quot;); // 打印：m1,m2,m3都打印666</span><br></pre></td></tr></table></figure>
<a name="MGpsi"></a><h3 id="3、-redux-的-reduceRight-与-reduce："><a href="#3、-redux-的-reduceRight-与-reduce：" class="headerlink" title="3、 redux 的 reduceRight 与 reduce："></a>3、 redux 的 reduceRight 与 reduce：</h3>返回的结果直接执行，因为我们加了一层返回函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduceRight(</span><br><span class="line">    (a, b) =&gt; b(a), // 注意这里，上个版本返回的是函数() =&gt; b(a)；这个版本变成b(a)，直接执行了，原因是我们中间件返回函数，所以这里需要将其执行</span><br><span class="line">    () =&gt; &#123;&#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middles);</span><br><span class="line">mid(&quot;666&quot;); // 打印：m1,m2,m3都打印666</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduce((a, b) =&gt; (...arg) =&gt; a(b(...arg))); // 这边也是，从() =&gt; b(..arg)变成b(..arg)</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middles);</span><br><span class="line">mid(&quot;666&quot;); // 打印：m1,m2,m3都打印666</span><br></pre></td></tr></table></figure>
<a name="7ZAgx"></a><h2 id="共同的属性"><a href="#共同的属性" class="headerlink" title="共同的属性"></a>共同的属性</h2>现在我们完成了中间件的链式调用和参数传递，已完成一个简单的中间件。但是如果我们这里不是普通的中间价，而是 redux 的中间件。我们想要这些中间件都拥有一个初始化的 store，该如何处理呢？熟悉 redux 的朋友肯定知道中间件最后写成这样：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const m1 = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;store1&quot;, store);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br><span class="line">const m2 = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;store2&quot;, store);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br><span class="line">const m3 = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;store3&quot;, store);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
我们还是按照上面几个步骤来实现一下，最后讲讲为什么能这么设计：<br><a name="Rcud0"></a><h3 id="1、-直接调用"><a href="#1、-直接调用" class="headerlink" title="1、 直接调用"></a>1、 直接调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const store = &#123; name: &quot;redux&quot; &#125;;</span><br><span class="line">// 基本写法，我们将参数传给每个中间件</span><br><span class="line">m1(arg =&gt; m2(() =&gt; m3()(arg))(arg))(store);</span><br></pre></td></tr></table></figure>
<a name="EiqgE"></a><h3 id="2-中间件先执行一遍将-store-传入进去"><a href="#2-中间件先执行一遍将-store-传入进去" class="headerlink" title="2. 中间件先执行一遍将 store 传入进去"></a>2. 中间件先执行一遍将 store 传入进去</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const store = &#123; name: &quot;redux&quot; &#125;;</span><br><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">const middlesWithStore = middles.map(middle =&gt; middle(store)); // 这里执行了第一遍，将store传进来</span><br><span class="line">function createFn(middle, next) &#123;</span><br><span class="line">  return action =&gt; middle(next)(action);</span><br><span class="line">&#125;</span><br><span class="line">let next = () =&gt; () =&gt; &#123;&#125;;</span><br><span class="line">for (let i = middlesWithStore.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">  next = createFn(middlesWithStore[i], next);</span><br><span class="line">&#125;</span><br><span class="line">next(store); // 打印：store1,store2,store3 &#123; name: &#x27;redux&#x27; &#125;</span><br></pre></td></tr></table></figure>
<a name="nUik9"></a><h3 id="3、-reduceRight-和-reduce-："><a href="#3、-reduceRight-和-reduce-：" class="headerlink" title="3、 reduceRight 和 reduce ："></a>3、 reduceRight 和 reduce ：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const store = &#123; name: &quot;redux&quot; &#125;;</span><br><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">const middlesWithStore = middles.map(middle =&gt; middle(store)); // 这里执行了第一遍，将store传进来</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middlesWithStore)();</span><br><span class="line">mid(store); // 打印：store1,store2,store3 &#123; name: &#x27;redux&#x27; &#125;</span><br></pre></td></tr></table></figure>
这里看起来简单，就是先执行一遍中间件，<strong>但为什么可以先执行一次函数将数据（store）传进去？而且这个数据在后来的调用中能被访问到</strong>？这背后涉及到的基础知识是函数柯里化和闭包：<br><a name="tXLDh"></a><h2 id="柯里化与闭包"><a href="#柯里化与闭包" class="headerlink" title="柯里化与闭包"></a>柯里化与闭包</h2><a name="Z0jD1"></a><h3 id="1、柯里化"><a href="#1、柯里化" class="headerlink" title="1、柯里化"></a>1、柯里化</h3>柯里化是使用匿名单参数函数来实现多参数函数的方法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const m1 = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;store1&quot;, store);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
上面这种写法，我们说是将中间件 m1 柯里化了，它的特点是每次只传一个参数，返回的是新的函数。<strong>返回新函数这个特点很重要，因为函数可以在其他地方再调用，所以本来一个连续的动作被打断了，变成了可以延迟执行，也可以称为参数前置</strong>。当我们执行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const middlesWithStore = middles.map(middle =&gt; middle(store));</span><br></pre></td></tr></table></figure>
相当于给每个中间件都添加了 store 属性，而且返回的是函数，可以等到你需要用它的时候再去使用。这就是柯里化的好处。<br><a name="fTUee"></a><h3 id="2、闭包"><a href="#2、闭包" class="headerlink" title="2、闭包"></a>2、闭包</h3>闭包：函数与其自由变量组成的环境，自由变量指不存在函数内部的变量。当函数按照值传递的方式在其他地方被调用时，产生了闭包。<br />上面的 m1 可以写成下面这种格式，可以知道柯里化中间函数处于同一闭包，所以尽管我们是在其他地方调用了 next(action)，但还是保存了最开始初始化的作用域，实现了真正的函数分开执行。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function m1(store) &#123;</span><br><span class="line">  return function(next) &#123;</span><br><span class="line">    return function(action) &#123;</span><br><span class="line">      console.log(&quot;store1&quot;, store);</span><br><span class="line">      next(action);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a name="W9wVB"></a><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>可以说我们整个中间件的设计就是建构在返回函数形成闭包这种柯里化特性上。它让我们缓存参数，分开执行，链式传递参数调用。所以 redux 中能提前注入 store，能有效传递 action。可以说koa/redux的中间件机制是闭包/柯里化的经典的实例。寒风卷起，落叶抱冬日，感谢阅读。<br><a name="irPln"></a><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><a target="_blank" rel="noopener" href="https://juejin.im/post/5bbdcf05e51d450e6c750693">https://juejin.im/post/5bbdcf05e51d450e6c750693</a><br /><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35040744">https://zhuanlan.zhihu.com/p/35040744</a><br /><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20597452">https://zhuanlan.zhihu.com/p/20597452</a><br /><a target="_blank" rel="noopener" href="https://github.com/brickspert/blog/issues/22">https://github.com/brickspert/blog/issues/22</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/21/193-%E3%80%90%E4%B8%AD%E9%97%B4%E4%BB%B6%E3%80%91%E4%BB%8Ekoa%E5%92%8Credux%E7%9C%8B%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%AD%E9%97%B4%E4%BB%B6/" data-id="ckts3eju0005b4d9kf2n31dqy" data-title="193-【中间件】从koa和redux看如何设计中间件" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/02/01/194-%E3%80%90Web%E6%8A%80%E6%9C%AF%E3%80%91%E7%94%A8preload%E9%A2%84%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E8%B5%84%E6%BA%90/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          194-【Web技术】用preload预加载页面资源
        
      </div>
    </a>
  
  
    <a href="/2020/01/20/192-%E3%80%90NPM%E3%80%91%E5%89%96%E6%9E%90npm%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">192-【NPM】剖析npm的包管理机制</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/" rel="tag">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS%E5%8A%A8%E7%94%BB/" rel="tag">CSS动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome/" rel="tag">Chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6-ES7-ES8/" rel="tag">ES6/ES7/ES8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eslint/" rel="tag">Eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Express/" rel="tag">Express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GraphQL/" rel="tag">GraphQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/H5/" rel="tag">H5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP%E5%8D%8F%E8%AE%AE/" rel="tag">HTTP协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hybrid/" rel="tag">Hybrid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NPM/" rel="tag">NPM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Numpy/" rel="tag">Numpy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/" rel="tag">Tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TyeScript/" rel="tag">TyeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vuejs/" rel="tag">Vuejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/" rel="tag">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/demo/" rel="tag">demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" rel="tag">人工智能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/" rel="tag">全栈开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2/" rel="tag">前端探索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97/" rel="tag">前端知乎系列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/" rel="tag">常用技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" rel="tag">微前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" rel="tag">构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB/" rel="tag">源码精读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%83%AD%E9%97%A8/" rel="tag">热门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/" rel="tag">生活杂记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" rel="tag">网络请求</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E6%B8%A9%E5%9F%BA%E7%A1%80/" rel="tag">重温基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Angular/" style="font-size: 11.88px;">Angular</a> <a href="/tags/CSS/" style="font-size: 18.13px;">CSS</a> <a href="/tags/CSS%E5%8A%A8%E7%94%BB/" style="font-size: 12.5px;">CSS动画</a> <a href="/tags/Chrome/" style="font-size: 10px;">Chrome</a> <a href="/tags/ES6-ES7-ES8/" style="font-size: 10.63px;">ES6/ES7/ES8</a> <a href="/tags/Eslint/" style="font-size: 10px;">Eslint</a> <a href="/tags/Express/" style="font-size: 10px;">Express</a> <a href="/tags/GraphQL/" style="font-size: 10px;">GraphQL</a> <a href="/tags/H5/" style="font-size: 10px;">H5</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/HTTP/" style="font-size: 11.88px;">HTTP</a> <a href="/tags/HTTP%E5%8D%8F%E8%AE%AE/" style="font-size: 11.25px;">HTTP协议</a> <a href="/tags/Hybrid/" style="font-size: 10.63px;">Hybrid</a> <a href="/tags/JavaScript/" style="font-size: 19.38px;">JavaScript</a> <a href="/tags/NPM/" style="font-size: 10px;">NPM</a> <a href="/tags/Nodejs/" style="font-size: 11.25px;">Nodejs</a> <a href="/tags/Numpy/" style="font-size: 10.63px;">Numpy</a> <a href="/tags/Python/" style="font-size: 17.5px;">Python</a> <a href="/tags/React/" style="font-size: 12.5px;">React</a> <a href="/tags/Tensorflow/" style="font-size: 10.63px;">Tensorflow</a> <a href="/tags/TyeScript/" style="font-size: 10px;">TyeScript</a> <a href="/tags/TypeScript/" style="font-size: 11.25px;">TypeScript</a> <a href="/tags/Vuejs/" style="font-size: 14.38px;">Vuejs</a> <a href="/tags/WebSocket/" style="font-size: 10px;">WebSocket</a> <a href="/tags/Webpack/" style="font-size: 15.63px;">Webpack</a> <a href="/tags/demo/" style="font-size: 10.63px;">demo</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">中间件</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 16.25px;">人工智能</a> <a href="/tags/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/" style="font-size: 11.25px;">全栈开发</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 20px;">前端开发</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2/" style="font-size: 11.25px;">前端探索</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97/" style="font-size: 10.63px;">前端知乎系列</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 18.75px;">原创</a> <a href="/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/" style="font-size: 10.63px;">常用技术</a> <a href="/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">微前端</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 13.75px;">总结</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">机器学习</a> <a href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" style="font-size: 10.63px;">构建工具</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10.63px;">正则表达式</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 10px;">源码</a> <a href="/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB/" style="font-size: 10px;">源码精读</a> <a href="/tags/%E7%83%AD%E9%97%A8/" style="font-size: 10px;">热门</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/" style="font-size: 10px;">生活杂记</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.13px;">算法</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 10px;">编译原理</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" style="font-size: 10px;">网络请求</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.38px;">读书笔记</a> <a href="/tags/%E9%87%8D%E6%B8%A9%E5%9F%BA%E7%A1%80/" style="font-size: 16.88px;">重温基础</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 10px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/28/227-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8SVG%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/">227-【总结】如何优雅的在微信小程序使用SVG字体图标</a>
          </li>
        
          <li>
            <a href="/2021/07/28/226-%E3%80%90HTTP%E3%80%91%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9F/">226-【HTTP】如何优雅的管理HTTP请求和响应拦截器？</a>
          </li>
        
          <li>
            <a href="/2021/07/28/225-%E3%80%90Vue%E3%80%91%E4%BB%8E%E6%89%8B%E5%86%99Vue3%E7%9A%84Reactivity%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%85%A5Vue3%E6%BA%90%E7%A0%81/">225-【Vue】从手写Vue3的Reactivity开始深入Vue3源码</a>
          </li>
        
          <li>
            <a href="/2021/05/30/224-%E3%80%90Chrome%E3%80%915%E4%B8%AAChrome%E8%B0%83%E8%AF%95%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7/">224-【Chrome】5个Chrome调试混合应用的技巧</a>
          </li>
        
          <li>
            <a href="/2021/03/19/223-%E3%80%90%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2%E3%80%91%E6%8E%A2%E7%B4%A2Snabbdom%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">223-【前端探索】探索Snabbdom模块系统原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>