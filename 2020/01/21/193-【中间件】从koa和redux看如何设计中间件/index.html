<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><meta name="description" content="王平安个人博客,pingan8787,前端开发,人工智能,AI,深度学习,前端框架vue,angular,react,nodejs,python,numpy,pandas,anaconda,Tensorflow,高等数学,概率论,统计学神经网络,"><title>193-【中间件】从koa和redux看如何设计中间件 · pingan8787</title><meta name="description" content="编者按：本文作者林向东，360奇舞团前端工程师。中间件是一种实现「关注点分离」的设计模式，有多种实现方式，本文仅探讨koa/redux是如何设计中间件。该模式有两个特点：

中间件middle是一个函数
middle有个next参数，也是函数，代表下个要执行的中间件。1234567891011121"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script type="text/javascript" src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js"></script><script type="text/javascript" src="https://hm.baidu.com/hm.js?de7c89214c05d551ef3ec12341cd0b9e"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;border-radius:15px;"><h3 title=""><a href="/">pingan8787</a></h3></div></div><ul class="my_tages_ul clearfix"><li class="my_tages_li next pagbuttons"><a class="btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"> 前端开发</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 人工智能</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 深度学习</a></li></ul><ul class="my_icon"><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://github.com/pingan8787" title="github"><img src="http://images.pingan8787.com/assets/icon_26_github.png" alt="github"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.yuque.com/wangpingan/cute-frontend" title="语雀"><img src="http://images.pingan8787.com/assets/icon_26_yuque.png" alt="语雀"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/cute-javascript" title="知乎"><img src="http://images.pingan8787.com/icon_zhihu.png" alt="知乎"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://juejin.im/user/586fc337a22b9d0058807d53/posts" title="掘金"><img src="http://images.pingan8787.com/icon_juejin.png" alt="掘金"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://segmentfault.com/blog/pingan8787" title="思否"><img src="http://images.pingan8787.com/icon_sf.png" alt="思否"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36380426" title="CSDN"><img src="http://images.pingan8787.com/icon_csdn.png" alt="CSDN"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/2ec5d94afd60" title="简书"><img src="http://images.pingan8787.com/icon_jianshu.png" alt="简书"></a></li></ul><div style="text-align:center;"><wb:follow-button uid="1689651205" type="red_1" style="margin-top:10px;width:67px;height:24px;display: inline-block;"></wb:follow-button></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>博客作者：</span></a><a href="https://github.com/pingan8787" target="_blank"> pingan8787（leo）</a><div class="by_farbox"> <a href="https://beian.miit.gov.cn/" target="_blank">备案编号：闽ICP备17012095号-1</a></div></div></div><s></s><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/leo">关于Leo</a></li><li><a href="/production">作品</a></li><li><a href="/Catalog">目录</a></li><li><a href="http://js.pingan8787.com" target="_blank">Cute-JavaScript</a></li><li><a href="https://github.com/pingan8787" target="_blank">Github</a></li></div><!--.information//.back_btn
  //li
    //if is_post()
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)") 
    //else
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)",style="display:none;") 
//.avatar
//  img(src= url_for('images/logo@2x.png'))--></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>193-【中间件】从koa和redux看如何设计中间件</a></h3></div><div class="post-content"><p>编者按：本文作者林向东，360奇舞团前端工程师。<br />中间件是一种实现「关注点分离」的设计模式，有多种实现方式，本文仅探讨koa/redux是如何设计中间件。该模式有两个特点：</p>
<ul>
<li>中间件middle是一个函数</li>
<li>middle有个next参数，也是函数，代表下个要执行的中间件。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function m1(next) &#123;</span><br><span class="line">  console.log(&quot;m1&quot;);</span><br><span class="line">  next();</span><br><span class="line">  console.log(&quot;v1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function m2(next) &#123;</span><br><span class="line">  console.log(&quot;m2&quot;);</span><br><span class="line">  next();</span><br><span class="line">  console.log(&quot;v2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function m3() &#123;</span><br><span class="line">  console.log(&quot;m3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如上所示：中间件 m1-&gt;m2-&gt;m3执行，打印结果为 m1-&gt;m2-&gt;m3-&gt;v2-&gt;v1。这种模式有个形象的名字，_洋葱模型_。但现在我们暂时忘记这些名字，就想想如何实现中间件（函数）的联动吧。有两种思路，第一是递归；第二是链式调用。<br><a name="5nPjD"></a><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2>设置一个数组按顺序存储函数，根据 index 值，按顺序一个个执行，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  function dispath(index) &#123;</span><br><span class="line">    if (index === arr.length) return;</span><br><span class="line">    const route = arr[index];</span><br><span class="line">    const next = () =&gt; dispath(index + 1); // 递归执行数组中下一个函数</span><br><span class="line">    return route(next);</span><br><span class="line">  &#125;</span><br><span class="line">  dispath(0);</span><br><span class="line">&#125;</span><br><span class="line">compose(middles); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
<a name="l3Vp1"></a><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2>将函数当作成参数传给上一个中间件，这样前一个中间件执行完就可以执行下一个中间件。<br><a name="Cxp1T"></a><h3 id="1、直接调用："><a href="#1、直接调用：" class="headerlink" title="1、直接调用："></a>1、直接调用：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1(() =&gt; m2(() =&gt; m3())); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br><span class="line">// m2的参数next是 () =&gt; m3()</span><br><span class="line">// m1的参数next是 () =&gt; m2(() =&gt; m3())</span><br></pre></td></tr></table></figure>
此种方法虽然可行，但是 m1，m2，m3 都是写死的，不是公共方法。<br><a name="SVJwr"></a><h3 id="2、构建next的函数createFn："><a href="#2、构建next的函数createFn：" class="headerlink" title="2、构建next的函数createFn："></a>2、构建next的函数createFn：</h3>我们观察到在传递参数时，m3 和 m2 都变成函数再传入，那这个变成函数的过程是否能提取：如下，参数 middle 是中间件，参数 next 是接下来要执行的函数。转换后 next 变成 middle 的参数。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createFn(middle, next) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    middle(next);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 需要先将后面的中间件变成我们需要的 next 函数：</span><br><span class="line">const fn3 = createFn(m3, null);</span><br><span class="line">const fn2 = createFn(m2, fn3);</span><br><span class="line">const fn1 = createFn(m1, fn2);</span><br><span class="line">fn1(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
这里 fn3/fn2/fn1 也是固定的，但我们看出这些中间状态变量，可以隐藏掉，统一用 next 代替：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let next = () =&gt; &#123;&#125;;</span><br><span class="line">next = createFn(m3, null);</span><br><span class="line">next = createFn(m2, next);</span><br><span class="line">next = createFn(m1, next);</span><br><span class="line">next(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
优化如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let next = () =&gt; &#123;&#125;;</span><br><span class="line">// 倒序</span><br><span class="line">for (let i = middles.length; i &gt;= 0; i--) &#123;</span><br><span class="line">  next = createFn(middles[i], next);</span><br><span class="line">&#125;</span><br><span class="line">next(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
<a name="iM3ym"></a><h3 id="3、redux-的-reduceRight"><a href="#3、redux-的-reduceRight" class="headerlink" title="3、redux 的 reduceRight"></a>3、redux 的 reduceRight</h3>仔细观察上面这种倒序，且每次拿上次的值进行计算的方法，是不是很像 reduceRight。（好吧，或许我们看不出来，但是早期 redux 就是这么实现的，我们直接拿过来研究）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduceRight(</span><br><span class="line">    (a, b) =&gt; &#123;</span><br><span class="line">      // b是middle，a是next，</span><br><span class="line">      return () =&gt; b(a); // 每次返回的是一个函数，执行这个函数为middle(next)，即b(a)</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; &#123;&#125; // 初始化的a值，空函数</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middles);</span><br><span class="line">mid(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
<a name="q7qBo"></a><h3 id="4、redux-的-reduce"><a href="#4、redux-的-reduce" class="headerlink" title="4、redux 的 reduce"></a>4、redux 的 reduce</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduce((a, b) =&gt; &#123;</span><br><span class="line">    return (...arg) =&gt; a(() =&gt; b(...arg)); // a 是 next函数，b是middle函数</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middles);</span><br><span class="line">mid(); // 打印m1 -&gt; m2 -&gt; m3 -&gt; v2 -&gt; v1</span><br></pre></td></tr></table></figure>
改成这种正序的方式，反而不好理解。尝试解释一下：a 是 next 函数，b 是 middle 函数。(…arg) =&gt; a(() =&gt; b(…arg)) 这简直就是我们最初这种写法 m1(() =&gt; m2(() =&gt; m3())) 的直接映射。摘抄一下这篇参考一作者的解释，感兴趣的同学可自行推导一下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 第 1 次 reduce 的返回值，下一次将作为 a</span><br><span class="line">arg =&gt; fn1(() =&gt; fn2(arg));</span><br><span class="line">// 第 2 次 reduce 的返回值，下一次将作为 a</span><br><span class="line">arg =&gt; (arg =&gt; fn1(() =&gt; fn2(arg)))(() =&gt; fn3(arg));</span><br><span class="line">// 等价于...</span><br><span class="line">arg =&gt; fn1(() =&gt; fn2(() =&gt; fn3(arg)));</span><br><span class="line">// 执行最后返回的函数连接中间件，返回值等价于...</span><br><span class="line">fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; &#123;&#125;)));</span><br></pre></td></tr></table></figure>
明白reduceRight到reduce转换不是最关键的，关键的是明白上面几种写法让我们能链式调用函数。<br><a name="i1JRO"></a><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2>设计一个中间件模式，怎么能少得了参数的传递。我们先想想<strong>如何组织我们中间件</strong>：很明显，我们通过 next 执行下个中间件，那么传值给下个中间件就是给 next 添加参数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function m1(next) &#123;</span><br><span class="line">  console.log(&quot;m1&quot;);</span><br><span class="line">  next(&quot;v2&quot;); // 将&#x27;v2&#x27;传给下个中间件m2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
那么 m2 该怎么获取这个值呢？因为 next 代表 m2 执行后的值，next 传递参数就是说 m2 需要返回函数，该函数的参数就是传递的值，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function m2(next) &#123;</span><br><span class="line">  return function(action) &#123;</span><br><span class="line">    // 这个action就是上一个函数传来的&#x27;v2&#x27;</span><br><span class="line">    next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这种写法等价于：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const m2 = next =&gt; action =&gt; &#123;</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
所以按照上面这种方式组织我们的中间件，我们就既能链式执行又能传递参数。如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const m1 = next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;m1&quot;, action);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br><span class="line">const m2 = next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;m2&quot;, action);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br><span class="line">const m3 = next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;m3&quot;, action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
那我们如何实现呢？<br><a name="CdlL8"></a><h3 id="1、直接调用：-1"><a href="#1、直接调用：-1" class="headerlink" title="1、直接调用："></a>1、直接调用：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1(arg =&gt; m2(() =&gt; m3()(arg))(arg))(&quot;666&quot;);</span><br><span class="line">// 打印：m1,m2,m3都打印666</span><br></pre></td></tr></table></figure>
<a name="uEuf6"></a><h3 id="2、创建createFn函数："><a href="#2、创建createFn函数：" class="headerlink" title="2、创建createFn函数："></a>2、创建createFn函数：</h3>createFn返回的函数添加了参数action，代表了中间件之间的参数。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 我们给返回的函数加上参数action并执行</span><br><span class="line">function createFn(middle, next) &#123;</span><br><span class="line">  return function (action) &#123;</span><br><span class="line">    middle(next)(action);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">let next = () =&gt; &#123;&#125;;</span><br><span class="line">for (let i = middles.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">  next = createFn(middles[i], next);</span><br><span class="line">&#125;</span><br><span class="line">next(&quot;666&quot;); // 打印：m1,m2,m3都打印666</span><br></pre></td></tr></table></figure>
<a name="MGpsi"></a><h3 id="3、-redux-的-reduceRight-与-reduce："><a href="#3、-redux-的-reduceRight-与-reduce：" class="headerlink" title="3、 redux 的 reduceRight 与 reduce："></a>3、 redux 的 reduceRight 与 reduce：</h3>返回的结果直接执行，因为我们加了一层返回函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduceRight(</span><br><span class="line">    (a, b) =&gt; b(a), // 注意这里，上个版本返回的是函数() =&gt; b(a)；这个版本变成b(a)，直接执行了，原因是我们中间件返回函数，所以这里需要将其执行</span><br><span class="line">    () =&gt; &#123;&#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middles);</span><br><span class="line">mid(&quot;666&quot;); // 打印：m1,m2,m3都打印666</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduce((a, b) =&gt; (...arg) =&gt; a(b(...arg))); // 这边也是，从() =&gt; b(..arg)变成b(..arg)</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middles);</span><br><span class="line">mid(&quot;666&quot;); // 打印：m1,m2,m3都打印666</span><br></pre></td></tr></table></figure>
<a name="7ZAgx"></a><h2 id="共同的属性"><a href="#共同的属性" class="headerlink" title="共同的属性"></a>共同的属性</h2>现在我们完成了中间件的链式调用和参数传递，已完成一个简单的中间件。但是如果我们这里不是普通的中间价，而是 redux 的中间件。我们想要这些中间件都拥有一个初始化的 store，该如何处理呢？熟悉 redux 的朋友肯定知道中间件最后写成这样：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const m1 = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;store1&quot;, store);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br><span class="line">const m2 = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;store2&quot;, store);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br><span class="line">const m3 = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;store3&quot;, store);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
我们还是按照上面几个步骤来实现一下，最后讲讲为什么能这么设计：<br><a name="Rcud0"></a><h3 id="1、-直接调用"><a href="#1、-直接调用" class="headerlink" title="1、 直接调用"></a>1、 直接调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const store = &#123; name: &quot;redux&quot; &#125;;</span><br><span class="line">// 基本写法，我们将参数传给每个中间件</span><br><span class="line">m1(arg =&gt; m2(() =&gt; m3()(arg))(arg))(store);</span><br></pre></td></tr></table></figure>
<a name="EiqgE"></a><h3 id="2-中间件先执行一遍将-store-传入进去"><a href="#2-中间件先执行一遍将-store-传入进去" class="headerlink" title="2. 中间件先执行一遍将 store 传入进去"></a>2. 中间件先执行一遍将 store 传入进去</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const store = &#123; name: &quot;redux&quot; &#125;;</span><br><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">const middlesWithStore = middles.map(middle =&gt; middle(store)); // 这里执行了第一遍，将store传进来</span><br><span class="line">function createFn(middle, next) &#123;</span><br><span class="line">  return action =&gt; middle(next)(action);</span><br><span class="line">&#125;</span><br><span class="line">let next = () =&gt; () =&gt; &#123;&#125;;</span><br><span class="line">for (let i = middlesWithStore.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">  next = createFn(middlesWithStore[i], next);</span><br><span class="line">&#125;</span><br><span class="line">next(store); // 打印：store1,store2,store3 &#123; name: &#x27;redux&#x27; &#125;</span><br></pre></td></tr></table></figure>
<a name="nUik9"></a><h3 id="3、-reduceRight-和-reduce-："><a href="#3、-reduceRight-和-reduce-：" class="headerlink" title="3、 reduceRight 和 reduce ："></a>3、 reduceRight 和 reduce ：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const store = &#123; name: &quot;redux&quot; &#125;;</span><br><span class="line">const middles = [m1, m2, m3];</span><br><span class="line">const middlesWithStore = middles.map(middle =&gt; middle(store)); // 这里执行了第一遍，将store传进来</span><br><span class="line">function compose(arr) &#123;</span><br><span class="line">  return arr.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));</span><br><span class="line">&#125;</span><br><span class="line">const mid = compose(middlesWithStore)();</span><br><span class="line">mid(store); // 打印：store1,store2,store3 &#123; name: &#x27;redux&#x27; &#125;</span><br></pre></td></tr></table></figure>
这里看起来简单，就是先执行一遍中间件，<strong>但为什么可以先执行一次函数将数据（store）传进去？而且这个数据在后来的调用中能被访问到</strong>？这背后涉及到的基础知识是函数柯里化和闭包：<br><a name="tXLDh"></a><h2 id="柯里化与闭包"><a href="#柯里化与闭包" class="headerlink" title="柯里化与闭包"></a>柯里化与闭包</h2><a name="Z0jD1"></a><h3 id="1、柯里化"><a href="#1、柯里化" class="headerlink" title="1、柯里化"></a>1、柯里化</h3>柯里化是使用匿名单参数函数来实现多参数函数的方法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const m1 = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">  console.log(&quot;store1&quot;, store);</span><br><span class="line">  next(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
上面这种写法，我们说是将中间件 m1 柯里化了，它的特点是每次只传一个参数，返回的是新的函数。<strong>返回新函数这个特点很重要，因为函数可以在其他地方再调用，所以本来一个连续的动作被打断了，变成了可以延迟执行，也可以称为参数前置</strong>。当我们执行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const middlesWithStore = middles.map(middle =&gt; middle(store));</span><br></pre></td></tr></table></figure>
相当于给每个中间件都添加了 store 属性，而且返回的是函数，可以等到你需要用它的时候再去使用。这就是柯里化的好处。<br><a name="fTUee"></a><h3 id="2、闭包"><a href="#2、闭包" class="headerlink" title="2、闭包"></a>2、闭包</h3>闭包：函数与其自由变量组成的环境，自由变量指不存在函数内部的变量。当函数按照值传递的方式在其他地方被调用时，产生了闭包。<br />上面的 m1 可以写成下面这种格式，可以知道柯里化中间函数处于同一闭包，所以尽管我们是在其他地方调用了 next(action)，但还是保存了最开始初始化的作用域，实现了真正的函数分开执行。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function m1(store) &#123;</span><br><span class="line">  return function(next) &#123;</span><br><span class="line">    return function(action) &#123;</span><br><span class="line">      console.log(&quot;store1&quot;, store);</span><br><span class="line">      next(action);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a name="W9wVB"></a><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>可以说我们整个中间件的设计就是建构在返回函数形成闭包这种柯里化特性上。它让我们缓存参数，分开执行，链式传递参数调用。所以 redux 中能提前注入 store，能有效传递 action。可以说koa/redux的中间件机制是闭包/柯里化的经典的实例。寒风卷起，落叶抱冬日，感谢阅读。<br><a name="irPln"></a><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><a target="_blank" rel="noopener" href="https://juejin.im/post/5bbdcf05e51d450e6c750693">https://juejin.im/post/5bbdcf05e51d450e6c750693</a><br /><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35040744">https://zhuanlan.zhihu.com/p/35040744</a><br /><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20597452">https://zhuanlan.zhihu.com/p/20597452</a><br /><a target="_blank" rel="noopener" href="https://github.com/brickspert/blog/issues/22">https://github.com/brickspert/blog/issues/22</a></li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-01-21</span><i class="fa fa-tag"></i><a class="tag" href="/tags/前端开发/" title="前端开发">前端开发 </a><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a><a class="tag" href="/tags/中间件/" title="中间件">中间件 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://pingan8787.github.io/2020/01/21/193-【中间件】从koa和redux看如何设计中间件/,pingan8787,193-【中间件】从koa和redux看如何设计中间件,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/02/01/194-%E3%80%90Web%E6%8A%80%E6%9C%AF%E3%80%91%E7%94%A8preload%E9%A2%84%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E8%B5%84%E6%BA%90/" title="194-【Web技术】用preload预加载页面资源">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/01/20/192-%E3%80%90NPM%E3%80%91%E5%89%96%E6%9E%90npm%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" title="192-【NPM】剖析npm的包管理机制">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>