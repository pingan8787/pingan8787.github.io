<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><meta name="description" content="王平安个人博客,pingan8787,前端开发,人工智能,AI,深度学习,前端框架vue,angular,react,nodejs,python,numpy,pandas,anaconda,Tensorflow,高等数学,概率论,统计学神经网络,"><title>211-【Webpack】了不起的Webpack构建流程学习指南 · pingan8787</title><meta name="description" content="最近原创文章回顾：

《了不起的 tsconfig.json 指南》
《了不起的 Webpack HMR 学习指南（含源码分析）》
《《你不知道的 Blob》番外篇》
《《你不知道的 WeakMap》番外篇》

Webpack 是前端很火的打包工具，它本质上是一个现代 JavaScript 应用程序"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script type="text/javascript" src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js"></script><script type="text/javascript" src="https://hm.baidu.com/hm.js?de7c89214c05d551ef3ec12341cd0b9e"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;border-radius:15px;"><h3 title=""><a href="/">pingan8787</a></h3></div></div><ul class="my_tages_ul clearfix"><li class="my_tages_li next pagbuttons"><a class="btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"> 前端开发</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 人工智能</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 深度学习</a></li></ul><ul class="my_icon"><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://github.com/pingan8787" title="github"><img src="http://images.pingan8787.com/assets/icon_26_github.png" alt="github"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.yuque.com/wangpingan/cute-frontend" title="语雀"><img src="http://images.pingan8787.com/assets/icon_26_yuque.png" alt="语雀"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/cute-javascript" title="知乎"><img src="http://images.pingan8787.com/icon_zhihu.png" alt="知乎"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://juejin.im/user/586fc337a22b9d0058807d53/posts" title="掘金"><img src="http://images.pingan8787.com/icon_juejin.png" alt="掘金"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://segmentfault.com/blog/pingan8787" title="思否"><img src="http://images.pingan8787.com/icon_sf.png" alt="思否"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36380426" title="CSDN"><img src="http://images.pingan8787.com/icon_csdn.png" alt="CSDN"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/2ec5d94afd60" title="简书"><img src="http://images.pingan8787.com/icon_jianshu.png" alt="简书"></a></li></ul><div style="text-align:center;"><wb:follow-button uid="1689651205" type="red_1" style="margin-top:10px;width:67px;height:24px;display: inline-block;"></wb:follow-button></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>博客作者：</span></a><a href="https://github.com/pingan8787" target="_blank"> pingan8787（leo）</a><div class="by_farbox"> <a href="https://beian.miit.gov.cn/" target="_blank">备案编号：闽ICP备17012095号-1</a></div></div></div><s></s><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/leo">关于Leo</a></li><li><a href="/production">作品</a></li><li><a href="/Catalog">目录</a></li><li><a href="http://js.pingan8787.com" target="_blank">Cute-JavaScript</a></li><li><a href="https://github.com/pingan8787" target="_blank">Github</a></li></div><!--.information//.back_btn
  //li
    //if is_post()
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)") 
    //else
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)",style="display:none;") 
//.avatar
//  img(src= url_for('images/logo@2x.png'))--></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>211-【Webpack】了不起的Webpack构建流程学习指南</a></h3></div><div class="post-content"><p>最近原创文章回顾：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ed589a251882542e3022f44">《了不起的 tsconfig.json 指南》</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ee8e32a51882543485780d3">《了不起的 Webpack HMR 学习指南（含源码分析）》</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ede5300e51d4578a6798220">《《你不知道的 Blob》番外篇》</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ee78bb7f265da76f15a0698">《《你不知道的 WeakMap》番外篇》</a></li>
</ul>
<p>Webpack 是前端很火的打包工具，它本质上是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 Webpack 处理应用程序时，它会递归地构建一个依赖关系图(<code>dependency graph</code>)，其中包含应用程序需要的每个模块，然后将所有模块打包成一个或多个 <code>bundle</code>。</p>
<p>其实就是：Webpack 是一个 JS 代码打包器。</p>
<p>至于图片、CSS、Less、TS等其他文件，就需要 Webpack 配合 loader 或者 plugin 功能来实现~</p>
<p><img src="http://images.pingan8787.com/Webpack-Build/Webpack-Build-Xmind.png" alt="了不起的 Webpack 构建流程学习指南.png"></p>
<h1 id="一、Webpack-构建流程分析"><a href="#一、Webpack-构建流程分析" class="headerlink" title="一、Webpack 构建流程分析"></a>一、Webpack 构建流程分析</h1><h2 id="1-Webpack-构建过程"><a href="#1-Webpack-构建过程" class="headerlink" title="1. Webpack 构建过程"></a>1. Webpack 构建过程</h2><p>首先先简单了解下 Webpack 构建过程：</p>
<ol>
<li>根据配置，识别入口文件；</li>
<li>逐层识别模块依赖（包括 Commonjs、AMD、或 ES6 的 import 等，都会被识别和分析）；</li>
<li>Webpack 主要工作内容就是分析代码，转换代码，编译代码，最后输出代码；</li>
<li>输出最后打包后的代码。</li>
</ol>
<h2 id="2-Webpack-构建原理"><a href="#2-Webpack-构建原理" class="headerlink" title="2. Webpack 构建原理"></a>2. Webpack 构建原理</h2><p>看完上面的构建流程的简单介绍，相信你已经简单了解了这个过程，那么接下来开始详细介绍 Webpack 构建原理，包括从启动构建到输出结果一系列过程：</p>
<p><strong>（1）初始化参数</strong></p>
<p>解析 Webpack 配置参数，合并 Shell 传入和 <code>webpack.config.js</code> 文件配置的参数，形成最后的配置结果。</p>
<p><strong>（2）开始编译</strong></p>
<p>上一步得到的参数初始化 <code>compiler</code> 对象，注册所有配置的插件，插件监听 Webpack 构建生命周期的事件节点，做出相应的反应，执行对象的 <code>run</code> 方法开始执行编译。</p>
<p><strong>（3）确定入口</strong></p>
<p>从配置文件（ <code>webpack.config.js</code> ）中指定的 <code>entry</code> 入口，开始解析文件构建 AST 语法树，找出依赖，递归下去。</p>
<p><strong>（4）编译模块</strong></p>
<p>递归中根据<strong>文件类型</strong>和 <strong>loader</strong> 配置，调用所有配置的 loader 对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</p>
<p><strong>（5）完成模块编译并输出</strong></p>
<p>递归完后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据 <code>entry</code> 配置生成代码块 <code>chunk</code> 。</p>
<p><strong>（6）输出完成</strong></p>
<p>输出所有的 <code>chunk</code> 到文件系统。</p>
<p>注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如 <code>UglifyPlugin</code> 会在 loader 转换递归完对结果使用 <code>UglifyJs</code> 压缩<strong>覆盖之前的结果</strong>。</p>
<h1 id="二、手写-Webpack-构建工具"><a href="#二、手写-Webpack-构建工具" class="headerlink" title="二、手写 Webpack 构建工具"></a>二、手写 Webpack 构建工具</h1><p>到这里，相信大家对 Webpack 构建流程已经有所了解，但是这还不够，我们再来试着手写 Webpack 构建工具，来将上面文字介绍的内容，应用于实际代码，那么开始吧~</p>
<h2 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1. 初始化项目"></a>1. 初始化项目</h2><p>在手写构建工具前，我们先初始化一个项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn init -y</span><br></pre></td></tr></table></figure>

<p>并安装下面四个依赖包：</p>
<ol>
<li><code>@babel/parser</code> : 用于分析通过 <code>fs.readFileSync</code>  读取的文件内容，并返回 AST (抽象语法树) ； </li>
<li><code>@babel/traverse</code> : 用于遍历 AST, 获取必要的数据；</li>
<li><code>@babel/core</code> : babel 核心模块，提供 <code>transformFromAst</code> 方法，用于将 AST 转化为浏览器可运行的代码；</li>
<li><code>@babel/preset-env</code> : 将转换后代码转化成 ES5 代码；</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add @babel/parser @babel/traverse @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure>

<p>初始化项目目录及文件：<br><img src="http://images.pingan8787.com/Webpack-Build/Webpack-Build-Xmind-Demo1.png" alt="image.png"></p>
<p>代码存放在仓库：<a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo-JavaScript/tree/master/Cute-Webpack/Write-Webpack">https://github.com/pingan8787/Leo-JavaScript/tree/master/Cute-Webpack/Write-Webpack</a></p>
<p>由于本部分核心内容是实现 Webpack 构建工具，所以会从《2. Webpack 构建原理》的“（3）确定入口”步骤开始下面介绍。</p>
<p>大致代码实现流程如下：</p>
<p><img src="http://images.pingan8787.com/Webpack-Build/Webpack-Build.jpeg" alt="webpack构建流程.jpg"></p>
<p>从图中可以看出，手写 Webpack 的核心是实现以下三个方法：</p>
<ul>
<li><code>createAssets</code> : 收集和处理文件的代码；</li>
<li><code>createGraph</code> ：根据入口文件，返回所有文件依赖图；</li>
<li><code>bundle</code> : 根据依赖图整个代码并输出；</li>
</ul>
<h2 id="2-实现-createAssets-函数"><a href="#2-实现-createAssets-函数" class="headerlink" title="2. 实现 createAssets 函数"></a>2. 实现 createAssets 函数</h2><h3 id="2-1-读取通过入口文件，并转为-AST"><a href="#2-1-读取通过入口文件，并转为-AST" class="headerlink" title="2.1 读取通过入口文件，并转为 AST"></a>2.1 读取通过入口文件，并转为 AST</h3><p>首先在 <code>./src/index</code> 文件中写点简单代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> info <span class="keyword">from</span> <span class="string">&quot;./info.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(info);</span><br></pre></td></tr></table></figure>
<p>实现 <code>createAssets</code> 方法中的 <strong>文件读取</strong> 和 <strong>AST转换</strong> 操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leo_webpack.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&quot;@babel/parser&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&quot;@babel/traverse&quot;</span>).default;</span><br><span class="line"><span class="comment">// 由于 traverse 采用的 ES Module 导出，我们通过 requier 引入的话就加个 .default</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> moduleId = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> createAssets = <span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> content = fs.readFileSync(filename, <span class="string">&quot;utf-8&quot;</span>); <span class="comment">// 根据文件名，同步读取文件流</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 将读取文件流 buffer 转换为 AST</span></span><br><span class="line">    <span class="keyword">const</span> ast = parser.parse(content, &#123;</span><br><span class="line">        <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span> <span class="comment">// 指定源码类型</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(ast);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createAssets(<span class="string">&#x27;./src/index.js&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码：<br>通过 <code>fs.readFileSync()</code> 方法，以<strong>同步方式</strong>读取指定路径下的文件流，并通过 <code>parser</code> 依赖包提供的 <code>parse()</code> 方法，将读取到的文件流 buffer <strong>转换为浏览器可以认识的代码（AST）</strong>，AST 输出如下：</p>
<p><img src="http://images.pingan8787.com/Webpack-Build/Webpack-Build-Xmind-Demo2.png" alt="image.png"></p>
<p>另外需要注意，这里我们声明了一个 <code>moduleId</code> 变量，来区分当前操作的模块。<br>在这里，不仅将读取到的文件流 buffer 转换为 AST 的同时，也将 ES6 代码转换为 ES5 代码了。</p>
<h3 id="2-2-收集每个模块的依赖"><a href="#2-2-收集每个模块的依赖" class="headerlink" title="2.2 收集每个模块的依赖"></a>2.2 收集每个模块的依赖</h3><p>接下来声明 <code>dependencies</code> 变量来保存收集到的文件依赖路径，通过 <code>traverse（）</code> 方法遍历 <code>ast</code>，获取每个节点依赖路径，并 <code>push</code> 进 <code>dependencies</code> 数组中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leo_webpack.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAssets</span>(<span class="params">filename</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> dependencies = []; <span class="comment">// 用于收集文件依赖的路径</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 通过 traverse 提供的操作 AST 的方法，获取每个节点的依赖路径</span></span><br><span class="line">    traverse(ast, &#123;</span><br><span class="line">        <span class="attr">ImportDeclaration</span>: <span class="function">(<span class="params">&#123;node&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            dependencies.push(node.source.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-将-AST-转换为浏览器可运行代码"><a href="#2-3-将-AST-转换为浏览器可运行代码" class="headerlink" title="2.3 将 AST 转换为浏览器可运行代码"></a>2.3 将 AST 转换为浏览器可运行代码</h3><p>在收集依赖的同时，我们可以将 AST 代码转换为浏览器可运行代码，这就需要使用到 <code>babel</code> ，这个万能的小家伙，为我们提供了非常好用的 <code>transformFromAstSync()</code> 方法，同步的将 AST 转换为浏览器可运行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leo_webpack.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAssets</span>(<span class="params">filename</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> &#123; code &#125; = babel.transformFromAstSync(ast,<span class="literal">null</span>, &#123;</span><br><span class="line">        <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> id = moduleId++; <span class="comment">// 设置当前处理的模块ID</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        id,</span><br><span class="line">        filename,</span><br><span class="line">        code,</span><br><span class="line">        dependencies</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这一步，我们在执行 <code>node leo_webpack.js</code> ，输出如下内容，包含了入口文件的路径 <code>filename</code>  、浏览器可执行代码 <code>code</code> 和文件依赖的路径 <code>dependencies</code> 数组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node leo_webpack.js</span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">  filename: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  code: <span class="string">&#x27;&quot;use strict&quot;;\n\nvar _info = _interopRequireDefault(require(&quot;./info.js&quot;));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; &quot;default&quot;: obj &#125;; &#125;\n\nconsole.log(_info[&quot;default&quot;]);&#x27;</span>, </span><br><span class="line">  dependencies: [ <span class="string">&#x27;./info.js&#x27;</span> ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-代码小结"><a href="#2-4-代码小结" class="headerlink" title="2.4 代码小结"></a>2.4 代码小结</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leo_webpack.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&quot;@babel/parser&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&quot;@babel/traverse&quot;</span>).default;</span><br><span class="line"><span class="comment">// 由于 traverse 采用的 ES Module 导出，我们通过 requier 引入的话就加个 .default</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> moduleId = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAssets</span>(<span class="params">filename</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> content = fs.readFileSync(filename, <span class="string">&quot;utf-8&quot;</span>); <span class="comment">// 根据文件名，同步读取文件流</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 将读取文件流 buffer 转换为 AST</span></span><br><span class="line">    <span class="keyword">const</span> ast = parser.parse(content, &#123;</span><br><span class="line">        <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span> <span class="comment">// 指定源码类型</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> dependencies = []; <span class="comment">// 用于收集文件依赖的路径</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 通过 traverse 提供的操作 AST 的方法，获取每个节点的依赖路径</span></span><br><span class="line">    traverse(ast, &#123;</span><br><span class="line">        <span class="attr">ImportDeclaration</span>: <span class="function">(<span class="params">&#123;node&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            dependencies.push(node.source.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 通过 AST 将 ES6 代码转换成 ES5 代码</span></span><br><span class="line">    <span class="keyword">const</span> &#123; code &#125; = babel.transformFromAstSync(ast,<span class="literal">null</span>, &#123;</span><br><span class="line">        <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> id = moduleId++; <span class="comment">// 设置当前处理的模块ID</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      	id,</span><br><span class="line">        filename,</span><br><span class="line">        code,</span><br><span class="line">        dependencies</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-实现-createGraph-函数"><a href="#3-实现-createGraph-函数" class="headerlink" title="3. 实现 createGraph 函数"></a>3. 实现 createGraph 函数</h2><p>在 <code>createGraph()</code> 函数中，我们将递归所有依赖模块，循环分析每个依赖模块依赖，生成一份依赖图谱。<br>为了方便测试，我们补充下 <code>consts.js</code> 和 <code>info.js</code> 文件的代码，增加一些依赖关系：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/consts.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> company = <span class="string">&quot;平安&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/info.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; company &#125; <span class="keyword">from</span> <span class="string">&quot;./consts.js&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">`你好，<span class="subst">$&#123;company&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>接下来开始实现 <code>createGraph()</code> 函数，它需要接收一个入口文件的路径（ <code>entry</code> ）作为参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leo_webpack.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGraph</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> mainAsset = createAssets(entry); <span class="comment">// 获取入口文件下的内容</span></span><br><span class="line">    <span class="keyword">const</span> queue = [mainAsset]; <span class="comment">// 入口文件的结果作为第一项</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> asset <span class="keyword">of</span> queue)&#123;</span><br><span class="line">        <span class="keyword">const</span> dirname = path.dirname(asset.filename);</span><br><span class="line">        asset.mapping = &#123;&#125;;</span><br><span class="line">        asset.dependencies.forEach(<span class="function"><span class="params">relativePath</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> absolutePath = path.join(dirname, relativePath); <span class="comment">// 转换文件路径为绝对路径</span></span><br><span class="line">            <span class="keyword">const</span> child = createAssets(absolutePath);</span><br><span class="line">            asset.mapping[relativePath] = child.id; <span class="comment">// 保存模块ID </span></span><br><span class="line">            queue.push(child); <span class="comment">// 递归去遍历所有子节点的文件</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码：</p>
<p>首先通过 <code>createAssets()</code> 函数读取入口文件的内容，并作为依赖关系的队列（依赖图谱） <code>queue</code> 数组的第一项，接着遍历依赖图谱 <code>queue</code> 每一项，再遍历将每一项中的依赖 <code>dependencies</code> 依赖数组，将依赖中的每一项拼接成依赖的绝对路径（<code>absolutePath</code> ），作为 <code>createAssets()</code> 函数调用的参数，递归去遍历所有子节点的文件，并将结果都保存在依赖图谱 <code>queue</code> 中。</p>
<p>注意， <code>mapping</code> 对象是用来保存文件的相对路径和模块 ID 的对应关系，在 <code>mapping</code> 对象中，我们使用依赖文件的相对路径作为 <code>key</code> ，来存储保存模块 ID。</p>
<p>然后我们修改启动函数：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// leo_webpack.js</span><br><span class="line"></span><br><span class="line"><span class="deletion">- const result = createAssets(&#x27;./src/index.js&#x27;);</span></span><br><span class="line"><span class="addition">+ const graph = createGraph(&quot;./src/index.js&quot;);</span></span><br><span class="line"><span class="addition">+ console.log(graph);</span></span><br></pre></td></tr></table></figure>

<p>这时我们将得到一份包含所有文件依赖关系的依赖图谱：</p>
<p><img src="http://images.pingan8787.com/Webpack-Build/Webpack-Build-Xmind-Demo3.png" alt="image.png"></p>
<p>这个依赖图谱，包含了所有文件模块的依赖，以及模块的代码内容。下一步只要实现 <code>bundle()</code> 函数，将结果输出即可。</p>
<h2 id="4-实现-bundle-函数"><a href="#4-实现-bundle-函数" class="headerlink" title="4. 实现 bundle 函数"></a>4. 实现 bundle 函数</h2><p>从前面介绍，我们知道，函数 <code>createGraph()</code> 会返回一个包含每个依赖相关信息（id / filename / code / dependencies）的依赖图谱 <code>queue</code>，这一步就将使用到它了。</p>
<p>在 <code>bundle()</code> 函数中，接收一个依赖图谱 <code>graph</code> 作为参数，最后输出编译后的结果。</p>
<h3 id="4-1-读取所有模块信息"><a href="#4-1-读取所有模块信息" class="headerlink" title="4.1 读取所有模块信息"></a>4.1 读取所有模块信息</h3><p>我们首先声明一个变量 <code>modules</code>，值为字符串类型，然后对参数 <code>graph</code> 进行遍历，将每一项中的 <code>id</code> 属性作为 <code>key</code> ，值为一个数组，包括一个用来执行代码 <code>code</code> 的方法和序列化后的 <code>mapping</code>，最后拼接到 <code>modules</code> 中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leo_webpack.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">graph</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> modules = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    graph.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        modules += <span class="string">`</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;item.id&#125;</span>: [</span></span><br><span class="line"><span class="string">                function (require, module, exports)&#123;</span></span><br><span class="line"><span class="string">                    <span class="subst">$&#123;item.code&#125;</span></span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(item.mapping)&#125;</span></span></span><br><span class="line"><span class="string">            ],</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码：</p>
<p>在 <code>modules</code> 中每一项的值中，下标为 0 的元素是个函数，接收三个参数 <code>require</code> / <code>module</code> / <code>exports</code> ，为什么会需要这三个参数呢？</p>
<p>原因是：构建工具无法判断是否支持<code>require</code> / <code>module</code> / <code>exports</code> 这三种模块方法，所以需要自己实现（后面步骤会实现），然后方法内的 <code>code</code> 才能正常执行。</p>
<h3 id="4-2-返回最终结果"><a href="#4-2-返回最终结果" class="headerlink" title="4.2 返回最终结果"></a>4.2 返回最终结果</h3><p>接着，我们来实现 <code>bundle()</code> 函数返回值的处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leo_webpack.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">graph</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">        (function(modules)&#123;</span></span><br><span class="line"><span class="string">            function require(id)&#123;</span></span><br><span class="line"><span class="string">                const [fn, mapping] = modules[id];</span></span><br><span class="line"><span class="string">                function localRequire(relativePath)&#123;</span></span><br><span class="line"><span class="string">                    return require(mapping[relativePath]);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                const module = &#123;</span></span><br><span class="line"><span class="string">                    exports: &#123;&#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                fn(localRequire, module, module.exports);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                return module.exports;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            require(0);</span></span><br><span class="line"><span class="string">        &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码：</p>
<p>最终 <code>bundle</code> 函数返回值是一个字符串，包含一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">自执行函数（IIFE）</a>，其中函数参数是一个对象， <code>key</code> 为 <code>modules</code> ， <code>value</code> 为前面拼接好的 <code>modules</code> 字符串，即 <code>&#123;modules: modules字符串&#125;</code> 。</p>
<p>在这个自执行函数中，实现了 <code>require</code> 方法，接收一个 <code>id</code> 作为参数，在方法内部，分别实现了 <code>localRequire</code> / <code>module</code> / <code>modules.exports</code> 三个方法，并作为参数，传到 <code>modules[id]</code> 中的 <code>fn</code> 方法中，最后初始化 <code>require()</code> 函数（<code>require(0);</code>）。</p>
<h3 id="4-3-代码小结"><a href="#4-3-代码小结" class="headerlink" title="4.3 代码小结"></a>4.3 代码小结</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leo_webpack.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">graph</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> modules = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    graph.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        modules += <span class="string">`</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;item.id&#125;</span>: [</span></span><br><span class="line"><span class="string">                function (require, module, exports)&#123;</span></span><br><span class="line"><span class="string">                    <span class="subst">$&#123;item.code&#125;</span></span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(item.mapping)&#125;</span></span></span><br><span class="line"><span class="string">            ],</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">        (function(modules)&#123;</span></span><br><span class="line"><span class="string">            function require(id)&#123;</span></span><br><span class="line"><span class="string">                const [fn, mapping] = modules[id];</span></span><br><span class="line"><span class="string">                function localRequire(relativePath)&#123;</span></span><br><span class="line"><span class="string">                    return require(mapping[relativePath]);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                const module = &#123;</span></span><br><span class="line"><span class="string">                    exports: &#123;&#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                fn(localRequire, module, module.exports);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                return module.exports;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            require(0);</span></span><br><span class="line"><span class="string">        &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-执行代码"><a href="#5-执行代码" class="headerlink" title="5. 执行代码"></a>5. 执行代码</h2><p>当我们上面方法都实现以后，就开始试试吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leo_webpack.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> graph = createGraph(<span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> result = bundle(graph);</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>
<p>这时候可以看到终端输出类似这样的代码，是字符串，这里为了方便查看而复制到控制台了：</p>
<p><img src="http://images.pingan8787.com/Webpack-Build/Webpack-Build-Xmind-Demo4.png" alt="image.png"></p>
<p>这就是打包后的代码咯~</p>
<p>那么如何让这些代码执行呢？用 <code>eval()</code> 方法咯：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leo_webpack.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> graph = createGraph(<span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> result = bundle(graph);</span><br><span class="line"><span class="built_in">eval</span>(result);</span><br></pre></td></tr></table></figure>
<p>这时候就能看到控制台输出 <code>你好，平安</code> 。那么我们就完成一个简单的 Webpack 构建工具啦~</p>
<p>能看到这里的朋友，为你点个赞~</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>本文主要介绍了 Webpack 的构建流程和构建原理，并在此基础上，和大家分享了手写 Webpack 的实现过程，希望大家对 Webpack 构建流程能有更深了解，毕竟面试贼喜欢问啦~</p>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#112;&#x69;&#x6e;&#x67;&#97;&#x6e;&#x38;&#55;&#56;&#55;&#64;&#113;&#113;&#x2e;&#99;&#111;&#109;">&#112;&#x69;&#x6e;&#x67;&#97;&#x6e;&#x38;&#55;&#56;&#55;&#64;&#113;&#113;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>ES小册</td>
<td>js.pingan8787.com</td>
</tr>
<tr>
<td>语雀知识库</td>
<td><a target="_blank" rel="noopener" href="https://www.yuque.com/wangpingan/cute-frontend">Cute-FrontEnd</a></td>
</tr>
</tbody></table>
<p><img src="http://images.pingan8787.com/2019_07_12guild_page.png" alt="bg"></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-07-06</span><i class="fa fa-tag"></i><a class="tag" href="/tags/前端开发/" title="前端开发">前端开发 </a><a class="tag" href="/tags/原创/" title="原创">原创 </a><a class="tag" href="/tags/Webpack/" title="Webpack">Webpack </a><a class="tag" href="/tags/读书笔记/" title="读书笔记">读书笔记 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://pingan8787.github.io/2020/07/06/211-【Webpack】了不起的Webpack构建流程学习指南/,pingan8787,211-【Webpack】了不起的Webpack构建流程学习指南,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/07/06/212-%E3%80%90JavaScript%E3%80%91%E5%88%9D%E4%B8%AD%E7%BA%A7%E5%89%8D%E7%AB%AFJavaScript%E8%87%AA%E6%B5%8B%E6%B8%85%E5%8D%95-1/" title="212-【JavaScript】初中级前端JavaScript自测清单-1">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/07/06/210-%E3%80%90JavaScript%E3%80%91%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84WeakMap%E3%80%8B%E7%95%AA%E5%A4%96%E7%AF%87/" title="210-【JavaScript】《你不知道的WeakMap》番外篇">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>