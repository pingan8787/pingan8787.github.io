<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><meta name="description" content="王平安个人博客,pingan8787,前端开发,人工智能,AI,深度学习,前端框架vue,angular,react,nodejs,python,numpy,pandas,anaconda,Tensorflow,高等数学,概率论,统计学神经网络,"><title>201-【编译原理】200行JS代码带你实现微型编译器（人人都能学会） · pingan8787</title><meta name="description" content="最近看到掘金、前端公众号好多 ES2020 的文章，想说一句：放开我，我还学得动！

先问大家一句，日常项目开发中你能离开 ES6 吗？
一、前言对于前端同学来说，编译器可能适合神奇的魔盒🎁，表面普通，但常常给我们惊喜。编译器，顾名思义，用来编译，编译什么呢？当然是编译代码咯🌹。其实我们也经常接"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script type="text/javascript" src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js"></script><script type="text/javascript" src="https://hm.baidu.com/hm.js?de7c89214c05d551ef3ec12341cd0b9e"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;border-radius:15px;"><h3 title=""><a href="/">pingan8787</a></h3></div></div><ul class="my_tages_ul clearfix"><li class="my_tages_li next pagbuttons"><a class="btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"> 前端开发</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 人工智能</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 深度学习</a></li></ul><ul class="my_icon"><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://github.com/pingan8787" title="github"><img src="http://images.pingan8787.com/assets/icon_26_github.png" alt="github"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.yuque.com/wangpingan/cute-frontend" title="语雀"><img src="http://images.pingan8787.com/assets/icon_26_yuque.png" alt="语雀"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/cute-javascript" title="知乎"><img src="http://images.pingan8787.com/icon_zhihu.png" alt="知乎"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://juejin.im/user/586fc337a22b9d0058807d53/posts" title="掘金"><img src="http://images.pingan8787.com/icon_juejin.png" alt="掘金"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://segmentfault.com/blog/pingan8787" title="思否"><img src="http://images.pingan8787.com/icon_sf.png" alt="思否"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36380426" title="CSDN"><img src="http://images.pingan8787.com/icon_csdn.png" alt="CSDN"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/2ec5d94afd60" title="简书"><img src="http://images.pingan8787.com/icon_jianshu.png" alt="简书"></a></li></ul><div style="text-align:center;"><wb:follow-button uid="1689651205" type="red_1" style="margin-top:10px;width:67px;height:24px;display: inline-block;"></wb:follow-button></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>博客作者：</span></a><a href="https://github.com/pingan8787" target="_blank"> pingan8787（leo）</a><div class="by_farbox"> <a href="https://beian.miit.gov.cn/" target="_blank">备案编号：闽ICP备17012095号-1</a></div></div></div><s></s><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/leo">关于Leo</a></li><li><a href="/production">作品</a></li><li><a href="/Catalog">目录</a></li><li><a href="http://js.pingan8787.com" target="_blank">Cute-JavaScript</a></li><li><a href="https://github.com/pingan8787" target="_blank">Github</a></li></div><!--.information//.back_btn
  //li
    //if is_post()
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)") 
    //else
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)",style="display:none;") 
//.avatar
//  img(src= url_for('images/logo@2x.png'))--></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>201-【编译原理】200行JS代码带你实现微型编译器（人人都能学会）</a></h3></div><div class="post-content"><p><img src="http://images.pingan8787.com/TinyCompiler/1585365502950-d474962e-f17c-4aec-bcf4-1252dd5f0e5d.jpeg"><br /></p>
<blockquote>
<p>最近看到掘金、前端公众号好多 ES2020 的文章，想说一句：放开我，我还学得动！</p>
</blockquote>
<p><br />先问大家一句，日常项目开发中你能离开 ES6 吗？<br /></p>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>对于前端同学来说，编译器可能适合神奇的魔盒🎁，表面普通，但常常给我们惊喜。<br />编译器，顾名思义，用来编译，编译什么呢？当然是编译代码咯🌹。<br /><br><img src="https://st-gdx.dancf.com/gaodingx/0/design/20191125-144728-7a47.gif"><br><br />其实我们也经常接触到编译器的使用场景：</p>
<ul>
<li>React 中 JSX 转换成 JS 代码；</li>
<li>通过 Babel 将 ES6 及以上规范的代码转换成 ES5 代码；</li>
<li>通过各种 Loader 将 Less / Scss 代码转换成浏览器支持的 CSS 代码；</li>
<li>将 TypeScript 转换为 JavaScript 代码。</li>
<li>and so on…</li>
</ul>
<p><br />使用场景非常之多，我的双手都数不过来了。😄<br />虽然现在社区已经有非常多工具能为我们完成上述工作，但了解一些编译原理是很有必要的。接下来进入本文主题：<strong>200行JS代码，带你实现代码编译器</strong>。<br /></p>
<h1 id="二、编译器介绍"><a href="#二、编译器介绍" class="headerlink" title="二、编译器介绍"></a>二、编译器介绍</h1><h2 id="2-1-程序运行方式"><a href="#2-1-程序运行方式" class="headerlink" title="2.1 程序运行方式"></a>2.1 程序运行方式</h2><p>现代程序主要有两种编译模式：静态编译和动态解释。推荐一篇文章<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008739157">《Angular 2 JIT vs AOT》</a>介绍得非常详细。<br /></p>
<h3 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h3><p>简称 <strong>AOT</strong>（Ahead-Of-Time）即 <strong>提前编译</strong> ，静态编译的程序会在执行前，会使用指定编译器，将全部代码编译成机器码。<br /><img src="http://images.pingan8787.com/TinyCompiler/111.png"><br />（图片来自：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008739157">https://segmentfault.com/a/1190000008739157</a>）<br /><br><br />在 Angular 的 AOT 编译模式开发流程如下：</p>
<ul>
<li>使用 TypeScript 开发 Angular 应用</li>
<li>运行 ngc 编译应用程序<ul>
<li>使用 Angular Compiler 编译模板，一般输出 TypeScript 代码</li>
<li>运行 tsc 编译 TypeScript 代码</li>
</ul>
</li>
<li>使用 Webpack 或 Gulp 等其他工具构建项目，如代码压缩、合并等</li>
<li>部署应用</li>
</ul>
<h3 id="动态解释"><a href="#动态解释" class="headerlink" title="动态解释"></a>动态解释</h3><p>简称 <strong>JIT</strong>（Just-In-Time）即 <strong>即时编译</strong> ，动态解释的程序会使用指定解释器，一边编译一边执行程序。<br /><img src="http://images.pingan8787.com/TinyCompiler/112.png">（图片来自：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008739157" title="https://segmentfault.com/a/1190000008739157">https://segmentfault.com/a/1190000008739157</a>）<br /><br><br />在 Angular 的 JIT 编译模式开发流程如下：</p>
<ul>
<li>使用 TypeScript 开发 Angular 应用</li>
<li>运行 tsc 编译 TypeScript 代码</li>
<li>使用 Webpack 或 Gulp 等其他工具构建项目，如代码压缩、合并等</li>
<li>部署应用</li>
</ul>
<h3 id="AOT-vs-JIT"><a href="#AOT-vs-JIT" class="headerlink" title="AOT vs JIT"></a>AOT vs JIT</h3><p><strong>AOT 编译流程：</strong><img src="http://images.pingan8787.com/TinyCompiler/113.png">（图片来自：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008739157">https://segmentfault.com/a/1190000008739157</a>）</p>
<p><strong>JIT 编译流程：</strong><img src="http://images.pingan8787.com/TinyCompiler/114.png">（图片来自：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008739157">https://segmentfault.com/a/1190000008739157</a>）</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">AOT</th>
<th align="center">JIT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">编译平台</td>
<td align="center">(Server) 服务器</td>
<td align="center">(Browser) 浏览器</td>
</tr>
<tr>
<td align="center">编译时机</td>
<td align="center">Build (构建阶段)</td>
<td align="center">Runtime (运行时)</td>
</tr>
<tr>
<td align="center">包大小</td>
<td align="center">较小</td>
<td align="center">较大</td>
</tr>
<tr>
<td align="center">执行性能</td>
<td align="center">更好</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">启动时间</td>
<td align="center">更短</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>除此之外 AOT 还有以下优点：</p>
<ul>
<li>在客户端我们不需要导入体积庞大的 angular 编译器，这样可以减少我们 JS 脚本库的大小</li>
<li>使用 AOT 编译后的应用，不再包含任何 HTML 片段，取而代之的是编译生成的 TypeScript 代码，这样的话 TypeScript 编译器就能提前发现错误。总而言之，采用 AOT 编译模式，我们的模板是类型安全的。</li>
</ul>
<h2 id="2-2-现代编译器工作流程"><a href="#2-2-现代编译器工作流程" class="headerlink" title="2.2 现代编译器工作流程"></a>2.2 现代编译器工作流程</h2><p>摘抄维基百科中对 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8?wprov=srpw1_0" title="编译器">编译器</a>工作流程介绍：</p>
<blockquote>
<p>一个现代编译器的主要工作流程如下：<br>源代码（source code）→ 预处理器（preprocessor）→ 编译器（compiler）→ 汇编程序（assembler）→ 目标代码（object code）→ 链接器（linker）→ 可执行文件（executables），最后打包好的文件就可以给电脑去判读运行了。</p>
</blockquote>
<p><img src="http://images.pingan8787.com/TinyCompiler/115.png"></p>
<p>这里更强调了编译器的作用：<strong>将原始程序作为输入，翻译产生目标语言的等价程序</strong>。</p>
<p><img src="http://images.pingan8787.com/TinyCompiler/%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E9%98%B6%E6%AE%B5.png" alt="编译器三个核心阶段.png"></p>
<p>目前绝大多数现代编译器工作流程基本类似，包括三个核心阶段：</p>
<ol>
<li><strong>解析（_Parsing_）</strong> ：通过词法分析和语法分析，将原始代码字符串解析成<strong>抽象语法树（Abstract Syntax Tree）</strong>；</li>
<li><strong>转换（_Transformation_）</strong>：对抽象语法树进行转换处理操作；</li>
<li><strong>生成代码（_Code Generation_）</strong>：将转换之后的 AST 对象生成目标语言代码字符串。</li>
</ol>
<h1 id="三、编译器实现"><a href="#三、编译器实现" class="headerlink" title="三、编译器实现"></a>三、编译器实现</h1><p>本文将通过 <strong><a target="_blank" rel="noopener" href="https://the-super-tiny-compiler.glitch.me/" title="The Super Tiny Compiler">The Super Tiny Compiler</a></strong> 源码解读，学习如何实现一个轻量编译器，最终<strong>实现将下面原始代码字符串（Lisp 风格的函数调用）编译成 JavaScript 可执行的代码</strong>。<br /></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Lisp 风格（编译前）</th>
<th align="left">JavaScript 风格（编译后）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2 + 2</td>
<td align="left">(add 2 2)</td>
<td align="left">add(2, 2)</td>
</tr>
<tr>
<td align="left">4 - 2</td>
<td align="left">(subtract 4 2)</td>
<td align="left">subtract(4, 2)</td>
</tr>
<tr>
<td align="left">2 + (4 - 2)</td>
<td align="left">(add 2 (subtract 4 2))</td>
<td align="left">add(2, subtract(4, 2))</td>
</tr>
</tbody></table>
<p><br />话说 <a target="_blank" rel="noopener" href="https://the-super-tiny-compiler.glitch.me/">The Super Tiny Compiler</a> 号称<strong>可能是有史以来最小的编译器</strong>，并且其作者 James Kyle 也是 Babel 活跃维护者之一。<br /><img src="https://st-gdx.dancf.com/gaodingx/46/design/20191206-135932-505a.gif"><br><br />让我们开始吧~<br /></p>
<h2 id="3-1-The-Super-Tiny-Compiler-工作流程"><a href="#3-1-The-Super-Tiny-Compiler-工作流程" class="headerlink" title="3.1 The Super Tiny Compiler 工作流程"></a>3.1 The Super Tiny Compiler 工作流程</h2><p>现在对照前面编译器的三个核心阶段，了解下 <a target="_blank" rel="noopener" href="https://the-super-tiny-compiler.glitch.me/">The Super Tiny Compiler</a>  编译器核心工作流程：<br /><img src="http://images.pingan8787.com/TinyCompiler/TheSuperTinyCompiler%E7%BC%96%E8%AF%91%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="The Super Tiny Compiler编译器工作流程.png"><br /></p>
<p><strong>图中详细流程如下：</strong></p>
<ol>
<li>执行<strong>入口函数</strong>，输入<strong>原始代码字符串</strong>作为参数；</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始代码字符串</span></span><br><span class="line">(add <span class="number">2</span> (subtract <span class="number">4</span> <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>进入<strong>解析阶段（Parsing）</strong>，原始代码字符串通过<strong>词法分析器（Tokenizer）</strong>转换为<strong>词法单元数组，</strong>然后再通过 <strong>语法分析器（Parser）</strong>将<strong>词法单元数组</strong>转换为<strong>抽象语法树（Abstract Syntax Tree 简称 AST）</strong>，并返回；</li>
</ol>
<p><img src="http://images.pingan8787.com/TinyCompiler/%E8%A7%A3%E6%9E%90%E9%98%B6%E6%AE%B5-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90.png" alt="解析阶段 - 词法分析.png"><br /><br><img src="http://images.pingan8787.com/TinyCompiler/%E8%A7%A3%E6%9E%90%E9%98%B6%E6%AE%B5-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90.png" alt="解析阶段 - 语法分析.png"><br /></p>
<ol start="3">
<li>进入<strong>转换阶段（Transformation）</strong>，将上一步生成的 <strong>AST 对象</strong> 导入<strong>转换器（Transformer）</strong>，通过<strong>转换器</strong>中的<strong>遍历器（Traverser）</strong>，将代码转换为我们所需的<strong>新的 AST 对象</strong>；</li>
</ol>
<p><img src="http://images.pingan8787.com/TinyCompiler/%E8%BD%AC%E6%8D%A2%E9%98%B6%E6%AE%B5.png" alt="转换阶段.png"><br /></p>
<ol start="4">
<li>进入<strong>代码生成阶段（Code Generation）</strong>，将上一步返回的<strong>新 AST 对象</strong>通过<strong>代码生成器（CodeGenerator）</strong>，转换成 <strong>JavaScript Code</strong>；</li>
</ol>
<p><img src="http://images.pingan8787.com/TinyCompiler/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E9%98%B6%E6%AE%B5.png" alt="代码生成阶段.png"><br /></p>
<ol start="5">
<li><strong>代码编译结束</strong>，返回 <strong>JavaScript Code</strong>。</li>
</ol>
<p><img src="https://st-gdx.dancf.com/gaodingx/0/uxms/design/20200320-163503-12b5.gif"><br /><br><br />上述流程看完后可能一脸懵逼，不过没事，请保持头脑清醒，先有个整个流程的印象，接下来我们开始阅读代码：<br /></p>
<h2 id="3-2-入口方法"><a href="#3-2-入口方法" class="headerlink" title="3.2 入口方法"></a>3.2 入口方法</h2><p>首先定义一个入口方法 <code>compiler</code> ，接收原始代码字符串作为参数，返回最终 JavaScript Code：<br /></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器入口方法 参数：原始代码字符串 input</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compiler</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tokens = tokenizer(input);</span><br><span class="line">  <span class="keyword">let</span> ast    = parser(tokens);</span><br><span class="line">  <span class="keyword">let</span> newAst = transformer(ast);</span><br><span class="line">  <span class="keyword">let</span> output = codeGenerator(newAst);</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-解析阶段"><a href="#3-3-解析阶段" class="headerlink" title="3.3 解析阶段"></a>3.3 解析阶段</h2><p>在解析阶段中，我们定义<strong>词法分析器方法</strong> <code>tokenizer</code>  和<strong>语法分析器方法</strong> <code>parser</code> 然后分别实现：<br /></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 词法分析器 参数：原始代码字符串 input</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenizer</span>(<span class="params">input</span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法分析器 参数：词法单元数组tokens</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parser</span>(<span class="params">tokens</span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h3><p><strong>词法分析器方法</strong> <code>tokenizer</code> 的主要任务：遍历整个原始代码字符串，将原始代码字符串转换为<strong>词法单元数组（tokens）</strong>，并返回。<br />在遍历过程中，匹配每种字符并处理成<strong>词法单元</strong>压入<strong>词法单元数组</strong>，如当匹配到左括号（ <code>(</code> ）时，将往<strong>词法单元数组（tokens）</strong>压入一个<strong>词法单元对象</strong>（<code>&#123;type: &#39;paren&#39;, value:&#39;(&#39;&#125;</code>）。<br /><img src="http://images.pingan8787.com/TinyCompiler/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="词法分析器工作流程.png"><br /></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 词法分析器 参数：原始代码字符串 input</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenizer</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="number">0</span>;  <span class="comment">// 当前解析的字符索引，作为游标</span></span><br><span class="line">  <span class="keyword">let</span> tokens = [];  <span class="comment">// 初始化词法单元数组</span></span><br><span class="line">  <span class="comment">// 循环遍历原始代码字符串，读取词法单元数组</span></span><br><span class="line">  <span class="keyword">while</span> (current &lt; input.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> char = input[current];</span><br><span class="line">    <span class="comment">// 匹配左括号，匹配成功则压入对象 &#123;type: &#x27;paren&#x27;, value:&#x27;(&#x27;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (char === <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">      tokens.push(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;paren&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;(&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">      current++;</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// 自增current，完成本次循环，进入下一个循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配右括号，匹配成功则压入对象 &#123;type: &#x27;paren&#x27;, value:&#x27;)&#x27;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (char === <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">      tokens.push(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;paren&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">      current++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 匹配空白字符，匹配成功则跳过</span></span><br><span class="line">    <span class="comment">// 使用 \s 匹配，包括空格、制表符、换页符、换行符、垂直制表符等</span></span><br><span class="line">    <span class="keyword">let</span> WHITESPACE = <span class="regexp">/\s/</span>;</span><br><span class="line">    <span class="keyword">if</span> (WHITESPACE.test(char)) &#123;</span><br><span class="line">      current++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配数字字符，使用 [0-9]：匹配</span></span><br><span class="line">    <span class="comment">// 匹配成功则压入&#123;type: &#x27;number&#x27;, value: value&#125;</span></span><br><span class="line">    <span class="comment">// 如 (add 123 456) 中 123 和 456 为两个数值词法单元</span></span><br><span class="line">    <span class="keyword">let</span> NUMBERS = <span class="regexp">/[0-9]/</span>;</span><br><span class="line">    <span class="keyword">if</span> (NUMBERS.test(char)) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="comment">// 匹配连续数字，作为数值</span></span><br><span class="line">      <span class="keyword">while</span> (NUMBERS.test(char)) &#123;</span><br><span class="line">        value += char;</span><br><span class="line">        char = input[++current];</span><br><span class="line">      &#125;</span><br><span class="line">      tokens.push(&#123; <span class="attr">type</span>: <span class="string">&#x27;number&#x27;</span>, value &#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配形双引号包围的字符串</span></span><br><span class="line">    <span class="comment">// 匹配成功则压入 &#123; type: &#x27;string&#x27;, value: value &#125;</span></span><br><span class="line">    <span class="comment">// 如 (concat &quot;foo&quot; &quot;bar&quot;) 中 &quot;foo&quot; 和 &quot;bar&quot; 为两个字符串词法单元</span></span><br><span class="line">    <span class="keyword">if</span> (char === <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      char = input[++current]; <span class="comment">// 跳过左双引号</span></span><br><span class="line">      <span class="comment">// 获取两个双引号之间所有字符</span></span><br><span class="line">      <span class="keyword">while</span> (char !== <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">        value += char;</span><br><span class="line">        char = input[++current];</span><br><span class="line">      &#125;</span><br><span class="line">      char = input[++current];<span class="comment">// 跳过右双引号</span></span><br><span class="line">      tokens.push(&#123; <span class="attr">type</span>: <span class="string">&#x27;string&#x27;</span>, value &#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配函数名，要求只含大小写字母，使用 [a-z] 匹配 i 模式</span></span><br><span class="line">    <span class="comment">// 匹配成功则压入 &#123; type: &#x27;name&#x27;, value: value &#125;</span></span><br><span class="line">    <span class="comment">// 如 (add 2 4) 中 add 为一个名称词法单元</span></span><br><span class="line">    <span class="keyword">let</span> LETTERS = <span class="regexp">/[a-z]/i</span>;</span><br><span class="line">    <span class="keyword">if</span> (LETTERS.test(char)) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="comment">// 获取连续字符</span></span><br><span class="line">      <span class="keyword">while</span> (LETTERS.test(char)) &#123;</span><br><span class="line">        value += char;</span><br><span class="line">        char = input[++current];</span><br><span class="line">      &#125;</span><br><span class="line">      tokens.push(&#123; <span class="attr">type</span>: <span class="string">&#x27;name&#x27;</span>, value &#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当遇到无法识别的字符，抛出错误提示，并退出</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;I dont know what this character is: &#x27;</span> + char);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 词法分析器的最后返回词法单元数组</span></span><br><span class="line">  <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h3><p><strong>语法分析器方法</strong> <code>parser</code> 的主要任务：将<strong>词法分析器</strong>返回的<strong>词法单元数组</strong>，转换为能够描述语法成分及其关系的中间形式（<strong>抽象语法树 AST</strong>）。<br /><img src="http://images.pingan8787.com/TinyCompiler/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="语法分析器工作流程.png"><br /></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法分析器 参数：词法单元数组tokens</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parser</span>(<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="number">0</span>; <span class="comment">// 设置当前解析的词法单元的索引，作为游标</span></span><br><span class="line">  <span class="comment">// 递归遍历（因为函数调用允许嵌套），将词法单元转成 LISP 的 AST 节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前索引下的词法单元 token</span></span><br><span class="line">    <span class="keyword">let</span> token = tokens[current]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数值类型词法单元</span></span><br><span class="line">    <span class="keyword">if</span> (token.type === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      current++; <span class="comment">// 自增当前 current 值</span></span><br><span class="line">      <span class="comment">// 生成一个 AST节点 &#x27;NumberLiteral&#x27;，表示数值字面量</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;NumberLiteral&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: token.value,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串类型词法单元</span></span><br><span class="line">    <span class="keyword">if</span> (token.type === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      current++;</span><br><span class="line">      <span class="comment">// 生成一个 AST节点 &#x27;StringLiteral&#x27;，表示字符串字面量</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;StringLiteral&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: token.value,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数类型词法单元</span></span><br><span class="line">    <span class="keyword">if</span> (token.type === <span class="string">&#x27;paren&#x27;</span> &amp;&amp; token.value === <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 跳过左括号，获取下一个词法单元作为函数名</span></span><br><span class="line">      token = tokens[++current];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> node = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;CallExpression&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: token.value,</span><br><span class="line">        <span class="attr">params</span>: []</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 再次自增 current 变量，获取参数词法单元</span></span><br><span class="line">      token = tokens[++current];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历每个词法单元，获取函数参数，直到出现右括号&quot;）&quot;</span></span><br><span class="line">      <span class="keyword">while</span> ((token.type !== <span class="string">&#x27;paren&#x27;</span>) || (token.type === <span class="string">&#x27;paren&#x27;</span> &amp;&amp; token.value !== <span class="string">&#x27;)&#x27;</span>)) &#123;</span><br><span class="line">        node.params.push(walk());</span><br><span class="line">        token = tokens[current];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      current++; <span class="comment">// 跳过右括号</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无法识别的字符，抛出错误提示</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(token.type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 AST 根节点</span></span><br><span class="line">  <span class="keyword">let</span> ast = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;Program&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: [],</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环填充 ast.body</span></span><br><span class="line">  <span class="keyword">while</span> (current &lt; tokens.length) &#123;</span><br><span class="line">    ast.body.push(walk());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后返回ast</span></span><br><span class="line">  <span class="keyword">return</span> ast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-4-转换阶段"><a href="#3-4-转换阶段" class="headerlink" title="3.4 转换阶段"></a>3.4 转换阶段</h2><p>在转换阶段中，定义了转换器 <code>transformer</code> 函数，使用词法分析器返回的 LISP 的 AST 对象作为参数，将 AST 对象转换成一个新的 AST 对象。<br /><br><br />为了方便代码组织，我们定义一个遍历器 <code>traverser</code> 方法，用来处理每一个节点的操作。<br /></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历器 参数：ast 和 visitor</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverser</span>(<span class="params">ast, visitor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义方法 traverseArray </span></span><br><span class="line">  <span class="comment">// 用于遍历 AST节点数组，对数组中每个元素调用 traverseNode 方法。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">traverseArray</span>(<span class="params">array, parent</span>) </span>&#123;</span><br><span class="line">    array.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">      traverseNode(child, parent);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义方法 traverseNode</span></span><br><span class="line">  <span class="comment">// 用于处理每个 AST 节点，接受一个 node 和它的父节点 parent 作为参数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">traverseNode</span>(<span class="params">node, parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 visitor 上对应方法的对象</span></span><br><span class="line">    <span class="keyword">let</span> methods = visitor[node.type];</span><br><span class="line">    <span class="comment">// 获取 visitor 的 enter 方法，处理操作当前 node</span></span><br><span class="line">    <span class="keyword">if</span> (methods &amp;&amp; methods.enter) &#123;</span><br><span class="line">      methods.enter(node, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (node.type) &#123;</span><br><span class="line">      <span class="comment">// 根节点</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Program&#x27;</span>:</span><br><span class="line">        traverseArray(node.body, node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 函数调用</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;CallExpression&#x27;</span>:</span><br><span class="line">        traverseArray(node.params, node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 数值和字符串，忽略</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;NumberLiteral&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;StringLiteral&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当遇到无法识别的字符，抛出错误提示，并退出</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(node.type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (methods &amp;&amp; methods.exit) &#123;</span><br><span class="line">      methods.exit(node, parent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 首次执行，开始遍历</span></span><br><span class="line">  traverseNode(ast, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看<strong>遍历器</strong> <code>traverser</code> 方法时，建议结合下面介绍的<strong>转换器</strong> <code>transformer</code> 方法阅读：<br /></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转化器，参数：ast</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transformer</span>(<span class="params">ast</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 newAST，与之前 AST 类似，Program：作为新 AST 的根节点</span></span><br><span class="line">  <span class="keyword">let</span> newAst = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;Program&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: [],</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 _context 维护新旧 AST，注意 _context 是一个引用，从旧的 AST 到新的 AST。</span></span><br><span class="line">  ast._context = newAst.body;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过遍历器遍历 处理旧的 AST</span></span><br><span class="line">  traverser(ast, &#123;</span><br><span class="line">    <span class="comment">// 数值，直接原样插入新AST，类型名称 NumberLiteral</span></span><br><span class="line">    <span class="attr">NumberLiteral</span>: &#123;</span><br><span class="line">      <span class="function"><span class="title">enter</span>(<span class="params">node, parent</span>)</span> &#123;</span><br><span class="line">        parent._context.push(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;NumberLiteral&#x27;</span>,</span><br><span class="line">          <span class="attr">value</span>: node.value,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 字符串，直接原样插入新AST，类型名称 StringLiteral</span></span><br><span class="line">    <span class="attr">StringLiteral</span>: &#123;</span><br><span class="line">      <span class="function"><span class="title">enter</span>(<span class="params">node, parent</span>)</span> &#123;</span><br><span class="line">        parent._context.push(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;StringLiteral&#x27;</span>,</span><br><span class="line">          <span class="attr">value</span>: node.value,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="attr">CallExpression</span>: &#123;</span><br><span class="line">      <span class="function"><span class="title">enter</span>(<span class="params">node, parent</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建不同的AST节点</span></span><br><span class="line">        <span class="keyword">let</span> expression = &#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;CallExpression&#x27;</span>,</span><br><span class="line">          <span class="attr">callee</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;Identifier&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: node.name,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">arguments</span>: [],</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数调用有子类，建立节点对应关系，供子节点使用</span></span><br><span class="line">        node._context = expression.arguments;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶层函数调用算是语句，包装成特殊的AST节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent.type !== <span class="string">&#x27;CallExpression&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">          expression = &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;ExpressionStatement&#x27;</span>,</span><br><span class="line">            <span class="attr">expression</span>: expression,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        parent._context.push(expression);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> newAst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要一点，这里通过 <code>_context</code> 引用来<strong>维护新旧 AST 对象</strong>，管理方便，避免污染旧 AST 对象。<br /></p>
<h2 id="3-5-代码生成"><a href="#3-5-代码生成" class="headerlink" title="3.5 代码生成"></a>3.5 代码生成</h2><p>接下来到了最后一步，我们定义<strong>代码生成器</strong> <code>codeGenerator</code> 方法，通过递归，将新的 AST 对象代码转换成 JavaScript 可执行代码字符串。<br /></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码生成器 参数：新 AST 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">codeGenerator</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (node.type) &#123;</span><br><span class="line">    <span class="comment">// 遍历 body 属性中的节点，且递归调用 codeGenerator，按行输出结果</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Program&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> node.body.map(codeGenerator)</span><br><span class="line">        .join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表达式，处理表达式内容，并用分号结尾</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ExpressionStatement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        codeGenerator(node.expression) +</span><br><span class="line">        <span class="string">&#x27;;&#x27;</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用，添加左右括号，参数用逗号隔开</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;CallExpression&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        codeGenerator(node.callee) +</span><br><span class="line">        <span class="string">&#x27;(&#x27;</span> +</span><br><span class="line">        node.arguments.map(codeGenerator)</span><br><span class="line">          .join(<span class="string">&#x27;, &#x27;</span>) +</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标识符，返回其 name</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Identifier&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> node.name;</span><br><span class="line">    <span class="comment">// 数值，返回其 value</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;NumberLiteral&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> node.value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串，用双引号包裹再输出</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;StringLiteral&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span> + node.value + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当遇到无法识别的字符，抛出错误提示，并退出</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(node.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-编译器测试"><a href="#3-6-编译器测试" class="headerlink" title="3.6 编译器测试"></a>3.6 编译器测试</h2><p>截止上一步，我们完成简易编译器的代码开发。接下来通过前面原始需求的代码，测试编译器效果如何：<br /></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">const</span> subtract = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b;</span><br><span class="line"><span class="keyword">const</span> source = <span class="string">&quot;(add 2 (subtract 4 2))&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> target = compiler(source); <span class="comment">// &quot;add(2, (subtract(4, 2));&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">eval</span>(target); <span class="comment">// Ok result is 4</span></span><br></pre></td></tr></table></figure>

<h2 id="3-7-工作流程小结"><a href="#3-7-工作流程小结" class="headerlink" title="3.7 工作流程小结"></a>3.7 工作流程小结</h2><p>总结 <a target="_blank" rel="noopener" href="https://the-super-tiny-compiler.glitch.me/">The Super Tiny Compiler</a> 编译器整个工作流程：<br /><strong>1、input =&gt; tokenizer =&gt; tokens</strong><br /><strong>2、tokens =&gt; parser =&gt; ast</strong><br /><strong>3、ast =&gt; transformer =&gt; newAst</strong><br /><strong>4、newAst =&gt; generator =&gt; output</strong><br /></p>
<p>其实多数编译器的工作流程都大致相同：<br><img src="http://images.pingan8787.com/TinyCompiler/TheSuperTinyCompiler%E7%BC%96%E8%AF%91%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%88%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%89.png" alt="The Super Tiny Compiler编译器工作流程（方法实现）.png"></p>
<h1 id="四、手写-Webpack-编译器"><a href="#四、手写-Webpack-编译器" class="headerlink" title="四、手写 Webpack 编译器"></a>四、手写 Webpack 编译器</h1><p>根据之前介绍的 <a target="_blank" rel="noopener" href="https://the-super-tiny-compiler.glitch.me/">The Super Tiny Compiler</a>编译器核心工作流程，再来手写 Webpack 的编译器，会让你有种众享丝滑的感觉~<br /><img src="https://st-gdx.dancf.com/gaodingx/0/design/20191030-163349-cca6.gif"></p>
<p><br />话说，有些面试官喜欢问这个呢。当然，手写一遍能让我们更了解 Webpack 的构建流程，这个章节我们简要介绍一下。</p>
<h2 id="4-1-Webpack-构建流程分析"><a href="#4-1-Webpack-构建流程分析" class="headerlink" title="4.1 Webpack 构建流程分析"></a>4.1 Webpack 构建流程分析</h2><p>从启动构建到输出结果一系列过程：</p>
<ol>
<li><strong>初始化参数</strong></li>
</ol>
<p>解析 Webpack 配置参数，合并 Shell 传入和 <code>webpack.config.js</code> 文件配置的参数，形成最后的配置结果。<br /></p>
<ol start="2">
<li><strong>开始编译</strong></li>
</ol>
<p>上一步得到的参数初始化 <code>compiler</code> 对象，注册所有配置的插件，插件监听 Webpack 构建生命周期的事件节点，做出相应的反应，执行对象的 <code>run</code> 方法开始执行编译。<br /></p>
<ol start="3">
<li><strong>确定入口</strong></li>
</ol>
<p>从配置的 <code>entry</code> 入口，开始解析文件构建 AST 语法树，找出依赖，递归下去。<br /></p>
<ol start="4">
<li><strong>编译模块</strong></li>
</ol>
<p>递归中根据<strong>文件类型</strong>和 <strong>loader 配置</strong>，调用所有配置的 loader 对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。<br /></p>
<ol start="5">
<li><strong>完成模块编译并输出</strong></li>
</ol>
<p>递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据 <code>entry</code> 配置生成代码块 <code>chunk</code> 。<br /></p>
<ol start="6">
<li><strong>输出完成</strong></li>
</ol>
<p>输出所有的 <code>chunk</code> 到文件系统。<br /><br><br />注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如 <code>UglifyPlugin</code> 会在 loader 转换递归完对结果使用 <code>UglifyJs</code> 压缩<strong>覆盖之前的结果</strong>。<br /><img src="http://images.pingan8787.com/TinyCompiler/Webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B1.png" alt="Webpack构建流程.png"></p>
<h2 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h2><p>手写 Webpack 需要实现以下三个核心方法：</p>
<ul>
<li><code>createAssets</code> : 收集和处理文件的代码；</li>
<li><code>createGraph</code> ：根据入口文件，返回所有文件依赖图；</li>
<li><code>bundle</code> : 根据依赖图整个代码并输出；</li>
</ul>
<h3 id="1-createAssets"><a href="#1-createAssets" class="headerlink" title="1. createAssets"></a>1. createAssets</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAssets</span>(<span class="params">filename</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> content = fs.readFileSync(filename, <span class="string">&quot;utf-8&quot;</span>); <span class="comment">// 根据文件名读取文件内容</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 将读取到的代码内容，转换为 AST</span></span><br><span class="line">    <span class="keyword">const</span> ast = parser.parse(content, &#123;</span><br><span class="line">        <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span> <span class="comment">// 指定源码类型</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> dependencies = []; <span class="comment">// 用于收集文件依赖的路径</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 通过 traverse 提供的操作 AST 的方法，获取每个节点的依赖路径</span></span><br><span class="line">    traverse(ast, &#123;</span><br><span class="line">        <span class="attr">ImportDeclaration</span>: <span class="function">(<span class="params">&#123;node&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            dependencies.push(node.source.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 通过 AST 将 ES6 代码转换成 ES5 代码</span></span><br><span class="line">    <span class="keyword">const</span> &#123; code &#125; = babel.transformFromAstSync(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">        <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> id = moduleId++;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        id,</span><br><span class="line">        filename,</span><br><span class="line">        code,</span><br><span class="line">        dependencies</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-createGraph"><a href="#2-createGraph" class="headerlink" title="2. createGraph"></a>2. createGraph</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGraph</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> mainAsset = createAssets(entry); <span class="comment">// 获取入口文件下的内容</span></span><br><span class="line">    <span class="keyword">const</span> queue = [mainAsset];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> asset <span class="keyword">of</span> queue)&#123;</span><br><span class="line">        <span class="keyword">const</span> dirname = path.dirname(asset.filename);</span><br><span class="line">        asset.mapping = &#123;&#125;;</span><br><span class="line">        asset.dependencies.forEach(<span class="function"><span class="params">relativePath</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> absolutePath = path.join(dirname, relativePath); <span class="comment">// 转换文件路径为绝对路径</span></span><br><span class="line">            <span class="keyword">const</span> child = createAssets(absolutePath);</span><br><span class="line">            asset.mapping[relativePath] = child.id;</span><br><span class="line">            queue.push(child); <span class="comment">// 递归去遍历所有子节点的文件</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-bunlde"><a href="#3-bunlde" class="headerlink" title="3. bunlde"></a>3. bunlde</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">graph</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> modules = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    graph.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        modules += <span class="string">`</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;item.id&#125;</span>: [</span></span><br><span class="line"><span class="string">                function (require, module, exports)&#123;</span></span><br><span class="line"><span class="string">                    <span class="subst">$&#123;item.code&#125;</span></span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(item.mapping)&#125;</span></span></span><br><span class="line"><span class="string">            ],</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">        (function(modules)&#123;</span></span><br><span class="line"><span class="string">            function require(id)&#123;</span></span><br><span class="line"><span class="string">                const [fn, mapping] = modules[id];</span></span><br><span class="line"><span class="string">                function localRequire(relativePath)&#123;</span></span><br><span class="line"><span class="string">                    return require(mapping[relativePath]);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                const module = &#123;</span></span><br><span class="line"><span class="string">                    exports: &#123;&#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                fn(localRequire, module, module.exports);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                return module.exports;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            require(0);</span></span><br><span class="line"><span class="string">        &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>本文从编译器概念和基本工作流程开始介绍，然后通过 <a target="_blank" rel="noopener" href="https://the-super-tiny-compiler.glitch.me/">The Super Tiny Compiler</a> 译器源码，详细介绍核心工作流程实现，包括<strong>词法分析器</strong>、<strong>语法分析器</strong>、<strong>遍历器</strong>和<strong>转换器</strong>的基本实现，最后通过<strong>代码生成器</strong>，将各个阶段代码结合起来，实现了这个号称<strong>可能是有史以来最小的编译器。</strong><br />本文也简要介绍了<strong>手写 Webpack 的实现</strong>，需要读者自行完善和深入哟！<br>是不是觉得很神奇~<br /><br><img src="https://st0.dancf.com/csc/346/templets/20191106-155044-c33a.gif"><br /><br>当然通过本文学习，也仅仅是编译器相关知识的边山一脚，要学的知识还有非常多，不过好的开头，更能促进我们学习动力。加油！<br /><br><br />最后，文中介绍到的代码，我存放在 Github 上：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo-JavaScript/blob/master/Cute-Frontend/learningSourceCode/%5Blearning%5Dthe-super-tiny-compiler.js" title="[learning]the-super-tiny-compiler.js">[learning]the-super-tiny-compiler.js</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo-JavaScript/blob/master/Cute-Frontend/learningSourceCode/%5Bwriting%5Dwebpack-compiler.js" title="[writing]webpack-compiler.js">[writing]webpack-compiler.js</a></li>
</ol>
<h1 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h1><ol>
<li><a target="_blank" rel="noopener" href="https://the-super-tiny-compiler.glitch.me/" title="《The Super Tiny Compiler》">《The Super Tiny Compiler》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016402699" title="《有史以来最小的编译器源码解析》">《有史以来最小的编译器源码解析》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008739157" title="《Angular 2 JIT vs AOT》">《Angular 2 JIT vs AOT》</a></li>
</ol>
<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#112;&#105;&#x6e;&#103;&#x61;&#110;&#x38;&#x37;&#x38;&#55;&#64;&#113;&#x71;&#46;&#x63;&#111;&#x6d;">&#112;&#105;&#x6e;&#103;&#x61;&#110;&#x38;&#x37;&#x38;&#55;&#64;&#113;&#x71;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>ES小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/22/1706bb1ea5f680ae?w=885&h=445&f=png&s=80093">  </p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-03-30</span><i class="fa fa-tag"></i><a class="tag" href="/tags/前端开发/" title="前端开发">前端开发 </a><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a><a class="tag" href="/tags/原创/" title="原创">原创 </a><a class="tag" href="/tags/编译原理/" title="编译原理">编译原理 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://pingan8787.github.io/2020/03/30/201-【编译原理】200行JS代码带你实现微型编译器（人人都能学会）/,pingan8787,201-【编译原理】200行JS代码带你实现微型编译器（人人都能学会）,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/04/15/202-%E3%80%90Babel%E3%80%91%E4%B8%8D%E5%AE%B9%E9%94%99%E8%BF%87%E7%9A%84Babel7%E7%9F%A5%E8%AF%86/" title="202-【Babel】不容错过的Babel7知识">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/03/24/200-%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%918%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="200-【数据结构】8种常见数据结构">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>