<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><meta name="description" content="王平安个人博客,pingan8787,前端开发,人工智能,AI,深度学习,前端框架vue,angular,react,nodejs,python,numpy,pandas,anaconda,Tensorflow,高等数学,概率论,统计学神经网络,"><title>165-【Hybrid】HybridApp应用开发中5个必备知识点复习 · pingan8787</title><meta name="description" content="Author
王平安



E-mail
&amp;#112;&amp;#105;&amp;#x6e;&amp;#103;&amp;#97;&amp;#x6e;&amp;#56;&amp;#55;&amp;#56;&amp;#55;&amp;#64;&amp;#x71;&amp;#113;&amp;#46;&amp;#99;&amp;#111;&amp;#x6d;


博  客
www.pingan8787.com


微  信
p"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script type="text/javascript" src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js"></script><script type="text/javascript" src="https://hm.baidu.com/hm.js?de7c89214c05d551ef3ec12341cd0b9e"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;border-radius:15px;"><h3 title=""><a href="/">pingan8787</a></h3></div></div><ul class="my_tages_ul clearfix"><li class="my_tages_li next pagbuttons"><a class="btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"> 前端开发</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 人工智能</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 深度学习</a></li></ul><ul class="my_icon"><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://github.com/pingan8787" title="github"><img src="http://images.pingan8787.com/assets/icon_26_github.png" alt="github"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.yuque.com/wangpingan/cute-frontend" title="语雀"><img src="http://images.pingan8787.com/assets/icon_26_yuque.png" alt="语雀"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/cute-javascript" title="知乎"><img src="http://images.pingan8787.com/icon_zhihu.png" alt="知乎"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://juejin.im/user/586fc337a22b9d0058807d53/posts" title="掘金"><img src="http://images.pingan8787.com/icon_juejin.png" alt="掘金"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://segmentfault.com/blog/pingan8787" title="思否"><img src="http://images.pingan8787.com/icon_sf.png" alt="思否"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36380426" title="CSDN"><img src="http://images.pingan8787.com/icon_csdn.png" alt="CSDN"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/2ec5d94afd60" title="简书"><img src="http://images.pingan8787.com/icon_jianshu.png" alt="简书"></a></li></ul><div style="text-align:center;"><wb:follow-button uid="1689651205" type="red_1" style="margin-top:10px;width:67px;height:24px;display: inline-block;"></wb:follow-button></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>博客作者：</span></a><a href="https://github.com/pingan8787" target="_blank"> pingan8787（leo）</a><div class="by_farbox"> <a href="https://beian.miit.gov.cn/" target="_blank">备案编号：闽ICP备17012095号-1</a></div></div></div><s></s><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/leo">关于Leo</a></li><li><a href="/production">作品</a></li><li><a href="/Catalog">目录</a></li><li><a href="http://js.pingan8787.com" target="_blank">Cute-JavaScript</a></li><li><a href="https://github.com/pingan8787" target="_blank">Github</a></li></div><!--.information//.back_btn
  //li
    //if is_post()
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)") 
    //else
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)",style="display:none;") 
//.avatar
//  img(src= url_for('images/logo@2x.png'))--></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>165-【Hybrid】HybridApp应用开发中5个必备知识点复习</a></h3></div><div class="post-content"><hr>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#112;&#105;&#x6e;&#103;&#97;&#x6e;&#56;&#55;&#56;&#55;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;">&#112;&#105;&#x6e;&#103;&#97;&#x6e;&#56;&#55;&#56;&#55;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>微信公众号</td>
<td>前端自习课</td>
</tr>
</tbody></table>
<p><img src="http://images.pingan8787.com/Hybird%E5%B0%81%E9%9D%A2.png" alt="封面"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们大前端团队内部 📖<strong>每周一练</strong> 的知识复习计划还在继续，本周主题是 <strong>《Hybrid APP 混合应用专题》</strong> ，这期内容比较多，篇幅也相对较长，每个知识点内容也比较多。</p>
<p>之前分享的每周内容，我都整理到掘金收藏集 <a target="_blank" rel="noopener" href="https://juejin.im/collection/5cd11b0af265da0346227e24">📔《EFT每周一练》</a> 上啦，欢迎点赞收藏咯💕💕。  </p>
<blockquote>
<p>注：本文整理资料来源网络，有些图片/段落找不到原文出处，如有侵权，联系删除。</p>
</blockquote>
<h3 id="一、什么是-Hybrid-App，与-Native-App-及-Web-App-有什么区别"><a href="#一、什么是-Hybrid-App，与-Native-App-及-Web-App-有什么区别" class="headerlink" title="一、什么是 Hybrid App，与 Native App 及 Web App 有什么区别"></a>一、什么是 Hybrid App，与 Native App 及 Web App 有什么区别</h3><p>参考文章：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="http://www.ionic.wang/article-index-id-58.html">《Web App Hybrid App和 Native App的区别》</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dailc/p/5930238.html">《Hybrid APP基础篇(二) -&gt; Native、Hybrid、React Native、Web App方案的分析比较》</a></p>
</li>
</ol>
<h4 id="1-1-主流应用类型"><a href="#1-1-主流应用类型" class="headerlink" title="1.1 主流应用类型"></a>1.1 主流应用类型</h4><p>随着现在移动互联网的快速发展，市面上目前主流移动应用程序主要分三类：<strong>Web App</strong>、 <strong>Native App</strong> 和 <strong>Hybrid App</strong>。</p>
<p>三者大致关系如下：   </p>
<p><img src="http://images.pingan8787.com/20190623HybridApp1.png" alt="关系图">   </p>
<h4 id="1-2-Web-App"><a href="#1-2-Web-App" class="headerlink" title="1.2 Web App"></a>1.2 Web App</h4><p><strong>Web App</strong>，即<strong>移动端网站</strong>，一般指的是基于 Web 的应用，基于<strong>浏览器运行</strong>，<strong>无需下载安装</strong>，基本上可以说是触屏版的网页应用。这类应用基本上是一个网页或一系列网页，旨在在移动屏幕上工作。</p>
<p><strong>Web 网站</strong>一般分为两种：</p>
<ol>
<li><p><strong>MPA</strong>(Multi-page Application)</p>
</li>
<li><p><strong>SPA</strong>(Single-page Application)</p>
</li>
</ol>
<p>一般的 <strong>Web App</strong> 是指 <strong>SPA</strong> 形式开发的网站。  </p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>开发和维护成本低，可以跨平台，调试方便；</strong></li>
</ul>
<p>前端人员开发的代码，可应用于各大主流浏览器(特殊情况可以代码进行下兼容)，没有新的学习成本，而且可以直接在浏览器中调试。 </p>
<ul>
<li><strong>更新最为快速；</strong></li>
</ul>
<p>由于web app资源是直接部署在服务器端的，所以只需替换服务器端文件，用户访问是就已经更新了(当然需要解决一些缓存问题)。 </p>
<ul>
<li><strong>无需安装App，不会占用手机内存；</strong></li>
</ul>
<p>通过浏览器即可访问，无需安装，用户使用成本更低。 </p>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>性能低，用户体验差；</strong></li>
</ul>
<p>由于是直接通过的浏览器访问，所以无法使用原生的API，操作体验不好。 </p>
<ul>
<li><strong>依赖于网络，页面访问速度慢，耗费流量；</strong></li>
</ul>
<p>Web App每次访问都必须依赖网络，从服务端加载资源，当网速慢时访问速度很不理想，特别是在移动端，对网站性能优化要求比较高。 </p>
<ul>
<li><strong>功能受限，大量功能无法实现；</strong></li>
</ul>
<p>只能使用 HTML5 的一些特殊 API ，无法调用原生 API ，所以很多功能存在无法实现情况。 </p>
<ul>
<li><strong>临时性入口，用户留存率低；</strong></li>
</ul>
<p>这既是它的优点，也是缺点，优点是无需安装，确定是用完后有时候很难再找到，或者说很难专门为某个web app留存一个入口，导致用户很难再次使用。 </p>
<h4 id="1-3-Native-App"><a href="#1-3-Native-App" class="headerlink" title="1.3 Native App"></a>1.3 Native App</h4><p><strong>Native APP</strong> 指的是原生程序，需要用户下载安装使用，一般依托于操作系统，有很强的交互，是一个完整的App，可拓展性强，能发布应用商店。</p>
<p>目前市面上主流的平台有：<strong>Android</strong> 和 <strong>iOS</strong>。</p>
<p><strong>优点：</strong>  </p>
<ul>
<li><p>直接依托于操作系统，<strong>用户体验好</strong>，<strong>操作流畅</strong>，<strong>性能稳定</strong>；</p>
</li>
<li><p>用户留存率高；  </p>
</li>
<li><p>功能最为强大，特别是在与系统交互中，几乎所有功能都能实现；</p>
</li>
</ul>
<p>由于 <strong>Native APP</strong> 是直接依托于系统，所以可以直接调用官方提供的API，功能最为全面(比如本地资源操作，通知，动画等)。</p>
<p><strong>缺点：</strong>   </p>
<ul>
<li>开发和维护成本高，无法跨平台，需要各平台各自独立开发；</li>
</ul>
<p><strong>Android</strong> 上基于 <strong>Java</strong> 开发，<strong>iOS</strong> 上基 <strong>OC</strong> 或 <strong>Swift</strong> 开发，相互之间独立，必须要有各自的开发人员。</p>
<ul>
<li>门槛较高，原生人员有一定的入门门槛，人才较少；</li>
</ul>
<p>原生的一个很大特点就是独立，所以不太容易入门，而且 <strong>Android</strong>， <strong>iOS</strong>都需要独立学习。</p>
<ul>
<li>分发成本高，更新缓慢，特别是发布应用商店后，需要等到审核周期；</li>
</ul>
<p>原生应用更新是一个很大的问题， <strong>Android</strong>中还能直接下载整包APK进行更新，但是 <strong>iOS</strong>中，如果是发布 <strong>AppStore</strong> ，必须通过 <strong>AppStore</strong>地址更新，而每次更新都需要审核，所以无法达到及时更新。</p>
<h4 id="1-4-Hybrid-App"><a href="#1-4-Hybrid-App" class="headerlink" title="1.4 Hybrid App"></a>1.4 Hybrid App</h4><p><strong>Hybrid App</strong> 指的是<strong>混合开发</strong>，也就是半原生半 Web 的开发模式，有跨平台效果，当然了，实质最终发布的仍然是独立的原生APP(各种的平台有各种的SDK)。  </p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>学习和开发成本较低，可以跨平台，调试方便</strong>；  </li>
</ul>
<p>Hybrid 开发模式下，由原生提供统一的 API 给 JS 调用，实际的主要逻辑由 HTML 和 JS 完成，最终放在 webview 中显示，这样只需要写一套代码即可，达到跨平台效果，另外也可以直接在浏览器中调试，很方便。  </p>
<p>一般 Hybrid 中的跨平台最少可以跨三个平台: Android App ，iOS App ，普通 webkit 浏览器。 </p>
<p>需要前端人员关注一些原生提供的API，具体的实现无需关心，没有新的学习内容。  </p>
<ul>
<li><strong>维护成本低</strong>，功能可复用，并且更容易更新；  </li>
</ul>
<p>虽然没有 web app 更新那么快速，但是 Hybrid 中也可以通过原生提供 api ，进行资源主动下载，达到只更新资源文件，不更新 apk(ipa) 的效果。  </p>
<ul>
<li>功能更加完善，性能和体验要比起 web app 好太多；  </li>
</ul>
<p>因为可以调用原生api，所以很多功能只要原生提供出就可以实现，另外性能也比较接近原生。  </p>
<ul>
<li>部分性能要求的页面可用原生实现；  </li>
</ul>
<p>这种模式是原生混合 web ，所以我们完全可以将交互强，性能要求高的页面用原生写，然后一些其它页面用 JS 写，嵌入 webview 中，达到最佳体验。  </p>
<p><strong>缺点：</strong></p>
<ul>
<li>相比原生，性能仍然有较大损耗；</li>
</ul>
<p>这种模式受限于 webview 的性能，相比原生而言有不少损耗，体验无法和原生相比。</p>
<ul>
<li>不适用于交互性较强的app；</li>
</ul>
<p>这种模式的主要适用：一些新闻阅读类，信息展示类的 app ，不适用于一些交互较强或者性能要求较高的 app (比如动画较多就不适合)。</p>
<h4 id="1-5-三者区别"><a href="#1-5-三者区别" class="headerlink" title="1.5 三者区别"></a>1.5 三者区别</h4><p><strong>三者使用场景对比：</strong></p>
<p><img src="http://images.pingan8787.com/20190623HybridApp7.png" alt="对比图"></p>
<p><strong>三者技术特征对比：</strong></p>
<p><img src="http://images.pingan8787.com/20190623HybridApp2.png" alt="对比图"></p>
<p><strong>另外增加 ReactNative 一起放入作对比。</strong></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">NativeApp</th>
<th align="left">WebApp</th>
<th align="left">HybridApp</th>
<th>ReactNativeApp</th>
</tr>
</thead>
<tbody><tr>
<td align="left">原生功能体验</td>
<td align="left">优秀</td>
<td align="left">差</td>
<td align="left">良好</td>
<td>接近优秀</td>
</tr>
<tr>
<td align="left">渲染性能</td>
<td align="left">非常快</td>
<td align="left">慢</td>
<td align="left">接近快</td>
<td>快</td>
</tr>
<tr>
<td align="left">是否支持设备底层访问</td>
<td align="left">支持</td>
<td align="left">不支持</td>
<td align="left">支持</td>
<td>支持</td>
</tr>
<tr>
<td align="left">网络要求</td>
<td align="left">支持离线</td>
<td align="left">依赖网络</td>
<td align="left">支持离线(资源存本地情况)</td>
<td>支持离线</td>
</tr>
<tr>
<td align="left">更新复杂度</td>
<td align="left">高(几乎总是通过应用商店更新)</td>
<td align="left">低(服务器端直接更新)</td>
<td align="left">较低(可以进行资源包更新)</td>
<td>较低(可以进行资源包更新)</td>
</tr>
<tr>
<td align="left">编程语言</td>
<td align="left">Android(Java)，iOS(OC/Swift)</td>
<td align="left">js+html+css3</td>
<td align="left">js+html+css3</td>
<td>主要使用JS编写，语法规则JSX</td>
</tr>
<tr>
<td align="left">社区资源</td>
<td align="left">丰富(Android，iOS单独学习)</td>
<td align="left">丰富(大量前端资源)</td>
<td align="left">有局限(不同的Hybrid相互独立)</td>
<td>丰富(统一的活跃社区)</td>
</tr>
<tr>
<td align="left">上手难度</td>
<td align="left">难(不同平台需要单独学习)</td>
<td align="left">简单(写一次，支持不同平台访问)</td>
<td align="left">简单(写一次，运行任何平台)</td>
<td>中等(学习一次，写任何平台)</td>
</tr>
<tr>
<td align="left">开发周期</td>
<td align="left">长</td>
<td align="left">短</td>
<td align="left">较短</td>
<td>中等</td>
</tr>
<tr>
<td align="left">开发成本</td>
<td align="left">昂贵</td>
<td align="left">便宜</td>
<td align="left">较为便宜</td>
<td>中等</td>
</tr>
<tr>
<td align="left">跨平台</td>
<td align="left">不跨平台</td>
<td align="left">所有H5浏览器</td>
<td align="left">Android，iOS，h5浏览器</td>
<td>Android，iOS</td>
</tr>
<tr>
<td align="left">APP发布</td>
<td align="left">AppStore</td>
<td align="left">Web服务器</td>
<td align="left">AppStore</td>
<td>AppStore</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
</tbody></table>
<h4 id="1-6-三者如何选择"><a href="#1-6-三者如何选择" class="headerlink" title="1.6 三者如何选择"></a>1.6 三者如何选择</h4><p>这里简单介绍几种情况，具体还是要以实际项目技术评估结果为主。  </p>
<ul>
<li>选择纯 Native App 模式的情况：</li>
</ul>
<p><strong>性能要求极高，体验要求极好，不追求开发效率</strong>。</p>
<ul>
<li>选择 Web App 模式的情况：</li>
</ul>
<p>不追求用户体验和性能，对离线访问没要求，正常来说，如果追求性能和体验，都不会选用web app。</p>
<ul>
<li>选择 Hybrid App 模式的情况</li>
</ul>
<p><strong>大部分情况下的App都推荐采用这种模式</strong>，这种模式可以用原生来实现要求高的界面，对于一些比较通用型，展示型的页面完全可以用web来实现，达到跨平台效果，<strong>提升效率</strong>。一般好一点的Hybrid方案，都会<strong>把资源放在本地</strong>的，可以<strong>减少网络流量消耗</strong>。</p>
<ul>
<li>选择React Native App模式的情况</li>
</ul>
<p>追求性能，体验，同时追求开发效率，而且有一定的技术资本，舍得前期投入。</p>
<p>React Native这种模式学习成本较高，所以需要前期投入不少时间才能达到较好水平，但是有了一定水准后，开发起来它的优势就体现出来了，性能不逊色原生，而且开发速度也很快</p>
<h3 id="二、什么是-Cordova，它的优缺点是什么"><a href="#二、什么是-Cordova，它的优缺点是什么" class="headerlink" title="二、什么是 Cordova，它的优缺点是什么"></a>二、什么是 Cordova，它的优缺点是什么</h3><p>参考文章： <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37730482/article/details/73920722">《浅谈Cordova框架》</a></p>
<h4 id="2-1-Cordova-简介"><a href="#2-1-Cordova-简介" class="headerlink" title="2.1 Cordova 简介"></a>2.1 Cordova 简介</h4><p>Cordova 是一个用基于 HTML、CSS 和 JavaScript 的，<strong>用于创建跨平台移动应用程序的快速开发平台</strong>。它使开发者能够利用iPhone、Android、Palm、Symbian、WP7、Bada和Blackberry等智能手机的核心功能——包括地理定位、加速器、联系人、声音和振动等，此外 Cordova 拥有丰富的插件，可以调用。</p>
<p>也可以用来开发<strong>原生和WebView组件之间的插件接口</strong>。</p>
<p><strong>来源：</strong><br>Cordova 是 PhoneGap 贡献给 Apache 后的开源项目，是从 PhoneGap 中抽出的核心代码，是驱动 PhoneGap 的核心引擎。可以把它们的关系想象成类似于 Webkit 和 Google Chrome 的关系。</p>
<h4 id="2-2-Cordova-架构图"><a href="#2-2-Cordova-架构图" class="headerlink" title="2.2 Cordova 架构图"></a>2.2 Cordova 架构图</h4><p><img src="http://images.pingan8787.com/20190623HybridApp3.jpg" alt="Cordova架构图">  </p>
<p><strong>架构图介绍：</strong>   </p>
<ul>
<li><strong>Web App</strong></li>
</ul>
<p>用于存放我们程序的代码，包括业务逻辑，还有一些运行需要的资源（如：CSS，JavaScript，图片，媒体文件等）。<br>应用的实现是通过 web 页面，默认的本地文件名称是 <code>index.html</code> ，应用执行在原生应用包装的 WebView 中，这个原生应用是你分发到应用商店中的。</p>
<ul>
<li><strong>WebView</strong></li>
</ul>
<p>Cordova 用的 WebView 可以给应用提供完整用户访问界面，使得应用混合了 Webview 和原生的应用组件。</p>
<ul>
<li><strong>Cordova Plugins</strong></li>
</ul>
<p>插件是 Cordova 生态系统的重要组成部分。它<strong>提供了 Cordova 和原生组件相互通信的接口</strong>，并绑定到了标准的设备API上，这使你能够<strong>通过 JavaScript 调用原生代码</strong>。</p>
<h4 id="2-3-优缺点"><a href="#2-3-优缺点" class="headerlink" title="2.3 优缺点"></a>2.3 优缺点</h4><p><strong>优点：</strong>  </p>
<ul>
<li>跨平台，开发简单，学习成本低；</li>
<li>框架多，插件多，可自定义插件；</li>
<li>发展最早，社区资源丰富；</li>
</ul>
<p><strong>缺点：</strong>  </p>
<ul>
<li>WebView性能低下时，用户体验差，反应慢；</li>
<li>中文文档资源少；</li>
<li>调试不方便，既不像原生那么好调试，也不像纯web那种调试；</li>
</ul>
<h3 id="三、Cordova-插件的原理是什么"><a href="#三、Cordova-插件的原理是什么" class="headerlink" title="三、Cordova 插件的原理是什么"></a>三、Cordova 插件的原理是什么</h3><p>Cordova 插件就是一些附加代码用来提供原生组件的 JavaScript 接口，它允许你的 App 可以使用原生设备的能力，超越了纯粹的 Web App。</p>
<p><strong>Cordova 在 iOS 上的实现原理：</strong><br><img src="http://images.pingan8787.com/20190623HybridApp6.png" alt="cordova"></p>
<h4 id="3-1-工作流程"><a href="#3-1-工作流程" class="headerlink" title="3.1 工作流程"></a>3.1 工作流程</h4><ol>
<li>Cordova 发起对原生的请求：   </li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cordova.exec(successCallback, failCallback, service, action, actionArgs); </span><br><span class="line"><span class="comment">// successCallback: 成功回调方法</span></span><br><span class="line"><span class="comment">// failCallback: 失败回调方法</span></span><br><span class="line"><span class="comment">// server: 所要请求的服务名字</span></span><br><span class="line"><span class="comment">// action: 所要请求的服务具体操作</span></span><br><span class="line"><span class="comment">// actionArgs: 请求操作所带的参数</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>这五个参数并不是直接传给原生，Cordova JS 端会做以下处理：</p>
<ul>
<li>为每个请求生成一个唯一标识( <code>callbackId</code> )，并传给原生端，原生端处理完后，会把 <code>callbackId</code> 连同处理结果一起返回给 JS 端；</li>
<li>以 <code>callbackId</code> 为 <code>key</code>，<code>&#123;success:successCallback, fail:failCallback&#125;</code> 为 <code>value</code>，把这个键值对保存在 JS 端的字典里，<code>successCallback</code> 与 <code>failCallback</code> 这两个参数不需要传给原生，原生返回结果时带上<code> callbackId</code>，JS 端就可以根据 <code>callbackId</code> 找到回调方法；</li>
<li>每次 JS 请求，最后发到原生的数据包括：<code>callbackId</code>, <code>service</code>, <code>action</code>, <code>actionArgs</code>；</li>
</ul>
</li>
</ol>
<p><img src="http://images.pingan8787.com/20190623HybridApp12.png" alt="iOS"></p>
<ol start="3">
<li><p>原生代码拿到 <code>callbackId</code>、<code>service</code>、<code>action</code> 及 <code>actionArgs</code> 后，会做以下处理：</p>
<ul>
<li>根据 <code>service</code> 参数找到对应插件类；</li>
<li>根据 <code>action</code> 参数找到插件类中对应的处理方法，并把 <code>actionArgs</code> 作为处理方法请求参数的一部分传给处理方法；</li>
<li>处理完成后，把处理结果及 <code>callbackId</code> 返回给 JS 端，JS 端收到后会根据 <code>callbackId</code> 找到回调方法，并把处理结果传给回调方法；</li>
</ul>
</li>
</ol>
<p><img src="http://images.pingan8787.com/20190623HybridApp13.png" alt="iOS"></p>
<ol start="4">
<li>JS 端根据 <code>callbackId</code> 回调 <code>cordova.js</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 callbackId 及是否成功标识，找到回调方法，并把处理结果传给回调方法</span></span><br><span class="line"><span class="attr">callbackFromNative</span>: <span class="function"><span class="keyword">function</span>(<span class="params">callbackId, success, status, args, keepCallback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> callback = cordova.callbacks[callbackId];</span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (success &amp;&amp; status == cordova.callbackStatus.OK) &#123;</span><br><span class="line">            callback.success &amp;&amp; callback.success.apply(<span class="literal">null</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            callback.fail &amp;&amp; callback.fail.apply(<span class="literal">null</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clear callback if not expecting any more results</span></span><br><span class="line">        <span class="keyword">if</span> (!keepCallback) &#123;</span><br><span class="line">            <span class="keyword">delete</span> cordova.callbacks[callbackId];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、什么是-JS-Bridge，它的作用是什么"><a href="#四、什么是-JS-Bridge，它的作用是什么" class="headerlink" title="四、什么是 JS Bridge，它的作用是什么"></a>四、什么是 JS Bridge，它的作用是什么</h3><p>参考文章：<a target="_blank" rel="noopener" href="https://juejin.im/post/5abca877f265da238155b6bc">《JSBridge的原理》</a></p>
<h4 id="4-1-JS-Bridge-介绍"><a href="#4-1-JS-Bridge-介绍" class="headerlink" title="4.1 JS Bridge 介绍"></a>4.1 JS Bridge 介绍</h4><p>JSBridge 简单来讲，主要是 <strong>给 JavaScript 提供调用 Native 功能的接口</strong>，让混合开发中的<strong>前端部分</strong>可以方便地使用地址位置、摄像头甚至支付等 Native 功能。</p>
<p>JSBridge 就像其名称中的 <strong>“Bridge”</strong> 的意义一样，<strong>是 Native 和非 Native 之间的桥梁</strong>，它的核心是 <strong>构建 Native 和非 Native 间消息通信的通道，而且是 双向通信的通道</strong>。</p>
<p>JSBridge 另一个叫法及大家熟知的 Hybrid app 技术。</p>
<p><img src="http://images.pingan8787.com/20190623HybridApp4.png" alt="brige"></p>
<p>所谓 <strong>双向通信的通道</strong>:</p>
<ul>
<li>JS 向 Native 发送消息 : </li>
</ul>
<p>调用相关功能、通知 Native 当前 JS 的相关状态等。</p>
<ul>
<li>Native 向 JS 发送消息 : </li>
</ul>
<p>回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。</p>
<h4 id="4-2-JS-Bridge-实现原理"><a href="#4-2-JS-Bridge-实现原理" class="headerlink" title="4.2. JS Bridge 实现原理"></a>4.2. JS Bridge 实现原理</h4><p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dailc/p/5931324.html">《Hybrid APP基础篇(四)-&gt;JSBridge的原理》</a></p>
<p><strong>Android 和 iOS 的 JSBridge 实现方式：</strong>  </p>
<p><img src="http://images.pingan8787.com/20190623HybridApp9.jpeg" alt="brige原理"></p>
<h5 id="4-2-1-基本流程"><a href="#4-2-1-基本流程" class="headerlink" title="4.2.1 基本流程"></a>4.2.1 基本流程</h5><p><img src="http://images.pingan8787.com/20190623HybridApp5.png" alt="brige原理"></p>
<ul>
<li>H5 页面通过某种方式触发一个 <code>url scheme </code>；  </li>
<li>Native 捕获到 <code>url scheme</code>，并进行分析和处理；  </li>
<li>Native 调用 H5 的 JSBridge 对象传递回调；  </li>
</ul>
<p>原生的 WebView/UIWebView 控件已经能够和 JS 实现数据通信了，那为什么还要 JSBridge呢？</p>
<p>其实使用JSBridge有很多方面的考虑：</p>
<ul>
<li>Android4.2以下，<code>addJavascriptInterface</code> 方式有安全漏掉。</li>
<li>iOS7以下，JS 无法调用 Native。</li>
<li><code>url scheme</code> 交互方式是一套现有的成熟方案，可以完美兼容各种版本，对以前老版本技术的兼容。</li>
</ul>
<h5 id="4-2-1-实现流程-Android-为例"><a href="#4-2-1-实现流程-Android-为例" class="headerlink" title="4.2.1 实现流程(Android 为例)"></a>4.2.1 实现流程(Android 为例)</h5><p><img src="http://images.pingan8787.com/20190623HybridApp10.png" alt="brige原理"></p>
<ol>
<li>拟定协议，参考 http 制定的协议为：<code>jsbridge://className:port/methodName?jsonObj</code>；   </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">className   // Android端实现暴露给前端的类名</span><br><span class="line">port        // Android返回结果给前端的端口</span><br><span class="line">methodName  // 前端需要调用的函数</span><br><span class="line">jsonObj     // 前端给Android传递的参数</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新建 HTML 文件命名为 <code>index.html</code>, 编写一个 <code>button</code> 绑定 <code>click</code> 事件；</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;JSBridge.call(</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#x27;bridge&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#x27;showToast&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#123;&#x27;msg&#x27;:&#x27;Hello JSBridge&#x27;&#125;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    function(res)&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">        alert(JSON.stringify(res))</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">)&quot;</span>&gt;</span></span><br><span class="line">    测试showToast </span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>新建 JS 文件命名为 <code>JSBridge.js</code>， 第2步中的 <code>JSBridge.call</code> 即为调用 <code>JSBridge.js </code>中的 <code>call</code> 方法，后面带了四个参数；   </li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call: <span class="function"><span class="keyword">function</span> (<span class="params">obj, method, params, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj+<span class="string">&quot; &quot;</span>+method+<span class="string">&quot; &quot;</span>+params+<span class="string">&quot; &quot;</span>+callback);</span><br><span class="line">    <span class="keyword">var</span> port = Util.getPort();</span><br><span class="line">    <span class="built_in">console</span>.log(port);</span><br><span class="line">    <span class="built_in">this</span>.callbacks[port] = callback;</span><br><span class="line">    <span class="keyword">var</span> uri=Util.getUri(obj,method,params,port);</span><br><span class="line">    <span class="built_in">console</span>.log(uri);</span><br><span class="line">    <span class="built_in">window</span>.prompt(uri, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><code>JSBridge.js</code> 中的 <code>call</code> 方法，最后调用了<code> window.prompt</code> 方法，这个方法就是触发 Android 端 <code>webChromeClient </code>的回调函数用的。</p>
<ol start="4">
<li><code>window.prompt</code> 触发了 <code>WebChromeClient</code>（这个需要使用函数<code>WebView.setWebChromeClient</code>( <code>new WebChromeClietn()</code> )进行设定）；</li>
</ol>
<p>类中的如下回调 <code>onJsPrompt</code>。这时就完成了前端与 Android端 的通信了，因为前端的信息都顺利通过这个函数传递给Android了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onJsPrompt</span><span class="params">(WebView view, String url, String message, String defaultValue, JsPromptResult result)</span> </span>&#123;</span><br><span class="line">    result.confirm(JSBridge.callJava(view,message));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Android 中会定义一个类 <code>JSBridge.java</code> 来管理暴露给前端使用的函数；</li>
</ol>
<p>这个类有两个功能：</p>
<ul>
<li>暴露给前端的函数的动态注册功能。</li>
<li>解析前端信息，调用了 Android 端对应的函数，这个示例中是：<code>showToast</code> 函数。</li>
</ul>
<p>解析前端的信息，获取前端调用的函数名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(uriString);</span><br><span class="line">className = uri.getHost();</span><br><span class="line">param = uri.getQuery();</span><br><span class="line">port = uri.getPort() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">String path = uri.getPath();</span><br><span class="line">HashMap&lt; String, Method&gt; methodHashMap = exposedMethod.get(className);</span><br><span class="line">Method method = methodHashMap.get(methodName);</span><br></pre></td></tr></table></figure>
<p>通过获取的函数名，这里是 <code>showToast </code>，调用 Android 端的 <code>showToast </code>函数。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.invoke(<span class="keyword">null</span>,webView,<span class="keyword">new</span> JSONObject(param),<span class="keyword">new</span> Callback(webView,port));</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>定义类 <code>BridgeImpl.java</code> 来具体的实现暴露给前端的所有函数。这里的 <code>showToast </code>函数如下:</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">showToast</span>(<span class="params">WebView webView, JSONObject param, final JSBridge.Callback callback</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">String</span> message = param.optString(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">    Toast.makeText(webView.getContext(),message,Toast.LENGTH_LONG).show();</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> != callback)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JSONObject object = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            object.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            object.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;vaule1&quot;</span>);</span><br><span class="line">            callback.apply(getJSONObject(<span class="number">0</span>,<span class="string">&quot;ok&quot;</span>,object));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、请列举-Android-与-iOS-平台下-JS-Bridge-的实现方式"><a href="#五、请列举-Android-与-iOS-平台下-JS-Bridge-的实现方式" class="headerlink" title="五、请列举 Android 与 iOS 平台下 JS Bridge 的实现方式"></a>五、请列举 Android 与 iOS 平台下 JS Bridge 的实现方式</h3><blockquote>
<p>这边代码比较多，我使用图片来展示，大家可以放大来查看。   </p>
</blockquote>
<h4 id="5-1-Android-实现方式"><a href="#5-1-Android-实现方式" class="headerlink" title="5.1 Android 实现方式"></a>5.1 Android 实现方式</h4><h5 id="5-1-1-Android-调用-JS-的-2-种方式"><a href="#5-1-1-Android-调用-JS-的-2-种方式" class="headerlink" title="5.1.1 Android 调用 JS 的 2 种方式"></a>5.1.1 Android 调用 JS 的 2 种方式</h5><ol>
<li><strong>通过</strong> <code>WebView</code> <strong>的</strong> <code>loadUrl()</code>:   </li>
</ol>
<p>JS 代码调用一定要在 <code>onPageFinished()</code> 回调之后才能调用，否则不会调用。    </p>
<p><strong>Web 端代码：</strong>   </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>前端代码<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// Android需要调用的方法</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">callJS</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;Android调用了JS的callJS方法&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Android 端代码：</strong>   </p>
<p><img src="http://images.pingan8787.com/20190623HybridApp11.png" alt="Android"></p>
<ol start="2">
<li><strong>通过</strong> <code>WebView</code> <strong>的</strong>  <code>evaluateJavascript()</code>：  </li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要将第一种方法的loadUrl()换成下面该方法即可</span></span><br><span class="line">mWebView.evaluateJavascript(</span><br><span class="line">    <span class="string">&quot;javascript:callJS()&quot;</span>, </span><br><span class="line">    <span class="keyword">new</span> ValueCallback&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public <span class="keyword">void</span> <span class="function"><span class="title">onReceiveValue</span>(<span class="params"><span class="built_in">String</span> value</span>)</span> &#123;</span><br><span class="line">            <span class="comment">//此处为 js 返回的结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="5-1-2-JS-调用-Android-的-3-种方式"><a href="#5-1-2-JS-调用-Android-的-3-种方式" class="headerlink" title="5.1.2 JS 调用 Android 的 3 种方式"></a>5.1.2 JS 调用 Android 的 3 种方式</h5><ol>
<li><strong>通过 <code>WebView</code> 的 <code>addJavascriptInterface()</code> 进行对象映射</strong>:   </li>
</ol>
<p><strong>Android 映射：</strong>   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自Object类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidtoJs</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义JS需要调用的方法</span></span><br><span class="line">    <span class="comment">// 被JS调用的方法必须加入@JavascriptInterface注解</span></span><br><span class="line">    <span class="meta">@JavascriptInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;JS调用了Android的hello方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Web：</strong>   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>前端代码<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="function"><span class="keyword">function</span> <span class="title">callAndroid</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 由于对象映射，所以调用test对象等于调用Android映射的对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            test.hello(<span class="string">&quot;js调用了android中的hello方法&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">      //点击按钮则调用callAndroid函数</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button1&quot;</span> &quot;<span class="attr">callAndroid</span>()&quot;&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Android 端：</strong>   </p>
<p><img src="http://images.pingan8787.com/20190623HybridApp15.png" alt="Android"></p>
<ol start="2">
<li><strong>通过 <code>WebViewClient</code> 的 <code>shouldOverrideUrlLoading ()</code> 方法回调拦截 <code>url</code>：</strong></li>
</ol>
<p><strong>Web 端：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>前端代码<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">callAndroid</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">/*约定的url协议为：js://webview?arg1=111&amp;arg2=222*/</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.location = <span class="string">&quot;js://webview?arg1=111&amp;arg2=222&quot;</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 点击按钮则调用callAndroid（）方法  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button1&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">onclick</span>=<span class="string">&quot;callAndroid()&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span>点击调用Android代码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Android 端：</strong>  </p>
<p><img src="http://images.pingan8787.com/20190623HybridApp16.png" alt="Android"></p>
<ol start="3">
<li><strong>通过 WebChromeClient 的方法回调拦截JS对话框方法：</strong></li>
</ol>
<p>通过 WebChromeClient 的 <code>onJsAlert()</code> 、<code>onJsConfirm()</code> 、<code>onJsPrompt()</code>方法回调拦截JS对话框 <code>alert()</code> 、<code>confirm()</code>、<code>prompt()</code> 消息。   </p>
<p><strong>Web 端：</strong>   </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>前端代码<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">clickprompt</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 调用prompt（）</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> result=prompt(<span class="string">&quot;js://demo?arg1=111&amp;arg2=222&quot;</span>);</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">&quot;demo &quot;</span> + result);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 点击按钮则调用clickprompt()  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button1&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">onclick</span>=<span class="string">&quot;clickprompt()&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span>点击调用Android代码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Android 端：</strong>  </p>
<p><img src="http://images.pingan8787.com/20190623HybridApp17.png" alt="Android"></p>
<h4 id="5-2-iOS-实现方式"><a href="#5-2-iOS-实现方式" class="headerlink" title="5.2 iOS 实现方式"></a>5.2 iOS 实现方式</h4><h5 id="5-2-1-JS-调用-iOS-的-2-种方式"><a href="#5-2-1-JS-调用-iOS-的-2-种方式" class="headerlink" title="5.2.1 JS 调用 iOS 的 2 种方式"></a>5.2.1 JS 调用 iOS 的 2 种方式</h5><ol>
<li><strong>使用 <code>XMLHttpRequest</code> 发起请求的方式：</strong></li>
</ol>
<p><strong>Web 端：</strong>   </p>
<p><img src="http://images.pingan8787.com/20190623HybridApp18.png" alt="iOS"></p>
<p><strong>XMLHttpRequest bridge：</strong></p>
<p>JS 端使用 <code>XMLHttpRequest</code> 发起了一个请求：<code>execXhr.open(&#39;HEAD&#39;, &quot;/!gap_exec?&quot; + (+new Date()), true);</code>，请求的地址是 <code>/!gap_exec</code>；并把请求的数据放在了请求的 header 里面，见这句代码：<code>execXhr.setRequestHeader(&#39;cmds&#39;, iOSExec.nativeFetchMessages());</code>。</p>
<p>而在 Objective-C 端使用一个 <code>NSURLProtocol</code> 的子类来检查每个请求，如果地址是 <code>/!gap_exec</code> 的话，则认为是 Cordova 通信的请求，直接拦截，拦截后就可以通过分析请求的数据，分发到不同的插件类(CDVPlugin 类的子类)的方法中：</p>
<p><img src="http://images.pingan8787.com/20190623HybridApp19.png" alt="iOS"></p>
<p>Cordova 中优先使用这种方式，<code> Cordova.js</code>  中的注释有提及为什么优先使用 <code> XMLHttpRequest</code>  的方式，及为什么保留第二种 <code>iframe bridge</code> 的通信方式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// XHR mode does not work on iOS 4.2, so default to IFRAME_NAV for such devices.</span><br><span class="line">// XHR mode’s main advantage is working around a bug in -webkit-scroll, which</span><br><span class="line">// doesn’t exist in 4.X devices anyways123</span><br></pre></td></tr></table></figure>

<p><strong>iframe bridge：</strong></p>
<p>在 JS 端创建一个透明的 <code>iframe</code>，设置这个 <code>ifame</code> 的 <code>src</code> 为自定义的协议，而 <code>ifame </code>的 <code>src</code> 更改时，<code>UIWebView</code> 会先回调其 <code>delegate</code> 的 <code>webView:shouldStartLoadWithRequest:navigationType:</code> 方法，关键代码如下：</p>
<p><img src="http://images.pingan8787.com/20190623HybridApp20.png" alt="iOS"></p>
<ol start="2">
<li><strong>通过设置透明的 <code>iframe</code> 的 <code>src</code> 属性：</strong></li>
</ol>
<h5 id="5-2-2-iOS-调用-JS-的方式"><a href="#5-2-2-iOS-调用-JS-的方式" class="headerlink" title="5.2.2 iOS 调用 JS 的方式"></a>5.2.2 iOS 调用 JS 的方式</h5><p><code>UIWebView</code> 有一个这样的方法 <code>stringByEvaluatingJavaScriptFromString:</code>，这个方法可以让一个 <code>UIWebView</code> 对象执行一段 JS 代码，这样就可以达到 Objective-C 跟 JS 通信的效果，在 Cordova 的代码中多处用到了这个方法，其中最重要的两处如下：</p>
<ol>
<li><strong>获取 JS 的请求数据：</strong></li>
</ol>
<p><img src="http://images.pingan8787.com/20190623HybridApp21.png" alt="iOS"></p>
<ol start="2">
<li><strong>把 JS 请求的结果返回给 JS 端：</strong></li>
</ol>
<p><img src="http://images.pingan8787.com/20190623HybridApp22.png" alt="iOS"></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>对于初入混合应用开发的小伙伴，这些会有点难度，但是好好理解下那几张流程图，再理一理思路，相信会有帮助😁</p>
<p>给大家加加油~~</p>
<h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><blockquote>
<p>本文首发在 <a target="_blank" rel="noopener" href="http://www.pingan8787.com/">pingan8787个人博客</a>，如需转载请保留个人介绍</p>
</blockquote>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#105;&#110;&#x67;&#97;&#x6e;&#x38;&#x37;&#56;&#x37;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;">&#x70;&#105;&#110;&#x67;&#97;&#x6e;&#x38;&#x37;&#56;&#x37;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>ES小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>
<h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><p><img src="http://images.pingan8787.com/2019_07_12guild_page.png" alt="bg">  </p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-06-26</span><i class="fa fa-tag"></i><a class="tag" href="/tags/前端开发/" title="前端开发">前端开发 </a><a class="tag" href="/tags/原创/" title="原创">原创 </a><a class="tag" href="/tags/HTTP/" title="HTTP">HTTP </a><a class="tag" href="/tags/Hybrid/" title="Hybrid">Hybrid </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://pingan8787.github.io/2019/06/26/165-【Hybrid】HybridApp应用开发中5个必备知识点复习/,pingan8787,165-【Hybrid】HybridApp应用开发中5个必备知识点复习,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/07/13/166-%E3%80%90Hybrid%E3%80%91HybirdApp%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%AD9%E4%B8%AA%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%EF%BC%88WebView-%E8%B0%83%E8%AF%95%E7%AD%89%EF%BC%89/" title="166-【Hybrid】HybirdApp应用开发中9个必备知识点复习（WebView/调试等）">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/06/22/164-%E3%80%90HTTP%E3%80%91HTTP%E7%9A%8415%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/" title="164-【HTTP】HTTP的15个常见知识点复习">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>