<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>175-【Webpack】一看就懂之webpack高级配置与优化 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="阅读原文  一、打包多页面应用所谓打包多页面，就是同时打包出多个 html 页面，打包多页面也是使用 html-webpack-plugin，只不过，在引入插件的时候是创建多个插件对象，因为一个 html-webpack-plugin 插件对象只能打包出一个 html 页面。如: 123456789101112131415161718module.exports &#x3D; &amp;#123;    entr">
<meta property="og:type" content="article">
<meta property="og:title" content="175-【Webpack】一看就懂之webpack高级配置与优化">
<meta property="og:url" content="http://example.com/2019/10/11/175-%E3%80%90Webpack%E3%80%91%E4%B8%80%E7%9C%8B%E5%B0%B1%E6%87%82%E4%B9%8Bwebpack%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="阅读原文  一、打包多页面应用所谓打包多页面，就是同时打包出多个 html 页面，打包多页面也是使用 html-webpack-plugin，只不过，在引入插件的时候是创建多个插件对象，因为一个 html-webpack-plugin 插件对象只能打包出一个 html 页面。如: 123456789101112131415161718module.exports &#x3D; &amp;#123;    entr">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-10-11T13:56:18.000Z">
<meta property="article:modified_time" content="2021-09-20T03:31:47.613Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="前端开发">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="Webpack">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-175-【Webpack】一看就懂之webpack高级配置与优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/11/175-%E3%80%90Webpack%E3%80%91%E4%B8%80%E7%9C%8B%E5%B0%B1%E6%87%82%E4%B9%8Bwebpack%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2019-10-11T13:56:18.000Z" itemprop="datePublished">2019-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      175-【Webpack】一看就懂之webpack高级配置与优化
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/t9qWv_-DZK8mVfa-T0AFWQ">阅读原文</a></p>
</blockquote>
<h2 id="一、打包多页面应用"><a href="#一、打包多页面应用" class="headerlink" title="一、打包多页面应用"></a>一、打包多页面应用</h2><p>所谓打包多页面，就是同时打包出多个 html 页面，打包多页面也是使用 <code>html-webpack-plugin</code>，只不过，在引入插件的时候是创建多个插件对象，因为一个 <code>html-webpack-plugin</code> 插件对象只能打包出一个 html 页面。如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&quot;./src/index.js&quot;</span>, <span class="comment">// 指定打包输出的chunk名为index</span></span><br><span class="line">        <span class="attr">foo</span>: <span class="string">&quot;./src/foo.js&quot;</span> <span class="comment">// 指定打包输出的chunk名为foo</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span>, <span class="comment">// 要打包输出哪个文件，可以使用相对路径</span></span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&quot;index.html&quot;</span>, <span class="comment">// 打包输出后该html文件的名称</span></span><br><span class="line">            <span class="attr">chunks</span>: [<span class="string">&quot;index&quot;</span>] <span class="comment">// 数组元素为chunk名称，即entry属性值为对象的时候指定的名称，index页面只引入index.js</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span>, <span class="comment">// 要打包输出哪个文件，可以使用相对路径</span></span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&quot;foo.html&quot;</span>, <span class="comment">// 打包输出后该html文件的名称</span></span><br><span class="line">            <span class="attr">chunks</span>: [<span class="string">&quot;foo&quot;</span>] <span class="comment">// 数组元素为chunk名称，即entry属性值为对象的时候指定的名称，foo页面只引入foo.js</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包多页面时，关键在于 <code>chunks</code> 属性的配置，因为在没有配置 <code>chunks</code> 属性的情况下，打包输出的 <code>index.html</code> 和 <code>foo.html</code> 都会同时引入 <code>index.js</code> 和<code> foo.js</code>。</p>
<p>所以必须配置 <code>chunks</code> 属性，来指定打包输出后的 html 文件中要引入的输出模块，数组的元素为 <code>entry</code> 属性值为对象的时候指定的 <code>chunk</code> 名，如上配置，才能实现，<code>index.html</code> 只引入 <code>index.js</code>，<code>foo.html</code> 只引入 <code>foo.js</code> 文件</p>
<h2 id="二、配置-source-map"><a href="#二、配置-source-map" class="headerlink" title="二、配置 source-map"></a>二、配置 source-map</h2><p>source-map 就是源码映射，主要是为了方便代码调试，因为我们打包上线后的代码会被压缩等处理，导致所有代码都被压缩成了一行，如果代码中出现错误，那么浏览器只会提示出错位置在第一行，这样我们无法真正知道出错地方在源码中的具体位置。webpack 提供了一个 devtool 属性来配置源码映射。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.lg(<span class="string">`console对象的方法名log写成了lg`</span>); <span class="comment">// 源文件第二行出错</span></span><br><span class="line"></span><br><span class="line">index.js:<span class="number">1</span> Uncaught <span class="built_in">TypeError</span>: <span class="built_in">console</span>.lg is not a <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">    <span class="title">at</span> <span class="title">Object</span>.&lt;<span class="title">anonymous</span>&gt; (<span class="params">index.js:<span class="number">1</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">at</span> <span class="title">o</span> (<span class="params">index.js:<span class="number">1</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">at</span> <span class="title">Object</span>.&lt;<span class="title">anonymous</span>&gt; (<span class="params">index.js:<span class="number">1</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">at</span> <span class="title">o</span> (<span class="params">index.js:<span class="number">1</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">at</span> <span class="title">index</span>.<span class="title">js</span>:1</span></span><br><span class="line"><span class="function">    <span class="title">at</span> <span class="title">index</span>.<span class="title">js</span>:1</span></span><br></pre></td></tr></table></figure>

<p>源码中出错的位置明明是第二行代码，而浏览器中提示的错误确实在第一行，所以如果代码很复杂的情况下，我们就无法找到出错的具体位置</p>
<p><code>devtool</code> 常见的有 6 种配置:</p>
<ul>
<li>1、source-map:</li>
</ul>
<p>这种模式会产生一个 .map 文件，出错了会提示具体的行和列，文件里面保留了打包后的文件与原始文件之间的映射关系，打包输出文件中会指向生成的 <code>.map</code> 文件，告诉 js 引擎源码在哪里，由于源码与 .map 文件分离，所以需要浏览器发送请求去获取 .map 文件,常用于生产环境，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//# sourceMappingURL=index.js.map</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2、eval: </li>
</ul>
<p>这种模式打包速度最快，不会生成 <code>.map </code>文件，会使用 <code>eval </code>将模块包裹，在末尾加入 <code>sourceURL </code>，常用于开发环境，如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//# sourceURL=webpack:///./src/index.js</span><br></pre></td></tr></table></figure>

<ul>
<li>3、eval-source-map: </li>
</ul>
<p>每个 module 会通过 <code>eval()</code> 来执行，并且生成一个 DataUrl 形式的 <code>SourceMap</code> (即 base64 编码形式内嵌到 eval 语句末尾), 但是不会生成 <code>.map</code> 文件，可以减少网络请求<em>，但是打包文件会非常大</em>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJmb28iLCJjb25zb2xlIiwibGciXSwibWFwcGluZ3MiOiJBQUFBLElBQUlBLEdBQUcsR0FBRyxDQUFWO0FBQ0FDLE9BQU8sQ0FBQ0MsRUFBUix1RSxDQUFxQyIsImZpbGUiOiIuL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImxldCBmb28gPSAxO1xuY29uc29sZS5sZyhgY29uc29sZeWvueixoeeahOaWueazleWQjWxvZ+WGmeaIkOS6hmxnYCk7IC8vIOa6kOaWh+S7tuesrOS6jOihjOWHuumUmVxuIl0sInNvdXJjZVJvb3QiOiIifQ==</span></span><br><span class="line"><span class="comment">//# sourceURL=webpack-internal:///./src/index.js</span></span><br></pre></td></tr></table></figure>

<ul>
<li>4、cheap-source-map:</li>
</ul>
<p> 加上 cheap，就只会提示到第几行报错，少了列信息提示，同时不会对引入的库做映射，可以提高打包性能，但是会产生 <code>.map</code> 文件。</p>
<ul>
<li>5、cheap-module-source-map: </li>
</ul>
<p>和 cheap-source-map 相比，加上了 module，就会对引入的库做映射，并且也会产生 <code>.map</code> 文件，用于生产环境。</p>
<ul>
<li>6、cheap-module-eval-source-map: </li>
</ul>
<p>常用于开发环境，使用 <code>cheap</code> 模式可以大幅提高 <code>souremap</code> 生成的效率，加上 module 同时会对引入的库做映射，eval 提高打包构建速度，并且不会产生 .map 文件减少网络请求。</p>
<p>凡是带 eval 的模式都不能用于生产环境，因为其不会产生 .map 文件，会导致打包后的文件变得非常大。通常我们并不关心列信息，所以都会使用 cheap 模式，但是我们也还是需要对第三方库做映射，以便精准找到错误的位置。</p>
<h2 id="三、watch-和-watchOptions-配置"><a href="#三、watch-和-watchOptions-配置" class="headerlink" title="三、watch 和 watchOptions 配置"></a>三、watch 和 watchOptions 配置</h2><p>webpack 可以<strong>监听文件变化</strong>，当它们修改后会重新编译，如果需要开启该功能，那么需要将 <code>watch</code> 设置为 <code>true</code>，具体监听配置通过 <code>watchOptions</code> 进行相应的设置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">watch</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">watchOptions</span>: &#123;</span><br><span class="line">        <span class="attr">poll</span>: <span class="number">1000</span>, <span class="comment">// 每隔一秒轮询一次文件是否发生变化</span></span><br><span class="line">        <span class="attr">aggregateTimeout</span>: <span class="number">1000</span>, <span class="comment">// 当第一个文件更改，会在重新构建前增加延迟。这个选项允许 webpack 将这段时间内进行的任何其他更改都聚合到一次重新构建里</span></span><br><span class="line">        <span class="attr">ignored</span>: <span class="regexp">/node_modules/</span> <span class="comment">// 排除一些文件的监听</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、三个常见小插件的使用"><a href="#四、三个常见小插件的使用" class="headerlink" title="四、三个常见小插件的使用"></a>四、三个常见小插件的使用</h2><ul>
<li>1、clean-webpack-plugin: </li>
</ul>
<p>其作用就是每次打包前先先将输出目录中的内容进行清空，然后再将打包输出的文件输出到输出目录中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin() <span class="comment">// 打包前清空输出目录</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>require(&quot;clean-webpack-plugin)</code> 的结果是一个对象而不是类，这个对象中的 <code>CleanWebpackPlugin</code> 属性才是一个类，我们就是用这个类去创建插件对象。</p>
<ul>
<li>2、copy-webpack-plugin: </li>
</ul>
<p>其作用就是打包的时候带上一些 <code>readMe.md</code>、<code>history.md</code> 等等一起输出到输出目录中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">from</span>: <span class="string">&quot;./readMe.md&quot;</span>, <span class="comment">// 将项目根目录下的readMe.md文件一起拷贝到输出目录中</span></span><br><span class="line">                <span class="attr">to</span>: <span class="string">&quot;&quot;</span> <span class="comment">// 属性值为空字符串则表示是输出目录</span></span><br><span class="line">            &#125;</span><br><span class="line">        ])</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">111</span></span><br><span class="line"></span><br><span class="line">* <span class="number">3</span>、BannerPlugin: </span><br><span class="line"></span><br><span class="line">其作用就是在打包输出的 js 文件的头部添加一些文字注释，比如版权说明等等，<span class="string">`BannerPlugin`</span> 是 <span class="string">`webpack`</span> 内置的插件，如:</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">module.exports = &#123;</span></span><br><span class="line"><span class="string">    plugins: [</span></span><br><span class="line"><span class="string">        new webpack.BannerPlugin(&quot;Copyright © 2019&quot;) // 在js文件头部添加版权说明</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="五、webpack-跨域问题"><a href="#五、webpack-跨域问题" class="headerlink" title="五、webpack 跨域问题"></a>五、webpack 跨域问题</h2><p>为什么 webpack 会存在跨域问题？因为 webpack 打包的是前端代码，其最终会被部署到前端服务器上，而前后端代码通常部署在不同的服务器上，即使是部署在同一个服务器上，所使用的端口也是不一样的，当前端代码通过 ajax 等手段向后端服务器获取数据的时候，由于前后端代码不在同一个域中，故存在跨域问题。</p>
<p>比如，我们通过 <code>webpack</code> 的 <code>devServer</code> 来运行部署我们的前端应用代码，<code>devServer</code> 启动在 <code>8080</code> 端口上，而前端应用代码中会通过 ajax 请求后端数据，后端服务器启动在 <code>3000</code> 端口上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// xhr.open(&quot;get&quot;, &quot;http://localhost:3000/api/test&quot;); // 由于跨域问题无法直接访问到http://localhost:3000下的资源</span></span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;/api/test&quot;</span>); <span class="comment">// 本来是要访问http://localhost:3000/api/test</span></span><br><span class="line">xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>由于前端代码是运行在浏览器中的，如果在前端代码中直接通过 ajax 向<code>http://localhost:3000/api/test</code> 发起请求获取数据，那么由于浏览器同源策略的影响，会存在跨域的问题，所以必须访问 <code>/api/test</code>。但是这样访问又会出现 404 问题，因为其实访问的是 <code>http://localhost:8080/api/test</code>，<code>8080</code> 服务器上是没有该资源的，解决办法就是通过 devServer 配置一个代理服务器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&quot;/api&quot;</span>: <span class="string">&quot;http://localhost:3000&quot;</span> <span class="comment">// 路径以/api开头则代理到localhost:3000上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>http://localhost:8080/api/test </code></p>
<p>就会被代理到<a target="_blank" rel="noopener" href="http://localhost:3000/api/test">http://localhost:3000/api/test</a> 上，proxy 还支持路径的重写，如果 3000 端口服务器上并没有 /api/test 路径，只有 /test 路径，那么就可以对路径进行重写，将 /api 替换掉</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123;<span class="string">&quot;/api&quot;</span>: <span class="string">&quot;&quot;</span>&#125; <span class="comment">// 将/api替换掉</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line">访问 <span class="string">`http://localhost:8080/api/test `</span></span><br><span class="line"></span><br><span class="line">就会被代理到 <span class="string">`http://localhost:3000/test`</span> 上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果前端只是想 <span class="string">`mock`</span> 一些数据，并不需要真正的去访问后台服务器，那么我们可以通过 <span class="string">`devServer`</span> 提供的 <span class="string">`before`</span> 钩子函数获取到内置的服务器对象进行处理请求，这个内置的服务器对象就是 webpack 的 <span class="string">`devServer`</span> 即 <span class="string">`8080`</span> 端口的 <span class="string">`server`</span>，因为是在同一个服务器中请求数据所以也不会出现跨域问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">before(app) &#123; // 此app即webpack的devServer</span></span><br><span class="line"><span class="string">            app.get(&quot;/api/test&quot;, (req, res, next) =&gt; &#123;</span></span><br><span class="line"><span class="string">                res.json(&#123;name: &quot;even&quot;&#125;);</span></span><br><span class="line"><span class="string">            &#125;)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br></pre></td></tr></table></figure>

<p>我们还可以不通过 <code>webpack</code> 提供的 <code>devServer</code> 来启动 <code>webpack</code>，而是使用自己服务器来启动 <code>webapck。</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>); <span class="comment">// 引入webpack</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&quot;./webpack.config.js&quot;</span>); <span class="comment">// 引入配置文件</span></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config); <span class="comment">// 创建webpack的编译器</span></span><br><span class="line"><span class="keyword">const</span> middleWare = <span class="built_in">require</span>(<span class="string">&quot;webpack-dev-middleware&quot;</span>); <span class="comment">//引入webpack的中间件</span></span><br><span class="line">app.use(middleWare(compiler)); <span class="comment">// 将compiler编译器交给中间件处理</span></span><br><span class="line">app.get(<span class="string">&quot;/api/test&quot;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    res.json(&#123;<span class="attr">name</span>: <span class="string">&quot;lhb&quot;</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>通过自定义服务器启动 webpack，这样 webpack 中的前端代码请求数据就和服务器的资源在同一个域中了。</p>
<h2 id="六、resolve-配置"><a href="#六、resolve-配置" class="headerlink" title="六、resolve 配置"></a>六、resolve 配置</h2><p><code>resolve</code> 用于配置模块的解析相关参数的，其属性值为一个对象。</p>
<ul>
<li>1、modules: </li>
</ul>
<p>告诉 webpack 解析模块时应该搜索的目录，即 <code>require</code> 或 <code>import</code> 模块的时候，只写模块名的时候，到哪里去找，其属性值为数组，因为可配置多个模块搜索路径，其搜索路径必须为绝对路径，比如，<code>src</code> 目录下面有一个 <code>foo.js</code> 文件和 <code>index.js</code> 文件:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&quot;./foo&quot;</span>); <span class="comment">// 必须写全foo.js模块的路径</span></span><br><span class="line"><span class="comment">// const foo = require(&quot;foo&quot;); // resolve.modules中配置了模块解析路径为.src目录，则可用只写foo即可搜索到foo.js模块</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">modules</span>: [path.resolve(__dirname, <span class="string">&quot;./src/&quot;</span>), <span class="string">&quot;node_modules&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>resolve.modules</code> 中配置了<code> ./src</code> 目录作为模块的搜索目录，所以 <code>index.js</code> 中可以只写模块名即可搜索到<code> foo.js</code> 模块</p>
<ul>
<li>2、alias: </li>
</ul>
<p>用于给路径或者文件取别名，当 <code>import</code> 或者 <code>require</code> 的模块的路径非常长时，我们可以给该模块的路径或者整个路径名+文件名都设置成一个别名，然后直接引入别名即可找到该模块，比如，有一个模块位置非常深</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const foo = require(&quot;./a/b/c/foo&quot;); // foo.js在./src/a/b/c/foo.js</span></span><br><span class="line"><span class="comment">// const foo = require(&quot;foo&quot;); // foo被映射成了./src/a/b/c/foo.js文件</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&quot;bar/foo.js&quot;</span>); <span class="comment">// bar被映射成了./src/a/b/c/路径</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="string">&quot;foo&quot;</span>: path.resolve(__dirname, <span class="string">&quot;./src/a/b/c/foo.js&quot;</span>),</span><br><span class="line">            <span class="string">&quot;bar&quot;</span>: path.resolve(__dirname, <span class="string">&quot;./src/a/b/c/&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>需要注意的就是，<code>alias</code> 可以映射文件也可以映射路径</p>
<ul>
<li>3、mainFields: </li>
</ul>
<p>我们的 <code>package.json</code> 中可以有多个字段，用于决定优先使用哪个字段来导入模块，比如 <code>bootstrap</code> 模块中含有 js 也含有 css，其 <code>package.json </code>文件中 main 字段对应的是”<code>dist/js/bootstrap</code>“，style 字段中对应的是”<code>dist/css/bootstrap.css</code>“,我们可以通过设置 <code>mainFields</code> 字段来改变默认引入，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">mainFields</span>: [<span class="string">&quot;style&quot;</span>, <span class="string">&quot;main&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4、extensions: </li>
</ul>
<p>用于设置引入模块的时候，如果没有写模块后缀名，webpack 会自动添加后缀去查找，<code>extensions </code>就是用于设置自动添加后缀的顺序，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&quot;js&quot;</span>, <span class="string">&quot;vue&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果项目中引入了 foo 模块，<code>require(&quot;./foo&quot;)</code>,其会优先找 <code>./foo.js</code>, 如果没有找到 <code>./foo.js</code> 则会去找 <code>./foo.vue</code> 文件</p>
<h2 id="七、设置环境变量"><a href="#七、设置环境变量" class="headerlink" title="七、设置环境变量"></a>七、设置环境变量</h2><p>设置环境变量需要用到 webpack 提供的一个内置插件 <code>DefinePlugin</code> 插件，其作用是将一个字符串值设置为全局变量，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            <span class="attr">DEV_MODE</span>: <span class="built_in">JSON</span>.stringify(<span class="string">&#x27;development&#x27;</span>) <span class="comment">// 将&#x27;development&#x27;设置为全局变量DEV_MODE</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样配置之后任何一个模块中都可以直接使用 <code>DEV_MODE</code> 变量了，并且其值为’<code>development</code>‘,与 <code>ProvidePlugin</code> 有点相似，<code>ProvidePlugin </code>是将一个模块注入到所有模块中，实现模块不需要引入即可直接使用。</p>
<h2 id="八、webpack-优化"><a href="#八、webpack-优化" class="headerlink" title="八、webpack 优化"></a>八、webpack 优化</h2><ul>
<li>1、noParse: </li>
</ul>
<p>该配置是作为 module 的一个属性值，即不解析某些模块，所谓不解析，就是不去分析某个模块中的依赖关系，即不去管某个文件是否 import(依赖)了某个文件，对于一些独立的库，比如 jquery，其根本不存在依赖关系，jquery 不会去引入其他的库(要根据自己对某个模块的了解去判断是否要解析该模块)，所以我们可以让 webpack 不去解析 jquery 的依赖关系，提高打包速度，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">noParse</span>:<span class="regexp">/jquery/</span>,<span class="comment">//不去解析jquery中的依赖库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>noParse</code> 是 <code>module</code> 配置中的一个属性，其属性值为一个正则表达式，填入不被解析的模块名称。</p>
<p>为了更清楚的展示 <code>noParse</code> 的作用，假设我们在入口文件 <code>index.js</code> 中引入 <code>bar.js</code> 模块，同时这个 <code>bar.js</code> 模块中也引入了 <code>foo.js</code> 模块，<code>foo.js</code> 不再依赖其他模块了，那么在不使用 <code>noParse</code> 的情况下，webpack 打包的时候，会先去分析 <code>index.js</code> 模块，发现其引入了 <code>bar.js</code> 模块，然后接着分析 <code>bar.js</code> 模块，发现其引入了 <code>foo.js</code> 模块，接着分析 <code>foo.js</code> 模块。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entrypoint index = index.js</span><br><span class="line">[./src/bar.js] 55 bytes &#123;index&#125; [built]</span><br><span class="line">[./src/foo.js] 21 bytes &#123;index&#125; [built]</span><br><span class="line">[./src/index.js] 81 bytes &#123;index&#125; [built]</span><br></pre></td></tr></table></figure>

<p>而此时如果使用了 <code>noParse: /bar/</code>，那么 webpack 打包的时候，会先去分析 <code>index.js</code> 模块，发现其引入了 <code>bar.js</code> 模块，但是由于 <code>noParse</code> 的作用，将不再继续解析 <code>bar.js</code> 模块了，即不会去分析 <code>bar.js</code> 中引入的 <code>foo.js</code> 模块了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entrypoint index = index.js</span><br><span class="line">[./src/bar.js] 55 bytes &#123;index&#125; [built]</span><br><span class="line">[./src/index.js] 81 bytes &#123;index&#125; [built]</span><br></pre></td></tr></table></figure>
<ul>
<li>2、exclude: </li>
</ul>
<p>在 <code>loader</code> 中使用 <code>exclude</code> 排除对某些目录中的文件处理，即引入指定目录下的文件时候，不使用对应的 <code>loader</code> 进行处理，<code>exclude</code> 是 <code>loader </code>配置中的一个属性，属性值为正则表达式，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/.js$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">                            <span class="attr">plugins</span>: [<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3、使用 IgnorePlugin </li>
</ul>
<p>来忽略某个模块中某些目录中的模块引用，比如在引入某个模块的时候，该模块会引入大量的语言包，而我们不会用到那么多语言包，如果都打包进项目中，那么就会影响打包速度和最终包的大小，然后再引入需要使用的语言包即可，如:</p>
<p>项目根目录下有一个 time 包，其中有一个 lang 包，lang 包中包含了各种语言输出对应时间的 js 文件，time 包下的 index.js 会引入 lang 包下所有的 js 文件，那么当我们引入 time 模块的时候，就会将 lang 包下的所有 js 文件都打包进去，添加如下配置:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/lang/</span>, <span class="regexp">/time/</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入 time 模块的时候，如果 time 模块中引入了其中的 lang 模块中的内容，那么就忽略掉，即不引入 lang 模块中的内容，需要注意的是，这 <code>/time/ </code>只是匹配文件夹和 time 模块的具体目录位置无关，即只要是引入了目录名为 time 中的内容就会生效。</p>
<ul>
<li>4、使用 HappyPack：</li>
</ul>
<p>由于在打包过程中有大量的文件需要交个 loader 进行处理，包括解析和转换等操作，而由于 js 是单线程的，所以这些文件只能一个一个地处理，而 HappyPack 的工作原理就是充分发挥 CPU 的多核功能，将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程，happypack 主要起到一个任务劫持的作用，在创建 HappyPack 实例的时候要传入对应文件的 loader，即 use 部分，loader 配置中将使用经过 HappyPack 包装后的 loader 进行处理，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">&quot;happypack&quot;</span>); <span class="comment">// 安装并引入happypack模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> HappyPack(&#123; <span class="comment">// 这里对处理css文件的loader进行包装</span></span><br><span class="line">            <span class="attr">id</span>: <span class="string">&quot;css&quot;</span>,<span class="comment">// 之前的loader根据具体的id进行引入</span></span><br><span class="line">            <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>,<span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">            <span class="attr">threads</span>: <span class="number">5</span> <span class="comment">// 设置开启的进程数</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/.css$/</span>, <span class="comment">// 匹配以.css结尾的文件</span></span><br><span class="line">                use: [<span class="string">&quot;happypack/loader?id=css&quot;</span>] <span class="comment">//根据happypack实例中配置的id引入包装后的laoder，这里的happyPack的h可以大写也可以小写</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack 要打包的文件非常多的时候才需要使用 happypack 进行优化，因为开启多进程也是需要耗时间的，所以文件少的时候，使用 happypack 返回更耗时</p>
<ul>
<li>5、抽离公共模块: </li>
</ul>
<p>对于多入口情况，如果某个或某些模块，被两个以上文件所依赖，那么可以将这个模块单独抽离出来，不需要将这些公共的代码都打包进每个输出文件中，这样会造成代码的重复和流量的浪费，即如果有两个入口文件 index.js 和 other.js，它们都依赖了 foo.js，那么如果不抽离公共模块，那么 foo.js 中的代码都会打包进最终输出的 index.js 和 other.js 中去，即有两份 foo.js 了。抽离公共模块也很简单，直接在 optimization 中配置即可，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">     <span class="attr">splitChunks</span>: &#123; <span class="comment">// 分割代码块，即抽离公共模块</span></span><br><span class="line">         <span class="attr">cacheGroups</span>: &#123; <span class="comment">// 缓存组</span></span><br><span class="line">             <span class="attr">common</span>: &#123; <span class="comment">// 组名为common可自定义</span></span><br><span class="line">                    <span class="attr">chunks</span>: <span class="string">&quot;initial&quot;</span>,</span><br><span class="line">                    <span class="attr">minSize</span>: <span class="number">0</span>, <span class="comment">// 文件大小为0字节以上才抽离</span></span><br><span class="line">                    <span class="attr">minChunks</span>: <span class="number">2</span>, <span class="comment">// 被引用过两次才抽离</span></span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;common/foo&quot;</span>, <span class="comment">// 定义抽离出的文件的名称</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就会将公共的 foo.js 模块抽离到 common 目录下 foo.js 中了，但是如果我们也有多个文件依赖了第三方模块如 jquery，如果按以上配置，那么 jquery 也会被打包进 foo.js 中，会导致代码混乱，所以我们希望将 jquery 单独抽出来，即与 foo.js 分开，我们可以复制一份以上配置，并通过设置抽离代码权重的方式来实现，即优先抽离出 jquery，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">     <span class="attr">splitChunks</span>: &#123; <span class="comment">// 分割代码块，即抽离公共模块</span></span><br><span class="line">         <span class="attr">cacheGroups</span>: &#123; <span class="comment">// 缓存组</span></span><br><span class="line">             <span class="attr">common</span>: &#123; <span class="comment">// 组名为common可自定义</span></span><br><span class="line">                    <span class="attr">chunks</span>: <span class="string">&quot;initial&quot;</span>,</span><br><span class="line">                    <span class="attr">minSize</span>: <span class="number">0</span>, <span class="comment">// 文件大小为0字节以上才抽离</span></span><br><span class="line">                    <span class="attr">minChunks</span>: <span class="number">2</span>, <span class="comment">// 被引用过两次才抽离</span></span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;common/foo&quot;</span>, <span class="comment">// 定义抽离出的文件的名称</span></span><br><span class="line">             &#125;,</span><br><span class="line">             <span class="attr">verdor</span>: &#123;</span><br><span class="line">                    <span class="attr">test</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                    priority: <span class="number">1</span>, <span class="comment">// 设置打包权重，即优先抽离第三方模块</span></span><br><span class="line">                    <span class="attr">chunks</span>: <span class="string">&quot;initial&quot;</span>,</span><br><span class="line">                    <span class="attr">minSize</span>: <span class="number">0</span>, <span class="comment">// 文件大小为0字节以上才抽离</span></span><br><span class="line">                    <span class="attr">minChunks</span>: <span class="number">2</span>, <span class="comment">// 被引用过两次才抽离</span></span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;common/jquery&quot;</span>, <span class="comment">// 定义抽离出的文件的名称</span></span><br><span class="line">                &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就会在 common 目录下同时抽离出 foo.js 和 jquery.js 了，需要注意的是，代码的抽离必须是该模块没有被排除打包，即该模块会被打包进输出 bundle 中，如果第三方模块已经通过 externals 排除打包，则以上 vendor 配置无效。</p>
<ul>
<li>6、按需加载，</li>
</ul>
<p>即在需要使用的时候才打包输出，webpack 提供了 import() 方法，传入要动态加载的模块，来动态加载指定的模块，当 webpack 遇到 import()语句的时候，不会立即去加载该模块，而是在用到该模块的时候，再去加载，也就是说打包的时候会一起打包出来，但是在浏览器中加载的时候并不会立即加载，而是等到用到的时候再去加载，比如，点击按钮后才会加载某个模块，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.createElement(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">button.innerText = <span class="string">&quot;点我&quot;</span></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// 点击按钮后加载foo.js</span></span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&quot;./foo&quot;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123; <span class="comment">// import()返回的是一个Promise对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(button);</span><br></pre></td></tr></table></figure>

<p>从中可以看到，<code>import()</code> 返回的是一个 <code>Promise</code> 对象，其主要就是利用 JSONP 实现动态加载，返回的 <code>res</code> 结果不同的<code> export</code> 方式会有不同，如果使用的 <code>module.exports</code> 输出，那么返回的<code> res</code> 就是 <code>module.exports</code> 输出的结果；如果使用的是 ES6 模块输出，即 <code>export default</code> 输出，那么返回的 res 结果就是 <code>res.default</code>，如:</p>
<p>// ES6模块输出，res结果为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">default</span>: <span class="string">&quot;foo&quot;</span>, <span class="attr">__esModule</span>: <span class="literal">true</span>, <span class="built_in">Symbol</span>(<span class="built_in">Symbol</span>.toStringTag): <span class="string">&quot;Module&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>7、开启模块热更新: </li>
</ul>
<p>模块热更新可以做到在不刷新网页的情况下，更新修改的模块，只编译变化的模块，而不用全部模块重新打包，大大提高开发效率，在未开启热更新的情况下，每次修改了模块，都会重新打包。</p>
<p>要开启模块热更新，那么只需要在 devServer 配置中添加 hot:true 即可。当然仅仅开启模块热更新是不够的，我们需要做一些类似监听的操作，当监听的模块发生变化的时候，重新加载该模块并执行，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span> <span class="comment">// 开启热更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&quot;./foo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">&quot;./foo&quot;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// 监听到foo模块发生变化的时候</span></span><br><span class="line">        <span class="keyword">const</span> foo =  <span class="built_in">require</span>(<span class="string">&quot;./foo&quot;</span>); <span class="comment">// 重新引入该模块并执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(foo);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不使用 <code>module.hot.accept</code> 监听，那么当修改 foo 模块的时候还是会刷新页面的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/11/175-%E3%80%90Webpack%E3%80%91%E4%B8%80%E7%9C%8B%E5%B0%B1%E6%87%82%E4%B9%8Bwebpack%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96/" data-id="ckts3ejyb00mc4d9k53pvfwe7" data-title="175-【Webpack】一看就懂之webpack高级配置与优化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/10/11/176-%E3%80%90HTML%E3%80%91HTML5%E7%9A%845%E4%B8%AA%E5%B8%B8%E7%94%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          176-【HTML】HTML5的5个常用存储方式
        
      </div>
    </a>
  
  
    <a href="/2019/09/20/174-%E3%80%90CSS%E3%80%91Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E5%85%A5%E9%97%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">174-【CSS】Grid网格布局入门</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/" rel="tag">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS%E5%8A%A8%E7%94%BB/" rel="tag">CSS动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome/" rel="tag">Chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6-ES7-ES8/" rel="tag">ES6/ES7/ES8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eslint/" rel="tag">Eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Express/" rel="tag">Express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GraphQL/" rel="tag">GraphQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/H5/" rel="tag">H5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP%E5%8D%8F%E8%AE%AE/" rel="tag">HTTP协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hybrid/" rel="tag">Hybrid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NPM/" rel="tag">NPM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Numpy/" rel="tag">Numpy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/" rel="tag">Tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TyeScript/" rel="tag">TyeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vuejs/" rel="tag">Vuejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/" rel="tag">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/demo/" rel="tag">demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" rel="tag">人工智能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/" rel="tag">全栈开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2/" rel="tag">前端探索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97/" rel="tag">前端知乎系列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/" rel="tag">常用技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" rel="tag">微前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" rel="tag">构建工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB/" rel="tag">源码精读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%83%AD%E9%97%A8/" rel="tag">热门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/" rel="tag">生活杂记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" rel="tag">网络请求</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E6%B8%A9%E5%9F%BA%E7%A1%80/" rel="tag">重温基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Angular/" style="font-size: 11.88px;">Angular</a> <a href="/tags/CSS/" style="font-size: 18.13px;">CSS</a> <a href="/tags/CSS%E5%8A%A8%E7%94%BB/" style="font-size: 12.5px;">CSS动画</a> <a href="/tags/Chrome/" style="font-size: 10px;">Chrome</a> <a href="/tags/ES6-ES7-ES8/" style="font-size: 10.63px;">ES6/ES7/ES8</a> <a href="/tags/Eslint/" style="font-size: 10px;">Eslint</a> <a href="/tags/Express/" style="font-size: 10px;">Express</a> <a href="/tags/GraphQL/" style="font-size: 10px;">GraphQL</a> <a href="/tags/H5/" style="font-size: 10px;">H5</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/HTTP/" style="font-size: 11.88px;">HTTP</a> <a href="/tags/HTTP%E5%8D%8F%E8%AE%AE/" style="font-size: 11.25px;">HTTP协议</a> <a href="/tags/Hybrid/" style="font-size: 10.63px;">Hybrid</a> <a href="/tags/JavaScript/" style="font-size: 19.38px;">JavaScript</a> <a href="/tags/NPM/" style="font-size: 10px;">NPM</a> <a href="/tags/Nodejs/" style="font-size: 11.25px;">Nodejs</a> <a href="/tags/Numpy/" style="font-size: 10.63px;">Numpy</a> <a href="/tags/Python/" style="font-size: 17.5px;">Python</a> <a href="/tags/React/" style="font-size: 12.5px;">React</a> <a href="/tags/Tensorflow/" style="font-size: 10.63px;">Tensorflow</a> <a href="/tags/TyeScript/" style="font-size: 10px;">TyeScript</a> <a href="/tags/TypeScript/" style="font-size: 11.25px;">TypeScript</a> <a href="/tags/Vuejs/" style="font-size: 14.38px;">Vuejs</a> <a href="/tags/WebSocket/" style="font-size: 10px;">WebSocket</a> <a href="/tags/Webpack/" style="font-size: 15.63px;">Webpack</a> <a href="/tags/demo/" style="font-size: 10.63px;">demo</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">中间件</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 16.25px;">人工智能</a> <a href="/tags/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/" style="font-size: 11.25px;">全栈开发</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 20px;">前端开发</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2/" style="font-size: 11.25px;">前端探索</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E4%B9%8E%E7%B3%BB%E5%88%97/" style="font-size: 10.63px;">前端知乎系列</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 18.75px;">原创</a> <a href="/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/" style="font-size: 10.63px;">常用技术</a> <a href="/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">微前端</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 13.75px;">总结</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">机器学习</a> <a href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" style="font-size: 10.63px;">构建工具</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10.63px;">正则表达式</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 10px;">源码</a> <a href="/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB/" style="font-size: 10px;">源码精读</a> <a href="/tags/%E7%83%AD%E9%97%A8/" style="font-size: 10px;">热门</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/" style="font-size: 10px;">生活杂记</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.13px;">算法</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 10px;">编译原理</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" style="font-size: 10px;">网络请求</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.38px;">读书笔记</a> <a href="/tags/%E9%87%8D%E6%B8%A9%E5%9F%BA%E7%A1%80/" style="font-size: 16.88px;">重温基础</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 10px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/28/227-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8SVG%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/">227-【总结】如何优雅的在微信小程序使用SVG字体图标</a>
          </li>
        
          <li>
            <a href="/2021/07/28/226-%E3%80%90HTTP%E3%80%91%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9F/">226-【HTTP】如何优雅的管理HTTP请求和响应拦截器？</a>
          </li>
        
          <li>
            <a href="/2021/07/28/225-%E3%80%90Vue%E3%80%91%E4%BB%8E%E6%89%8B%E5%86%99Vue3%E7%9A%84Reactivity%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%85%A5Vue3%E6%BA%90%E7%A0%81/">225-【Vue】从手写Vue3的Reactivity开始深入Vue3源码</a>
          </li>
        
          <li>
            <a href="/2021/05/30/224-%E3%80%90Chrome%E3%80%915%E4%B8%AAChrome%E8%B0%83%E8%AF%95%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7/">224-【Chrome】5个Chrome调试混合应用的技巧</a>
          </li>
        
          <li>
            <a href="/2021/03/19/223-%E3%80%90%E5%89%8D%E7%AB%AF%E6%8E%A2%E7%B4%A2%E3%80%91%E6%8E%A2%E7%B4%A2Snabbdom%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">223-【前端探索】探索Snabbdom模块系统原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>