<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><meta name="description" content="王平安个人博客,pingan8787,前端开发,人工智能,AI,深度学习,前端框架vue,angular,react,nodejs,python,numpy,pandas,anaconda,Tensorflow,高等数学,概率论,统计学神经网络,"><title>175-【Webpack】一看就懂之webpack高级配置与优化 · pingan8787</title><meta name="description" content="阅读原文

一、打包多页面应用所谓打包多页面，就是同时打包出多个 html 页面，打包多页面也是使用 html-webpack-plugin，只不过，在引入插件的时候是创建多个插件对象，因为一个 html-webpack-plugin 插件对象只能打包出一个 html 页面。如:
123456789"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script type="text/javascript" src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js"></script><script type="text/javascript" src="https://hm.baidu.com/hm.js?de7c89214c05d551ef3ec12341cd0b9e"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;border-radius:15px;"><h3 title=""><a href="/">pingan8787</a></h3></div></div><ul class="my_tages_ul clearfix"><li class="my_tages_li next pagbuttons"><a class="btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"> 前端开发</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 人工智能</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 深度学习</a></li></ul><ul class="my_icon"><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://github.com/pingan8787" title="github"><img src="http://images.pingan8787.com/assets/icon_26_github.png" alt="github"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.yuque.com/wangpingan/cute-frontend" title="语雀"><img src="http://images.pingan8787.com/assets/icon_26_yuque.png" alt="语雀"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/cute-javascript" title="知乎"><img src="http://images.pingan8787.com/icon_zhihu.png" alt="知乎"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://juejin.im/user/586fc337a22b9d0058807d53/posts" title="掘金"><img src="http://images.pingan8787.com/icon_juejin.png" alt="掘金"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://segmentfault.com/blog/pingan8787" title="思否"><img src="http://images.pingan8787.com/icon_sf.png" alt="思否"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36380426" title="CSDN"><img src="http://images.pingan8787.com/icon_csdn.png" alt="CSDN"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/2ec5d94afd60" title="简书"><img src="http://images.pingan8787.com/icon_jianshu.png" alt="简书"></a></li></ul><div style="text-align:center;"><wb:follow-button uid="1689651205" type="red_1" style="margin-top:10px;width:67px;height:24px;display: inline-block;"></wb:follow-button></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>博客作者：</span></a><a href="https://github.com/pingan8787" target="_blank"> pingan8787（leo）</a><div class="by_farbox"> <a href="https://beian.miit.gov.cn/" target="_blank">备案编号：闽ICP备17012095号-1</a></div></div></div><s></s><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/leo">关于Leo</a></li><li><a href="/production">作品</a></li><li><a href="/Catalog">目录</a></li><li><a href="http://js.pingan8787.com" target="_blank">Cute-JavaScript</a></li><li><a href="https://github.com/pingan8787" target="_blank">Github</a></li></div><!--.information//.back_btn
  //li
    //if is_post()
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)") 
    //else
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)",style="display:none;") 
//.avatar
//  img(src= url_for('images/logo@2x.png'))--></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>175-【Webpack】一看就懂之webpack高级配置与优化</a></h3></div><div class="post-content"><blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/t9qWv_-DZK8mVfa-T0AFWQ">阅读原文</a></p>
</blockquote>
<h2 id="一、打包多页面应用"><a href="#一、打包多页面应用" class="headerlink" title="一、打包多页面应用"></a>一、打包多页面应用</h2><p>所谓打包多页面，就是同时打包出多个 html 页面，打包多页面也是使用 <code>html-webpack-plugin</code>，只不过，在引入插件的时候是创建多个插件对象，因为一个 <code>html-webpack-plugin</code> 插件对象只能打包出一个 html 页面。如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&quot;./src/index.js&quot;</span>, <span class="comment">// 指定打包输出的chunk名为index</span></span><br><span class="line">        <span class="attr">foo</span>: <span class="string">&quot;./src/foo.js&quot;</span> <span class="comment">// 指定打包输出的chunk名为foo</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span>, <span class="comment">// 要打包输出哪个文件，可以使用相对路径</span></span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&quot;index.html&quot;</span>, <span class="comment">// 打包输出后该html文件的名称</span></span><br><span class="line">            <span class="attr">chunks</span>: [<span class="string">&quot;index&quot;</span>] <span class="comment">// 数组元素为chunk名称，即entry属性值为对象的时候指定的名称，index页面只引入index.js</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span>, <span class="comment">// 要打包输出哪个文件，可以使用相对路径</span></span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&quot;foo.html&quot;</span>, <span class="comment">// 打包输出后该html文件的名称</span></span><br><span class="line">            <span class="attr">chunks</span>: [<span class="string">&quot;foo&quot;</span>] <span class="comment">// 数组元素为chunk名称，即entry属性值为对象的时候指定的名称，foo页面只引入foo.js</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包多页面时，关键在于 <code>chunks</code> 属性的配置，因为在没有配置 <code>chunks</code> 属性的情况下，打包输出的 <code>index.html</code> 和 <code>foo.html</code> 都会同时引入 <code>index.js</code> 和<code> foo.js</code>。</p>
<p>所以必须配置 <code>chunks</code> 属性，来指定打包输出后的 html 文件中要引入的输出模块，数组的元素为 <code>entry</code> 属性值为对象的时候指定的 <code>chunk</code> 名，如上配置，才能实现，<code>index.html</code> 只引入 <code>index.js</code>，<code>foo.html</code> 只引入 <code>foo.js</code> 文件</p>
<h2 id="二、配置-source-map"><a href="#二、配置-source-map" class="headerlink" title="二、配置 source-map"></a>二、配置 source-map</h2><p>source-map 就是源码映射，主要是为了方便代码调试，因为我们打包上线后的代码会被压缩等处理，导致所有代码都被压缩成了一行，如果代码中出现错误，那么浏览器只会提示出错位置在第一行，这样我们无法真正知道出错地方在源码中的具体位置。webpack 提供了一个 devtool 属性来配置源码映射。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.lg(<span class="string">`console对象的方法名log写成了lg`</span>); <span class="comment">// 源文件第二行出错</span></span><br><span class="line"></span><br><span class="line">index.js:<span class="number">1</span> Uncaught <span class="built_in">TypeError</span>: <span class="built_in">console</span>.lg is not a <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">    <span class="title">at</span> <span class="title">Object</span>.&lt;<span class="title">anonymous</span>&gt; (<span class="params">index.js:<span class="number">1</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">at</span> <span class="title">o</span> (<span class="params">index.js:<span class="number">1</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">at</span> <span class="title">Object</span>.&lt;<span class="title">anonymous</span>&gt; (<span class="params">index.js:<span class="number">1</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">at</span> <span class="title">o</span> (<span class="params">index.js:<span class="number">1</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">at</span> <span class="title">index</span>.<span class="title">js</span>:1</span></span><br><span class="line"><span class="function">    <span class="title">at</span> <span class="title">index</span>.<span class="title">js</span>:1</span></span><br></pre></td></tr></table></figure>

<p>源码中出错的位置明明是第二行代码，而浏览器中提示的错误确实在第一行，所以如果代码很复杂的情况下，我们就无法找到出错的具体位置</p>
<p><code>devtool</code> 常见的有 6 种配置:</p>
<ul>
<li>1、source-map:</li>
</ul>
<p>这种模式会产生一个 .map 文件，出错了会提示具体的行和列，文件里面保留了打包后的文件与原始文件之间的映射关系，打包输出文件中会指向生成的 <code>.map</code> 文件，告诉 js 引擎源码在哪里，由于源码与 .map 文件分离，所以需要浏览器发送请求去获取 .map 文件,常用于生产环境，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//# sourceMappingURL=index.js.map</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2、eval: </li>
</ul>
<p>这种模式打包速度最快，不会生成 <code>.map </code>文件，会使用 <code>eval </code>将模块包裹，在末尾加入 <code>sourceURL </code>，常用于开发环境，如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//# sourceURL=webpack:///./src/index.js</span><br></pre></td></tr></table></figure>

<ul>
<li>3、eval-source-map: </li>
</ul>
<p>每个 module 会通过 <code>eval()</code> 来执行，并且生成一个 DataUrl 形式的 <code>SourceMap</code> (即 base64 编码形式内嵌到 eval 语句末尾), 但是不会生成 <code>.map</code> 文件，可以减少网络请求<em>，但是打包文件会非常大</em>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJmb28iLCJjb25zb2xlIiwibGciXSwibWFwcGluZ3MiOiJBQUFBLElBQUlBLEdBQUcsR0FBRyxDQUFWO0FBQ0FDLE9BQU8sQ0FBQ0MsRUFBUix1RSxDQUFxQyIsImZpbGUiOiIuL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImxldCBmb28gPSAxO1xuY29uc29sZS5sZyhgY29uc29sZeWvueixoeeahOaWueazleWQjWxvZ+WGmeaIkOS6hmxnYCk7IC8vIOa6kOaWh+S7tuesrOS6jOihjOWHuumUmVxuIl0sInNvdXJjZVJvb3QiOiIifQ==</span></span><br><span class="line"><span class="comment">//# sourceURL=webpack-internal:///./src/index.js</span></span><br></pre></td></tr></table></figure>

<ul>
<li>4、cheap-source-map:</li>
</ul>
<p> 加上 cheap，就只会提示到第几行报错，少了列信息提示，同时不会对引入的库做映射，可以提高打包性能，但是会产生 <code>.map</code> 文件。</p>
<ul>
<li>5、cheap-module-source-map: </li>
</ul>
<p>和 cheap-source-map 相比，加上了 module，就会对引入的库做映射，并且也会产生 <code>.map</code> 文件，用于生产环境。</p>
<ul>
<li>6、cheap-module-eval-source-map: </li>
</ul>
<p>常用于开发环境，使用 <code>cheap</code> 模式可以大幅提高 <code>souremap</code> 生成的效率，加上 module 同时会对引入的库做映射，eval 提高打包构建速度，并且不会产生 .map 文件减少网络请求。</p>
<p>凡是带 eval 的模式都不能用于生产环境，因为其不会产生 .map 文件，会导致打包后的文件变得非常大。通常我们并不关心列信息，所以都会使用 cheap 模式，但是我们也还是需要对第三方库做映射，以便精准找到错误的位置。</p>
<h2 id="三、watch-和-watchOptions-配置"><a href="#三、watch-和-watchOptions-配置" class="headerlink" title="三、watch 和 watchOptions 配置"></a>三、watch 和 watchOptions 配置</h2><p>webpack 可以<strong>监听文件变化</strong>，当它们修改后会重新编译，如果需要开启该功能，那么需要将 <code>watch</code> 设置为 <code>true</code>，具体监听配置通过 <code>watchOptions</code> 进行相应的设置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">watch</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">watchOptions</span>: &#123;</span><br><span class="line">        <span class="attr">poll</span>: <span class="number">1000</span>, <span class="comment">// 每隔一秒轮询一次文件是否发生变化</span></span><br><span class="line">        <span class="attr">aggregateTimeout</span>: <span class="number">1000</span>, <span class="comment">// 当第一个文件更改，会在重新构建前增加延迟。这个选项允许 webpack 将这段时间内进行的任何其他更改都聚合到一次重新构建里</span></span><br><span class="line">        <span class="attr">ignored</span>: <span class="regexp">/node_modules/</span> <span class="comment">// 排除一些文件的监听</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、三个常见小插件的使用"><a href="#四、三个常见小插件的使用" class="headerlink" title="四、三个常见小插件的使用"></a>四、三个常见小插件的使用</h2><ul>
<li>1、clean-webpack-plugin: </li>
</ul>
<p>其作用就是每次打包前先先将输出目录中的内容进行清空，然后再将打包输出的文件输出到输出目录中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin() <span class="comment">// 打包前清空输出目录</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>require(&quot;clean-webpack-plugin)</code> 的结果是一个对象而不是类，这个对象中的 <code>CleanWebpackPlugin</code> 属性才是一个类，我们就是用这个类去创建插件对象。</p>
<ul>
<li>2、copy-webpack-plugin: </li>
</ul>
<p>其作用就是打包的时候带上一些 <code>readMe.md</code>、<code>history.md</code> 等等一起输出到输出目录中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">from</span>: <span class="string">&quot;./readMe.md&quot;</span>, <span class="comment">// 将项目根目录下的readMe.md文件一起拷贝到输出目录中</span></span><br><span class="line">                <span class="attr">to</span>: <span class="string">&quot;&quot;</span> <span class="comment">// 属性值为空字符串则表示是输出目录</span></span><br><span class="line">            &#125;</span><br><span class="line">        ])</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">111</span></span><br><span class="line"></span><br><span class="line">* <span class="number">3</span>、BannerPlugin: </span><br><span class="line"></span><br><span class="line">其作用就是在打包输出的 js 文件的头部添加一些文字注释，比如版权说明等等，<span class="string">`BannerPlugin`</span> 是 <span class="string">`webpack`</span> 内置的插件，如:</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">module.exports = &#123;</span></span><br><span class="line"><span class="string">    plugins: [</span></span><br><span class="line"><span class="string">        new webpack.BannerPlugin(&quot;Copyright © 2019&quot;) // 在js文件头部添加版权说明</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="五、webpack-跨域问题"><a href="#五、webpack-跨域问题" class="headerlink" title="五、webpack 跨域问题"></a>五、webpack 跨域问题</h2><p>为什么 webpack 会存在跨域问题？因为 webpack 打包的是前端代码，其最终会被部署到前端服务器上，而前后端代码通常部署在不同的服务器上，即使是部署在同一个服务器上，所使用的端口也是不一样的，当前端代码通过 ajax 等手段向后端服务器获取数据的时候，由于前后端代码不在同一个域中，故存在跨域问题。</p>
<p>比如，我们通过 <code>webpack</code> 的 <code>devServer</code> 来运行部署我们的前端应用代码，<code>devServer</code> 启动在 <code>8080</code> 端口上，而前端应用代码中会通过 ajax 请求后端数据，后端服务器启动在 <code>3000</code> 端口上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// xhr.open(&quot;get&quot;, &quot;http://localhost:3000/api/test&quot;); // 由于跨域问题无法直接访问到http://localhost:3000下的资源</span></span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;/api/test&quot;</span>); <span class="comment">// 本来是要访问http://localhost:3000/api/test</span></span><br><span class="line">xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>由于前端代码是运行在浏览器中的，如果在前端代码中直接通过 ajax 向<code>http://localhost:3000/api/test</code> 发起请求获取数据，那么由于浏览器同源策略的影响，会存在跨域的问题，所以必须访问 <code>/api/test</code>。但是这样访问又会出现 404 问题，因为其实访问的是 <code>http://localhost:8080/api/test</code>，<code>8080</code> 服务器上是没有该资源的，解决办法就是通过 devServer 配置一个代理服务器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&quot;/api&quot;</span>: <span class="string">&quot;http://localhost:3000&quot;</span> <span class="comment">// 路径以/api开头则代理到localhost:3000上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>http://localhost:8080/api/test </code></p>
<p>就会被代理到<a target="_blank" rel="noopener" href="http://localhost:3000/api/test">http://localhost:3000/api/test</a> 上，proxy 还支持路径的重写，如果 3000 端口服务器上并没有 /api/test 路径，只有 /test 路径，那么就可以对路径进行重写，将 /api 替换掉</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123;<span class="string">&quot;/api&quot;</span>: <span class="string">&quot;&quot;</span>&#125; <span class="comment">// 将/api替换掉</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line">访问 <span class="string">`http://localhost:8080/api/test `</span></span><br><span class="line"></span><br><span class="line">就会被代理到 <span class="string">`http://localhost:3000/test`</span> 上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果前端只是想 <span class="string">`mock`</span> 一些数据，并不需要真正的去访问后台服务器，那么我们可以通过 <span class="string">`devServer`</span> 提供的 <span class="string">`before`</span> 钩子函数获取到内置的服务器对象进行处理请求，这个内置的服务器对象就是 webpack 的 <span class="string">`devServer`</span> 即 <span class="string">`8080`</span> 端口的 <span class="string">`server`</span>，因为是在同一个服务器中请求数据所以也不会出现跨域问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">before(app) &#123; // 此app即webpack的devServer</span></span><br><span class="line"><span class="string">            app.get(&quot;/api/test&quot;, (req, res, next) =&gt; &#123;</span></span><br><span class="line"><span class="string">                res.json(&#123;name: &quot;even&quot;&#125;);</span></span><br><span class="line"><span class="string">            &#125;)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br></pre></td></tr></table></figure>

<p>我们还可以不通过 <code>webpack</code> 提供的 <code>devServer</code> 来启动 <code>webpack</code>，而是使用自己服务器来启动 <code>webapck。</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>); <span class="comment">// 引入webpack</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&quot;./webpack.config.js&quot;</span>); <span class="comment">// 引入配置文件</span></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config); <span class="comment">// 创建webpack的编译器</span></span><br><span class="line"><span class="keyword">const</span> middleWare = <span class="built_in">require</span>(<span class="string">&quot;webpack-dev-middleware&quot;</span>); <span class="comment">//引入webpack的中间件</span></span><br><span class="line">app.use(middleWare(compiler)); <span class="comment">// 将compiler编译器交给中间件处理</span></span><br><span class="line">app.get(<span class="string">&quot;/api/test&quot;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    res.json(&#123;<span class="attr">name</span>: <span class="string">&quot;lhb&quot;</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>通过自定义服务器启动 webpack，这样 webpack 中的前端代码请求数据就和服务器的资源在同一个域中了。</p>
<h2 id="六、resolve-配置"><a href="#六、resolve-配置" class="headerlink" title="六、resolve 配置"></a>六、resolve 配置</h2><p><code>resolve</code> 用于配置模块的解析相关参数的，其属性值为一个对象。</p>
<ul>
<li>1、modules: </li>
</ul>
<p>告诉 webpack 解析模块时应该搜索的目录，即 <code>require</code> 或 <code>import</code> 模块的时候，只写模块名的时候，到哪里去找，其属性值为数组，因为可配置多个模块搜索路径，其搜索路径必须为绝对路径，比如，<code>src</code> 目录下面有一个 <code>foo.js</code> 文件和 <code>index.js</code> 文件:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&quot;./foo&quot;</span>); <span class="comment">// 必须写全foo.js模块的路径</span></span><br><span class="line"><span class="comment">// const foo = require(&quot;foo&quot;); // resolve.modules中配置了模块解析路径为.src目录，则可用只写foo即可搜索到foo.js模块</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">modules</span>: [path.resolve(__dirname, <span class="string">&quot;./src/&quot;</span>), <span class="string">&quot;node_modules&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>resolve.modules</code> 中配置了<code> ./src</code> 目录作为模块的搜索目录，所以 <code>index.js</code> 中可以只写模块名即可搜索到<code> foo.js</code> 模块</p>
<ul>
<li>2、alias: </li>
</ul>
<p>用于给路径或者文件取别名，当 <code>import</code> 或者 <code>require</code> 的模块的路径非常长时，我们可以给该模块的路径或者整个路径名+文件名都设置成一个别名，然后直接引入别名即可找到该模块，比如，有一个模块位置非常深</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const foo = require(&quot;./a/b/c/foo&quot;); // foo.js在./src/a/b/c/foo.js</span></span><br><span class="line"><span class="comment">// const foo = require(&quot;foo&quot;); // foo被映射成了./src/a/b/c/foo.js文件</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&quot;bar/foo.js&quot;</span>); <span class="comment">// bar被映射成了./src/a/b/c/路径</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="string">&quot;foo&quot;</span>: path.resolve(__dirname, <span class="string">&quot;./src/a/b/c/foo.js&quot;</span>),</span><br><span class="line">            <span class="string">&quot;bar&quot;</span>: path.resolve(__dirname, <span class="string">&quot;./src/a/b/c/&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>需要注意的就是，<code>alias</code> 可以映射文件也可以映射路径</p>
<ul>
<li>3、mainFields: </li>
</ul>
<p>我们的 <code>package.json</code> 中可以有多个字段，用于决定优先使用哪个字段来导入模块，比如 <code>bootstrap</code> 模块中含有 js 也含有 css，其 <code>package.json </code>文件中 main 字段对应的是”<code>dist/js/bootstrap</code>“，style 字段中对应的是”<code>dist/css/bootstrap.css</code>“,我们可以通过设置 <code>mainFields</code> 字段来改变默认引入，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">mainFields</span>: [<span class="string">&quot;style&quot;</span>, <span class="string">&quot;main&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4、extensions: </li>
</ul>
<p>用于设置引入模块的时候，如果没有写模块后缀名，webpack 会自动添加后缀去查找，<code>extensions </code>就是用于设置自动添加后缀的顺序，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&quot;js&quot;</span>, <span class="string">&quot;vue&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果项目中引入了 foo 模块，<code>require(&quot;./foo&quot;)</code>,其会优先找 <code>./foo.js</code>, 如果没有找到 <code>./foo.js</code> 则会去找 <code>./foo.vue</code> 文件</p>
<h2 id="七、设置环境变量"><a href="#七、设置环境变量" class="headerlink" title="七、设置环境变量"></a>七、设置环境变量</h2><p>设置环境变量需要用到 webpack 提供的一个内置插件 <code>DefinePlugin</code> 插件，其作用是将一个字符串值设置为全局变量，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            <span class="attr">DEV_MODE</span>: <span class="built_in">JSON</span>.stringify(<span class="string">&#x27;development&#x27;</span>) <span class="comment">// 将&#x27;development&#x27;设置为全局变量DEV_MODE</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样配置之后任何一个模块中都可以直接使用 <code>DEV_MODE</code> 变量了，并且其值为’<code>development</code>‘,与 <code>ProvidePlugin</code> 有点相似，<code>ProvidePlugin </code>是将一个模块注入到所有模块中，实现模块不需要引入即可直接使用。</p>
<h2 id="八、webpack-优化"><a href="#八、webpack-优化" class="headerlink" title="八、webpack 优化"></a>八、webpack 优化</h2><ul>
<li>1、noParse: </li>
</ul>
<p>该配置是作为 module 的一个属性值，即不解析某些模块，所谓不解析，就是不去分析某个模块中的依赖关系，即不去管某个文件是否 import(依赖)了某个文件，对于一些独立的库，比如 jquery，其根本不存在依赖关系，jquery 不会去引入其他的库(要根据自己对某个模块的了解去判断是否要解析该模块)，所以我们可以让 webpack 不去解析 jquery 的依赖关系，提高打包速度，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">noParse</span>:<span class="regexp">/jquery/</span>,<span class="comment">//不去解析jquery中的依赖库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>noParse</code> 是 <code>module</code> 配置中的一个属性，其属性值为一个正则表达式，填入不被解析的模块名称。</p>
<p>为了更清楚的展示 <code>noParse</code> 的作用，假设我们在入口文件 <code>index.js</code> 中引入 <code>bar.js</code> 模块，同时这个 <code>bar.js</code> 模块中也引入了 <code>foo.js</code> 模块，<code>foo.js</code> 不再依赖其他模块了，那么在不使用 <code>noParse</code> 的情况下，webpack 打包的时候，会先去分析 <code>index.js</code> 模块，发现其引入了 <code>bar.js</code> 模块，然后接着分析 <code>bar.js</code> 模块，发现其引入了 <code>foo.js</code> 模块，接着分析 <code>foo.js</code> 模块。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entrypoint index = index.js</span><br><span class="line">[./src/bar.js] 55 bytes &#123;index&#125; [built]</span><br><span class="line">[./src/foo.js] 21 bytes &#123;index&#125; [built]</span><br><span class="line">[./src/index.js] 81 bytes &#123;index&#125; [built]</span><br></pre></td></tr></table></figure>

<p>而此时如果使用了 <code>noParse: /bar/</code>，那么 webpack 打包的时候，会先去分析 <code>index.js</code> 模块，发现其引入了 <code>bar.js</code> 模块，但是由于 <code>noParse</code> 的作用，将不再继续解析 <code>bar.js</code> 模块了，即不会去分析 <code>bar.js</code> 中引入的 <code>foo.js</code> 模块了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entrypoint index = index.js</span><br><span class="line">[./src/bar.js] 55 bytes &#123;index&#125; [built]</span><br><span class="line">[./src/index.js] 81 bytes &#123;index&#125; [built]</span><br></pre></td></tr></table></figure>
<ul>
<li>2、exclude: </li>
</ul>
<p>在 <code>loader</code> 中使用 <code>exclude</code> 排除对某些目录中的文件处理，即引入指定目录下的文件时候，不使用对应的 <code>loader</code> 进行处理，<code>exclude</code> 是 <code>loader </code>配置中的一个属性，属性值为正则表达式，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/.js$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">                            <span class="attr">plugins</span>: [<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3、使用 IgnorePlugin </li>
</ul>
<p>来忽略某个模块中某些目录中的模块引用，比如在引入某个模块的时候，该模块会引入大量的语言包，而我们不会用到那么多语言包，如果都打包进项目中，那么就会影响打包速度和最终包的大小，然后再引入需要使用的语言包即可，如:</p>
<p>项目根目录下有一个 time 包，其中有一个 lang 包，lang 包中包含了各种语言输出对应时间的 js 文件，time 包下的 index.js 会引入 lang 包下所有的 js 文件，那么当我们引入 time 模块的时候，就会将 lang 包下的所有 js 文件都打包进去，添加如下配置:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/lang/</span>, <span class="regexp">/time/</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入 time 模块的时候，如果 time 模块中引入了其中的 lang 模块中的内容，那么就忽略掉，即不引入 lang 模块中的内容，需要注意的是，这 <code>/time/ </code>只是匹配文件夹和 time 模块的具体目录位置无关，即只要是引入了目录名为 time 中的内容就会生效。</p>
<ul>
<li>4、使用 HappyPack：</li>
</ul>
<p>由于在打包过程中有大量的文件需要交个 loader 进行处理，包括解析和转换等操作，而由于 js 是单线程的，所以这些文件只能一个一个地处理，而 HappyPack 的工作原理就是充分发挥 CPU 的多核功能，将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程，happypack 主要起到一个任务劫持的作用，在创建 HappyPack 实例的时候要传入对应文件的 loader，即 use 部分，loader 配置中将使用经过 HappyPack 包装后的 loader 进行处理，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">&quot;happypack&quot;</span>); <span class="comment">// 安装并引入happypack模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> HappyPack(&#123; <span class="comment">// 这里对处理css文件的loader进行包装</span></span><br><span class="line">            <span class="attr">id</span>: <span class="string">&quot;css&quot;</span>,<span class="comment">// 之前的loader根据具体的id进行引入</span></span><br><span class="line">            <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>,<span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">            <span class="attr">threads</span>: <span class="number">5</span> <span class="comment">// 设置开启的进程数</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/.css$/</span>, <span class="comment">// 匹配以.css结尾的文件</span></span><br><span class="line">                use: [<span class="string">&quot;happypack/loader?id=css&quot;</span>] <span class="comment">//根据happypack实例中配置的id引入包装后的laoder，这里的happyPack的h可以大写也可以小写</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack 要打包的文件非常多的时候才需要使用 happypack 进行优化，因为开启多进程也是需要耗时间的，所以文件少的时候，使用 happypack 返回更耗时</p>
<ul>
<li>5、抽离公共模块: </li>
</ul>
<p>对于多入口情况，如果某个或某些模块，被两个以上文件所依赖，那么可以将这个模块单独抽离出来，不需要将这些公共的代码都打包进每个输出文件中，这样会造成代码的重复和流量的浪费，即如果有两个入口文件 index.js 和 other.js，它们都依赖了 foo.js，那么如果不抽离公共模块，那么 foo.js 中的代码都会打包进最终输出的 index.js 和 other.js 中去，即有两份 foo.js 了。抽离公共模块也很简单，直接在 optimization 中配置即可，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">     <span class="attr">splitChunks</span>: &#123; <span class="comment">// 分割代码块，即抽离公共模块</span></span><br><span class="line">         <span class="attr">cacheGroups</span>: &#123; <span class="comment">// 缓存组</span></span><br><span class="line">             <span class="attr">common</span>: &#123; <span class="comment">// 组名为common可自定义</span></span><br><span class="line">                    <span class="attr">chunks</span>: <span class="string">&quot;initial&quot;</span>,</span><br><span class="line">                    <span class="attr">minSize</span>: <span class="number">0</span>, <span class="comment">// 文件大小为0字节以上才抽离</span></span><br><span class="line">                    <span class="attr">minChunks</span>: <span class="number">2</span>, <span class="comment">// 被引用过两次才抽离</span></span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;common/foo&quot;</span>, <span class="comment">// 定义抽离出的文件的名称</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就会将公共的 foo.js 模块抽离到 common 目录下 foo.js 中了，但是如果我们也有多个文件依赖了第三方模块如 jquery，如果按以上配置，那么 jquery 也会被打包进 foo.js 中，会导致代码混乱，所以我们希望将 jquery 单独抽出来，即与 foo.js 分开，我们可以复制一份以上配置，并通过设置抽离代码权重的方式来实现，即优先抽离出 jquery，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">     <span class="attr">splitChunks</span>: &#123; <span class="comment">// 分割代码块，即抽离公共模块</span></span><br><span class="line">         <span class="attr">cacheGroups</span>: &#123; <span class="comment">// 缓存组</span></span><br><span class="line">             <span class="attr">common</span>: &#123; <span class="comment">// 组名为common可自定义</span></span><br><span class="line">                    <span class="attr">chunks</span>: <span class="string">&quot;initial&quot;</span>,</span><br><span class="line">                    <span class="attr">minSize</span>: <span class="number">0</span>, <span class="comment">// 文件大小为0字节以上才抽离</span></span><br><span class="line">                    <span class="attr">minChunks</span>: <span class="number">2</span>, <span class="comment">// 被引用过两次才抽离</span></span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;common/foo&quot;</span>, <span class="comment">// 定义抽离出的文件的名称</span></span><br><span class="line">             &#125;,</span><br><span class="line">             <span class="attr">verdor</span>: &#123;</span><br><span class="line">                    <span class="attr">test</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                    priority: <span class="number">1</span>, <span class="comment">// 设置打包权重，即优先抽离第三方模块</span></span><br><span class="line">                    <span class="attr">chunks</span>: <span class="string">&quot;initial&quot;</span>,</span><br><span class="line">                    <span class="attr">minSize</span>: <span class="number">0</span>, <span class="comment">// 文件大小为0字节以上才抽离</span></span><br><span class="line">                    <span class="attr">minChunks</span>: <span class="number">2</span>, <span class="comment">// 被引用过两次才抽离</span></span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;common/jquery&quot;</span>, <span class="comment">// 定义抽离出的文件的名称</span></span><br><span class="line">                &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就会在 common 目录下同时抽离出 foo.js 和 jquery.js 了，需要注意的是，代码的抽离必须是该模块没有被排除打包，即该模块会被打包进输出 bundle 中，如果第三方模块已经通过 externals 排除打包，则以上 vendor 配置无效。</p>
<ul>
<li>6、按需加载，</li>
</ul>
<p>即在需要使用的时候才打包输出，webpack 提供了 import() 方法，传入要动态加载的模块，来动态加载指定的模块，当 webpack 遇到 import()语句的时候，不会立即去加载该模块，而是在用到该模块的时候，再去加载，也就是说打包的时候会一起打包出来，但是在浏览器中加载的时候并不会立即加载，而是等到用到的时候再去加载，比如，点击按钮后才会加载某个模块，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.createElement(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">button.innerText = <span class="string">&quot;点我&quot;</span></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// 点击按钮后加载foo.js</span></span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&quot;./foo&quot;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123; <span class="comment">// import()返回的是一个Promise对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(button);</span><br></pre></td></tr></table></figure>

<p>从中可以看到，<code>import()</code> 返回的是一个 <code>Promise</code> 对象，其主要就是利用 JSONP 实现动态加载，返回的 <code>res</code> 结果不同的<code> export</code> 方式会有不同，如果使用的 <code>module.exports</code> 输出，那么返回的<code> res</code> 就是 <code>module.exports</code> 输出的结果；如果使用的是 ES6 模块输出，即 <code>export default</code> 输出，那么返回的 res 结果就是 <code>res.default</code>，如:</p>
<p>// ES6模块输出，res结果为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">default</span>: <span class="string">&quot;foo&quot;</span>, <span class="attr">__esModule</span>: <span class="literal">true</span>, <span class="built_in">Symbol</span>(<span class="built_in">Symbol</span>.toStringTag): <span class="string">&quot;Module&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>7、开启模块热更新: </li>
</ul>
<p>模块热更新可以做到在不刷新网页的情况下，更新修改的模块，只编译变化的模块，而不用全部模块重新打包，大大提高开发效率，在未开启热更新的情况下，每次修改了模块，都会重新打包。</p>
<p>要开启模块热更新，那么只需要在 devServer 配置中添加 hot:true 即可。当然仅仅开启模块热更新是不够的，我们需要做一些类似监听的操作，当监听的模块发生变化的时候，重新加载该模块并执行，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span> <span class="comment">// 开启热更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&quot;./foo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">&quot;./foo&quot;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// 监听到foo模块发生变化的时候</span></span><br><span class="line">        <span class="keyword">const</span> foo =  <span class="built_in">require</span>(<span class="string">&quot;./foo&quot;</span>); <span class="comment">// 重新引入该模块并执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(foo);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不使用 <code>module.hot.accept</code> 监听，那么当修改 foo 模块的时候还是会刷新页面的。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-10-11</span><i class="fa fa-tag"></i><a class="tag" href="/tags/前端开发/" title="前端开发">前端开发 </a><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a><a class="tag" href="/tags/Webpack/" title="Webpack">Webpack </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://pingan8787.github.io/2019/10/11/175-【Webpack】一看就懂之webpack高级配置与优化/,pingan8787,175-【Webpack】一看就懂之webpack高级配置与优化,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/10/11/176-%E3%80%90HTML%E3%80%91HTML5%E7%9A%845%E4%B8%AA%E5%B8%B8%E7%94%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/" title="176-【HTML】HTML5的5个常用存储方式">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/09/20/174-%E3%80%90CSS%E3%80%91Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E5%85%A5%E9%97%A8/" title="174-【CSS】Grid网格布局入门">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>