<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><meta name="description" content="王平安个人博客,pingan8787,前端开发,人工智能,AI,深度学习,前端框架vue,angular,react,nodejs,python,numpy,pandas,anaconda,Tensorflow,高等数学,概率论,统计学神经网络,"><title>176-【HTML】HTML5的5个常用存储方式 · pingan8787</title><meta name="description" content="一、介绍在 HTML5 规范之前，存储主要是用 cookies 。cookies 的缺点有：   

在请求头上带着数据；
大小是 4k 之内；
主 Domain 污染；

cookies 的主要应用：
购物车、客户登录。
由于存在这么多缺点，因此我们需要解决以下问题：   

解决 4k 的大小问"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script type="text/javascript" src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js"></script><script type="text/javascript" src="https://hm.baidu.com/hm.js?de7c89214c05d551ef3ec12341cd0b9e"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;border-radius:15px;"><h3 title=""><a href="/">pingan8787</a></h3></div></div><ul class="my_tages_ul clearfix"><li class="my_tages_li next pagbuttons"><a class="btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"> 前端开发</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 人工智能</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 深度学习</a></li></ul><ul class="my_icon"><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://github.com/pingan8787" title="github"><img src="http://images.pingan8787.com/assets/icon_26_github.png" alt="github"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.yuque.com/wangpingan/cute-frontend" title="语雀"><img src="http://images.pingan8787.com/assets/icon_26_yuque.png" alt="语雀"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/cute-javascript" title="知乎"><img src="http://images.pingan8787.com/icon_zhihu.png" alt="知乎"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://juejin.im/user/586fc337a22b9d0058807d53/posts" title="掘金"><img src="http://images.pingan8787.com/icon_juejin.png" alt="掘金"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://segmentfault.com/blog/pingan8787" title="思否"><img src="http://images.pingan8787.com/icon_sf.png" alt="思否"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36380426" title="CSDN"><img src="http://images.pingan8787.com/icon_csdn.png" alt="CSDN"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/2ec5d94afd60" title="简书"><img src="http://images.pingan8787.com/icon_jianshu.png" alt="简书"></a></li></ul><div style="text-align:center;"><wb:follow-button uid="1689651205" type="red_1" style="margin-top:10px;width:67px;height:24px;display: inline-block;"></wb:follow-button></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>博客作者：</span></a><a href="https://github.com/pingan8787" target="_blank"> pingan8787（leo）</a><div class="by_farbox"> <a href="https://beian.miit.gov.cn/" target="_blank">备案编号：闽ICP备17012095号-1</a></div></div></div><s></s><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/leo">关于Leo</a></li><li><a href="/production">作品</a></li><li><a href="/Catalog">目录</a></li><li><a href="http://js.pingan8787.com" target="_blank">Cute-JavaScript</a></li><li><a href="https://github.com/pingan8787" target="_blank">Github</a></li></div><!--.information//.back_btn
  //li
    //if is_post()
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)") 
    //else
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)",style="display:none;") 
//.avatar
//  img(src= url_for('images/logo@2x.png'))--></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>176-【HTML】HTML5的5个常用存储方式</a></h3></div><div class="post-content"><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>在 HTML5 规范之前，存储主要是用 <code>cookies</code> 。<br><code>cookies</code> 的缺点有：   </p>
<ul>
<li><strong>在请求头上带着数据</strong>；</li>
<li>大小是 <code>4k</code> 之内；</li>
<li>主 <code>Domain</code> 污染；</li>
</ul>
<p><code>cookies</code> 的主要应用：</p>
<p>购物车、客户登录。</p>
<p>由于存在这么多缺点，因此我们需要解决以下问题：   </p>
<ul>
<li><p>解决 <code>4k</code> 的大小问题；</p>
</li>
<li><p>解决请求头常带存储信息的问题；</p>
</li>
<li><p>解决关系型存储的问题；</p>
</li>
<li><p>跨浏览器；</p>
</li>
</ul>
<h2 id="三、五种存储方式"><a href="#三、五种存储方式" class="headerlink" title="三、五种存储方式"></a>三、五种存储方式</h2><h3 id="1-本地存储-localstorage"><a href="#1-本地存储-localstorage" class="headerlink" title="1. 本地存储 localstorage"></a>1. 本地存储 localstorage</h3><ul>
<li><strong>存储方式</strong>：</li>
</ul>
<p>以键值对( <code>Key-Value </code>)的方式存储，永久存储，永不失效，除非手动删除。</p>
<ul>
<li><strong>大小</strong>：</li>
</ul>
<p>每个域名5M。</p>
<ul>
<li><strong>支持情况</strong>：</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/34uGBxmCnto7TzbpZnGA5yGCqrOJyu2vib5SdR7mb0u6oAzF3nyTHNBdLDxjJ1xMh2EyfBb2QapsjicHdGEwmSrQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="1"></p>
<p>注意：IE9 <code>localStorage</code> 不支持本地文件，需要将项目署到服务器，才可以支持！</p>
<ul>
<li><strong>检测方法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.localStorage)&#123;</span><br><span class="line"> alert(<span class="string">&#x27;This browser supports localStorage&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> alert(<span class="string">&#x27;This browser does NOT support localStorage&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>常用API</strong>：</li>
</ul>
<p>取记录: <code>getItem</code>；</p>
<p>设置记录：<code>setIten</code>；</p>
<p>移除记录：<code>removeItem</code>；</p>
<p>取 <code>key </code>所对应的值：<code>key</code>；</p>
<p>清除记录：<code>clear</code>；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/34uGBxmCnto7TzbpZnGA5yGCqrOJyu2v1WDAITbPXPicjIskPQK5pM8FhT8OAdXvFq2TsI2N9O9hDmrpR9pyxibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="2"></p>
<ul>
<li><strong>存储的内容</strong>：</li>
</ul>
<p>数组，图片，json，样式，脚本。。。（只要是能序列化成字符串的内容都可以存储）。</p>
<h3 id="2-本地存储-sessionstorage"><a href="#2-本地存储-sessionstorage" class="headerlink" title="2. 本地存储 sessionstorage"></a>2. 本地存储 sessionstorage</h3><p>HTML5 的本地存储 API 中的 <code>localStorage</code> 与 <code>sessionStorage</code> 在使用方法上是相同的，区别在于 <code>sessionStorage</code> 在关闭页面后即被清空，而 <code>localStorage</code> 则会一直保存。</p>
<h3 id="3-离线缓存-application-cache"><a href="#3-离线缓存-application-cache" class="headerlink" title="3. 离线缓存 application cache"></a>3. 离线缓存 application cache</h3><p>本地缓存应用所需的文件。</p>
<ul>
<li><strong>使用方法</strong>：</li>
</ul>
<p>需要配置 <code>manifest</code> 文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">&quot;demo.appcache&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Manifest</code> 文件：</li>
</ul>
<p><code>manifest</code> 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。</p>
<p><code>manifest</code> 文件可分为三个部分：</p>
<p>1.1 <code>CACHE MANIFEST</code> - 在此标题下列出的文件将在首次下载后进行缓存；</p>
<p>1.2 <code>NETWORK</code> - 在此标题下列出的文件需要与服务器的连接，且不会被缓存；</p>
<p>1.3 <code>FALLBACK</code> - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）；</p>
<ul>
<li><strong>完整demo</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 2016-07-24 v1.0.0</span><br><span class="line">/theme.css</span><br><span class="line">/main.js</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">login.jsp</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">/html/ /offline.html</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>服务器上</strong>：</li>
</ul>
<p><code>manifest</code> 文件需要配置正确的 <code>MIME-type</code> ，即 “<code>text/cache-manifest</code>”。</p>
<p>如 Tomcat:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mime-mapping&gt;</span><br><span class="line">     &lt;extension&gt;manifest&lt;/extension&gt;</span><br><span class="line">     &lt;mime-type&gt;text/cache-manifest&lt;/mime-type&gt;</span><br><span class="line">&lt;/mime-mapping&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>常用API</strong>：</li>
</ul>
<p>核心是 <code>applicationCache</code> 对象，有个 <code>status</code> 属性，表示应用缓存的当前状态：</p>
<p>0（UNCACHED） :  无缓存， 即没有与页面相关的应用缓存</p>
<p>1（IDLE） : 闲置，即应用缓存未得到更新</p>
<p>2 （CHECKING） : 检查中，即正在下载描述文件并检查更新</p>
<p>3 （DOWNLOADING） : 下载中，即应用缓存正在下载描述文件中指定的资源</p>
<p>4 （UPDATEREADY） : 更新完成，所有资源都已下载完毕</p>
<p>5 （IDLE） :  废弃，即应用缓存的描述文件已经不存在了，因此页面无法再访问应用缓存</p>
<ul>
<li><strong>相关事件</strong>：</li>
</ul>
<p>表示应用缓存状态的改变。</p>
<p><code>checking</code> : 在浏览器为应用缓存查找更新时触发</p>
<p><code>error</code> : 在检查更新或下载资源期间发送错误时触发</p>
<p><code>noupdate</code> : 在检查描述文件发现文件无变化时触发</p>
<p><code>downloading</code> : 在开始下载应用缓存资源时触发</p>
<p><code>progress</code>：在文件下载应用缓存的过程中持续不断地下载地触发</p>
<p><code>updateready</code> : 在页面新的应用缓存下载完毕触发</p>
<p>cached : 在应用缓存完整可用时触发</p>
<ul>
<li><code>Application Cache</code> 的三个优势：</li>
</ul>
<p>① 离线浏览</p>
<p>② 提升页面载入速度</p>
<p>③ 降低服务器压力</p>
<ul>
<li>注意事项：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）</span><br><span class="line"></span><br><span class="line">2. 如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存</span><br><span class="line"></span><br><span class="line">3. 引用manifest的html必须与manifest文件同源，在同一个域下</span><br><span class="line"></span><br><span class="line">4. 浏览器会自动缓存引用manifest文件的HTML文件，这就导致如果改了HTML内容，也需要更新版本才能做到更新。</span><br><span class="line"></span><br><span class="line">5. manifest文件中CACHE则与NETWORK，FALLBACK的位置顺序没有关系，如果是隐式声明需要在最前面</span><br><span class="line"></span><br><span class="line">6. FALLBACK中的资源必须和manifest文件同源</span><br><span class="line"></span><br><span class="line">7. 更新完版本后，必须刷新一次才会启动新版本（会出现重刷一次页面的情况），需要添加监听版本事件。</span><br><span class="line"></span><br><span class="line">8. 站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问</span><br><span class="line"></span><br><span class="line">9. 当manifest文件发生改变时，资源请求本身也会触发更新</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>离线缓存与传统浏览器缓存区别</strong>：</li>
</ul>
<ol>
<li><p>离线缓存是针对整个应用，浏览器缓存是单个文件</p>
</li>
<li><p>离线缓存断网了还是可以打开页面，浏览器缓存不行</p>
</li>
<li><p>离线缓存可以主动通知浏览器更新资源</p>
</li>
</ol>
<h3 id="4-Web-SQL"><a href="#4-Web-SQL" class="headerlink" title="4. Web SQL"></a>4. Web SQL</h3><p>关系数据库，通过SQL语句访问。</p>
<p><code>Web SQL</code> 数据库 API 并不是 HTML5 规范的一部分，但是它是一个独立的规范，引入了一组使用 SQL 操作客户端数据库的 APIs。</p>
<ul>
<li><strong>支持情况</strong>：</li>
</ul>
<p><code>Web SQL</code> 数据库可以在最新版的 Safari, Chrome 和 Opera 浏览器中工作。</p>
<ul>
<li><strong>核心方法</strong>：</li>
</ul>
<p>①<code>openDatabase</code>：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。</p>
<p>②<code>transaction</code>：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。</p>
<p>③<code>executeSql</code>：这个方法用于执行实际的 SQL 查询。</p>
<ul>
<li><strong>打开数据库</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = openDatabase(<span class="string">&#x27;mydb&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>, <span class="string">&#x27;Test DB&#x27;</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>,fn);</span><br><span class="line"><span class="comment">// openDatabase() 方法对应的五个参数</span></span><br><span class="line"><span class="comment">// 分别为：数据库名称、版本号、描述文本、数据库大小、创建回调</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行查询操作</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = openDatabase(<span class="string">&#x27;mydb&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>, <span class="string">&#x27;Test DB&#x27;</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;  </span><br><span class="line">   tx.executeSql(<span class="string">&#x27;CREATE TABLE IF NOT EXISTS WIN (id unique, name)&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>插入数据</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = openDatabase(<span class="string">&#x27;mydb&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>, <span class="string">&#x27;Test DB&#x27;</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span><br><span class="line">   tx.executeSql(<span class="string">&#x27;CREATE TABLE IF NOT EXISTS WIN (id unique, name)&#x27;</span>);</span><br><span class="line">   tx.executeSql(<span class="string">&#x27;INSERT INTO WIN (id, name) VALUES (1, &quot;winty&quot;)&#x27;</span>);</span><br><span class="line">   tx.executeSql(<span class="string">&#x27;INSERT INTO WIN (id, name) VALUES (2, &quot;LuckyWinty&quot;)&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>读取数据</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span><br><span class="line">   tx.executeSql(<span class="string">&#x27;SELECT * FROM WIN&#x27;</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params">tx, results</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> len = results.rows.length, i;</span><br><span class="line">      msg = <span class="string">&quot;&lt;p&gt;查询记录条数: &quot;</span> + len + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;#status&#x27;</span>).innerHTML +=  msg;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">         alert(results.rows.item(i).name );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;, <span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由这些操作可以看出，基本上都是用SQL语句进行数据库的相关操作，如果你会MySQL的话，这个应该比较容易用。</p>
<h3 id="5-IndexedDB"><a href="#5-IndexedDB" class="headerlink" title="5. IndexedDB"></a>5. IndexedDB</h3><p>索引数据库 (IndexedDB) API（作为 HTML5 的一部分）对创建具有丰富本地存储数据的数据密集型的离线 HTML5 Web 应用程序很有用。</p>
<p>同时它还有助于本地缓存数据，使传统在线 Web 应用程序（比如移动 Web 应用程序）能够更快地运行和响应。</p>
<ul>
<li><strong>异步API</strong>：</li>
</ul>
<p>在 IndexedDB 大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求——响应的模式，比如打开数据库的操作:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/34uGBxmCnto7TzbpZnGA5yGCqrOJyu2vyYezL9lNFpqFLJQwibAseZSoE0CzApfbbZYeznRKRJFBSDDCRyxjdYg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="3"></p>
<p>这样，我们打开数据库的时候，实质上返回了一个DB对象，而这个对象就在result中。</p>
<p>由上图可以看出，除了 <code>result</code> 之外。还有几个重要的属性就是 <code>onerror</code> 、 <code>onsuccess</code> 、 <code>onupgradeneeded</code> （我们请求打开的数据库的版本号和已经存在的数据库版本号不一致的时候调用）。</p>
<p>这就类似于我们的 <code>ajax</code> 请求那样。我们发起了这个请求之后并不能确定它什么时候才请求成功，所以需要在回调中处理一些逻辑。</p>
<ul>
<li><strong>关闭与删除</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeDB</span>(<span class="params">db</span>)</span>&#123;</span><br><span class="line">     db.close();</span><br><span class="line">&#125;<span class="function"><span class="keyword">function</span> <span class="title">deleteDB</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">     indexedDB.deleteDatabase(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>数据存储</strong>：</li>
</ul>
<p>indexedDB 中没有表的概念，而是 <code>objectStore</code> ，一个数据库中可以包含多个<code>objectStore</code>，<code>objectStore</code>是一个灵活的数据结构，可以存放多种类型数据。</p>
<p>也就是说一个 <code>objectStore</code> 相当于一张表，里面存储的每条数据和一个键相关联。</p>
<p>我们可以使用每条记录中的某个指定字段作为键值（ <code>keyPath</code> ），也可以使用自动生成的递增数字作为键值（ <code>keyGenerator</code> ），也可以不指定。</p>
<p>选择键的类型不同， <code>objectStore</code> 可以存储的数据结构也有差异。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-10-11</span><i class="fa fa-tag"></i><a class="tag" href="/tags/前端开发/" title="前端开发">前端开发 </a><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a><a class="tag" href="/tags/Webpack/" title="Webpack">Webpack </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://pingan8787.github.io/2019/10/11/176-【HTML】HTML5的5个常用存储方式/,pingan8787,176-【HTML】HTML5的5个常用存储方式,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/10/21/177-%E3%80%90JavaScript%E3%80%91%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/" title="177-【JavaScript】模块化方案总结">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/10/11/175-%E3%80%90Webpack%E3%80%91%E4%B8%80%E7%9C%8B%E5%B0%B1%E6%87%82%E4%B9%8Bwebpack%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96/" title="175-【Webpack】一看就懂之webpack高级配置与优化">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>