<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><meta name="description" content="王平安个人博客,pingan8787,前端开发,人工智能,AI,深度学习,前端框架vue,angular,react,nodejs,python,numpy,pandas,anaconda,Tensorflow,高等数学,概率论,统计学神经网络,"><title>167-【Webpack】Webpack怎么运行 · pingan8787</title><meta name="description" content="原文地址：《Webpack 是怎样运行的?》

在平时开发中我们经常会用到 Webpack 这个时下最流行的前端打包工具。它打包开发代码，输出能在各种浏览器运行的代码，提升了开发至发布过程的效率。
我们知道一份Webpack配置文件主要包含入口（ entry ）、输出文件（ output ）、模式、"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script type="text/javascript" src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js"></script><script type="text/javascript" src="https://hm.baidu.com/hm.js?de7c89214c05d551ef3ec12341cd0b9e"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;border-radius:15px;"><h3 title=""><a href="/">pingan8787</a></h3></div></div><ul class="my_tages_ul clearfix"><li class="my_tages_li next pagbuttons"><a class="btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"> 前端开发</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 人工智能</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 深度学习</a></li></ul><ul class="my_icon"><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://github.com/pingan8787" title="github"><img src="http://images.pingan8787.com/assets/icon_26_github.png" alt="github"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.yuque.com/wangpingan/cute-frontend" title="语雀"><img src="http://images.pingan8787.com/assets/icon_26_yuque.png" alt="语雀"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/cute-javascript" title="知乎"><img src="http://images.pingan8787.com/icon_zhihu.png" alt="知乎"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://juejin.im/user/586fc337a22b9d0058807d53/posts" title="掘金"><img src="http://images.pingan8787.com/icon_juejin.png" alt="掘金"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://segmentfault.com/blog/pingan8787" title="思否"><img src="http://images.pingan8787.com/icon_sf.png" alt="思否"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36380426" title="CSDN"><img src="http://images.pingan8787.com/icon_csdn.png" alt="CSDN"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/2ec5d94afd60" title="简书"><img src="http://images.pingan8787.com/icon_jianshu.png" alt="简书"></a></li></ul><div style="text-align:center;"><wb:follow-button uid="1689651205" type="red_1" style="margin-top:10px;width:67px;height:24px;display: inline-block;"></wb:follow-button></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>博客作者：</span></a><a href="https://github.com/pingan8787" target="_blank"> pingan8787（leo）</a><div class="by_farbox"> <a href="https://beian.miit.gov.cn/" target="_blank">备案编号：闽ICP备17012095号-1</a></div></div></div><s></s><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/leo">关于Leo</a></li><li><a href="/production">作品</a></li><li><a href="/Catalog">目录</a></li><li><a href="http://js.pingan8787.com" target="_blank">Cute-JavaScript</a></li><li><a href="https://github.com/pingan8787" target="_blank">Github</a></li></div><!--.information//.back_btn
  //li
    //if is_post()
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)") 
    //else
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)",style="display:none;") 
//.avatar
//  img(src= url_for('images/logo@2x.png'))--></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>167-【Webpack】Webpack怎么运行</a></h3></div><div class="post-content"><blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019117897">《Webpack 是怎样运行的?》</a></p>
</blockquote>
<p>在平时开发中我们经常会用到 <code>Webpack </code>这个时下最流行的前端打包工具。它打包开发代码，输出能在各种浏览器运行的代码，提升了开发至发布过程的效率。</p>
<p>我们知道一份Webpack配置文件主要包含入口（ <code>entry </code>）、输出文件（ <code>output </code>）、模式、加载器（ <code>Loader </code>）、插件（ <code>Plugin </code>）等几个部分。但如果只需要组织 JS 文件的话，指定入口和输出文件路径即可完成一个迷你项目的打包。下面我们来通过一个简单的项目来看一下Webpack是怎样运行的。</p>
<h3 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h3><blockquote>
<p>本文使用 webpack ^4.30.0 作示例.为了更好地观察产出的文件，我们将模式设置为 development 关闭代码压缩，再开启 source-map 支持原始源代码调试。除此之外。我们还简单的写了一个插件 <code>MyPlugin </code>来去除源码中的注释。</p>
</blockquote>
<p>新建 <code>src/index.js</code>:    </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello webpack!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>新建 <code>webpack </code>配置文件 <code>webpack.config.js </code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> MyPlugin = <span class="built_in">require</span>(<span class="string">&#x27;./src/MyPlugin.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">    <span class="keyword">new</span> MyPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新建 <code>src/MyPlugin.js </code>。<a target="_blank" rel="noopener" href="https://github.com/xiangxingchen/blog/issues/18">了解webpack插件更多信息</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.options = options</span><br><span class="line">    <span class="built_in">this</span>.externalModules = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="regexp">/(&quot;([^\\\&quot;]*(\\.)?)*&quot;)|(&#x27;([^\\\&#x27;]*(\\.)?)*&#x27;)|(\/&#123;2,&#125;.*?(\r|\n))|(\/\*(\n|.)*?\*\/)|(\/\*\*\*\*\*\*\/)/g</span></span><br><span class="line">    compiler.hooks.emit.tap(<span class="string">&#x27;CodeBeautify&#x27;</span>, <span class="function">(<span class="params">compilation</span>)=&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.keys(compilation.assets).forEach(<span class="function">(<span class="params">data</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> content = compilation.assets[data].source() <span class="comment">// 欲处理的文本</span></span><br><span class="line">        content = content.replace(reg, <span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>&#123; <span class="comment">// 去除注释后的文本</span></span><br><span class="line">          <span class="keyword">return</span> <span class="regexp">/^\/&#123;2,&#125;/</span>.test(word) || <span class="regexp">/^\/\*!/</span>.test(word) || <span class="regexp">/^\/\*&#123;3,&#125;\//</span>.test(word) ? <span class="string">&quot;&quot;</span> : word;</span><br><span class="line">        &#125;);</span><br><span class="line">        compilation.assets[data] = &#123;</span><br><span class="line">          <span class="function"><span class="title">source</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> content</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="title">size</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> content.length</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = MyPlugin</span><br></pre></td></tr></table></figure>

<p>现在我们运行命令 <code>webpack --config webpack.config.js</code> ，打包完成后会多出一个输出目录 <code>dist</code>：<code>dist/main.js</code>。<code>main</code> 是 <code>webpack</code> 默认设置的输出文件名，我们快速瞄一眼这个文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">&quot;./src/index.js&quot;</span>: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>整个文件只含一个立即执行函数（<code>IIFE</code>），我们称它为 <code>webpackBootstrap</code>，它仅接收一个对象 —— 未加载的 模块集合（<code>modules</code>），这个<code> modules</code> 对象的 <code>key</code> 是一个路径，<code>value</code> 是一个函数。你也许会问，这里的模块是什么？它们又是如何加载的呢？</p>
<p>在细看产出代码前，我们先丰富一下源代码：</p>
<p>新文件 <code>src/utils/math.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> plus = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>修改 <code>src/index.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; plus &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils/math.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello webpack!&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1 + 2: &#x27;</span>, plus(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>我们按照 ES 规范的模块化语法写了一个简单的模块 <code>src/utils/math.js</code>，给 <code>src/index.js</code> 引用。<code>Webpack</code> 用自己的方式支持了 <code>ES6 Module</code> 规范，前面提到的 <code>modul</code>e 就是和 <code>ES6 module</code> 对应的概念。</p>
<p>接下来我们看一下这些模块是如何通 ES5 代码实现的。再次运行命令 <code>webpack --config webpack.config.js</code> 后查看输出文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">&quot;./src/index.js&quot;</span>: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="string">&quot;./src/utils/math.js&quot;</span>: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>IIFE</code> 传入的 <code>modules</code> 对象里多了一个键值对，对应着新模块 <code>src/utils/math.js</code>，这和我们在源代码中拆分的模块互相呼应。然而，有了 <code>modules</code> 只是第一步，这份文件最终达到的效果应该是让各个模块按开发者编排的顺序运行。</p>
<h3 id="探究-webpackBootstrap"><a href="#探究-webpackBootstrap" class="headerlink" title="探究 webpackBootstrap"></a>探究 <code>webpackBootstrap</code></h3><p>接下来看看 <code>webpackBootstrap</code> 函数中有些什么：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpackBootstrap</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存 __webpack_require__ 函数加载过的模块</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Webpack 加载函数，用来加载 webpack 定义的模块</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>moduleId 模块 ID，一般为模块的源码路径，如 &quot;./src/index.js&quot;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns <span class="type">&#123;Object&#125;</span> </span>exports 导出对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 __webpack_require__ 函数对象上挂载一些变量及函数 ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传入表达式的值为 &quot;./src/index.js&quot;</span></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line">&#125;)(<span class="comment">/* modules */</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到其实主要做了两件事：</p>
<ol>
<li>定义一个模块加载函数<code> __webpack_require__</code>。</li>
<li>使用加载函数加载入口模块 <code>&quot;./src/index.js&quot;</code>。</li>
</ol>
<p>整个 <code>webpackBootstrap</code> 中只出现了入口模块的影子，那其他模块又是如何加载的呢？我们顺着 <code>__webpack_require__(&quot;./src/index.js&quot;)</code> 细看加载函数的内部逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 重复加载则利用缓存</span></span><br><span class="line">  <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是第一次加载，则初始化模块对象，并缓存</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">    <span class="attr">i</span>: moduleId,  <span class="comment">// 模块 ID</span></span><br><span class="line">    <span class="attr">l</span>: <span class="literal">false</span>,     <span class="comment">// 模块加载标识</span></span><br><span class="line">    <span class="attr">exports</span>: &#123;&#125;   <span class="comment">// 模块导出对象</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 执行模块</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>module.exports -- 模块导出对象引用，改变模块包裹函数内部的 this 指向</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">module</span></span> -- 当前模块对象引用</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>module.exports -- 模块导出对象引用</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">__webpack_require__</span></span> -- 用于在模块中加载其他模块</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模块加载标识置为已加载</span></span><br><span class="line">  <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回当前模块的导出对象引用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，加载函数使用了闭包变量 <code>installedModules</code>，用来将已加载过的模块保存在内存中。 接着是初始化模块对象，并把它挂载到缓存里。然后是模块的执行过程，加载入口文件时 <code>modules[moduleId]</code> 其实就是<code>./src/index.js</code>对应的模块函数。执行模块函数前传入了跟模块相关的几个实参，让模块可以导出内容，以及加载其他模块的导出。最后标识该模块加载完成，返回模块的导出内容。</p>
<p>根据 <code>__webpack_require__</code> 的缓存和导出逻辑，我们得知在整个 <code>IIFE</code> 运行过程中，加载已缓存的模块时，都会直接返回<code>installedModules[moduleId].exports</code>，换句话说，相同的模块只有在第一次引用的时候才会执行模块本身。</p>
<h3 id="模块执行函数"><a href="#模块执行函数" class="headerlink" title="模块执行函数"></a>模块执行函数</h3><p><code>__webpack_require__ </code>中通过 <code>modules[moduleId].call()</code> 运行了模块执行函数，下面我们就进入到<code>webpackBootstrap</code> 的参数部分，看看模块的执行函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 入口模块 ./src/index.js ***/</span></span><br><span class="line"><span class="string">&quot;./src/index.js&quot;</span>: (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 用于区分 ES 模块和其他模块规范，不影响理解 demo，战略跳过。</span></span><br><span class="line">  __webpack_require__.r(__webpack_exports__);</span><br><span class="line">  <span class="comment">/* harmony import */</span></span><br><span class="line"> <span class="comment">// 源模块代码中，`import &#123;plus&#125; from &#x27;./utils/math.js&#x27;;` 语句被 loader 解析转化。</span></span><br><span class="line">    <span class="comment">// 加载 &quot;./src/utils/math.js&quot; 模块，</span></span><br><span class="line">  <span class="keyword">var</span> _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">&quot;./src/utils/math.js&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello webpack!&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1 + 2: &#x27;</span>, <span class="built_in">Object</span>(_utils_math_js__WEBPACK_IMPORTED_MODULE_0__[<span class="string">&quot;plus&quot;</span>])(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;./src/utils/math.js&quot;</span>: (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  __webpack_require__.r(__webpack_exports__);</span><br><span class="line">  <span class="comment">/* harmony export (binding) */</span></span><br><span class="line"><span class="comment">// 源模块代码中，`export` 语句被 loader 解析转化。</span></span><br><span class="line">  __webpack_require__.d(__webpack_exports__, <span class="string">&quot;plus&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> plus;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> plus = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行顺序是：入口模块 -&gt; 工具模块 -&gt; 入口模块。入口模块中首先就通过 <code>__webpack_require__(&quot;./src/utils/math.js&quot;)</code> 拿到了工具模块的 exports 对象。再看工具模块，ES 导出语法转化成了<code>__webpack_require__.d(__webpack_exports__, [key], [getter])</code>，而 <code>__webpack_require__.d</code> 函数的定义在 <code>webpackBootstrap</code> 内：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 exports 对象导出的属性。</span></span><br><span class="line">  __webpack_require__.d = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, name, getter</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 exports （不含原型链上）没有 [name] 属性，定义该属性的 getter。</span></span><br><span class="line">    <span class="keyword">if</span> (!__webpack_require__.o(<span class="built_in">exports</span>, name)) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, name, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">get</span>: getter</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包装 Object.prototype.hasOwnProperty 函数。</span></span><br><span class="line">  __webpack_require__.o = <span class="function"><span class="keyword">function</span> (<span class="params">object, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(object, property);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>可见 <code>__webpack_require__.d</code> 其实就是 <code>Object.defineProperty</code> 的简单包装.<br>引用工具模块导出的变量后，入口模块再执行它剩余的部分。至此，<code>Webpack</code> 基本的模块执行过程就结束了。</p>
<p>好了，我们用流程图总结一下<code> Webpack</code> 模块的加载思路：</p>
<p><img src="http://images.pingan8787.com/20190718_articlex1.jpg" alt="图片描述"></p>
<h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>有上面的打包我们发现将不同的打包进一个 <code>main.js</code> 文件。<code>main.js</code> 会集中消耗太多网络资源，导致用户需要等待很久才可以开始与网页交互。</p>
<p>一般的解决方式是：根据需求降低首次加载文件的体积，在需要时（如切换前端路由器，交互事件回调）异步加载其他文件并使用其中的模块。</p>
<p>Webpack 推荐用 ES <code>import()</code> 规范来异步加载模块，我们根据 ES 规范修改一下入口模块的 import 方式，让其能够异步加载模块：</p>
<p><code>src/index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello webpack!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./utils/math&#x27;</span>).then(<span class="function"><span class="params">mathUtil</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1 + 2: &#x27;</span> + mathUtil.plus(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line">工具模块（src/utils/math.js）依然不变，在webpack 配置里，我们指定一下资源文件的公共资源路径（publicPath），后面的探索过程中会遇到。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> MyPlugin = <span class="built_in">require</span>(<span class="string">&#x27;./src/MyPlugin.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;/dist/&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">    <span class="keyword">new</span> MyPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着执行一下打包，可以看到除了 <code>dist/main.js</code> 外，又多了一个 <code>dist/0.js</code> <code>./src/utils/math.js</code>。模块从<code>main chunk</code> 迁移到了 <code>0 chunk</code> 中。而与 <code>demo1</code> 不同的是，<code>main chunk</code> 中添加了一些用于异步加载的代码，我们概览一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpackBootstrap</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 加载其他 chunk 后的回调函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于缓存 chunk 的加载状态，0 为已加载</span></span><br><span class="line">  <span class="keyword">var</span> installedChunks = &#123;</span><br><span class="line">    <span class="string">&quot;main&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼接 chunk 的请求地址</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">jsonpScriptSrc</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步 require 函数，内容不变</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步加载 chunk，返回封装加载过程的 promise</span></span><br><span class="line">  __webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// defineProperty 的包装，内容不变</span></span><br><span class="line">  __webpack_require__.d = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, name, getter</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据配置文件确定的 publicPath</span></span><br><span class="line">  __webpack_require__.p = <span class="string">&quot;/dist/&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**** JSONP 初始化 ****/</span></span><br><span class="line">  <span class="keyword">var</span> jsonpArray = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] || [];</span><br><span class="line">  <span class="keyword">var</span> oldJsonpFunction = jsonpArray.push.bind(jsonpArray);</span><br><span class="line">  jsonpArray.push = webpackJsonpCallback;</span><br><span class="line">  jsonpArray = jsonpArray.slice();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);</span><br><span class="line">  <span class="keyword">var</span> parentJsonpFunction = oldJsonpFunction;</span><br><span class="line">  <span class="comment">/**** JSONP 初始化 ****/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">&quot;./src/index.js&quot;</span>: (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&#x27;Hello webpack!\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      __webpack_require__.e(<span class="comment">/*! import() */</span> <span class="number">0</span>).then(__webpack_require__.bind(<span class="literal">null</span>, <span class="comment">/*! ./utils/math */</span> <span class="string">&quot;./src/utils/math.js&quot;</span>)).then(<span class="function"><span class="params">mathUtil</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;1 + 2: &#x27;</span> + mathUtil.plus(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>webpackBootstrap</code> 的函数体部分增加了一些内容，参数部分移除了<code>&quot;./src/utils/math.js&quot;</code>模块。跟着包裹函数的执行顺序，我们先聚焦到「<code>JSONP 初始化</code>」部分：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储 jsonp 的数组，首次运行为 []</span></span><br><span class="line"><span class="keyword">var</span> jsonpArray = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] || [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存 jsonpArray 的 push 函数，首次运行为 Array.prototype.push</span></span><br><span class="line"><span class="keyword">var</span> oldJsonpFunction = jsonpArray.push.bind(jsonpArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 jsonpArray 的 push 重写为 webpackJsonpCallback （加载其他 chunk 后的回调函数）</span></span><br><span class="line">jsonpArray.push = webpackJsonpCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 jsonpArray 重置为正常数组，push 重置为 Array.prototype.push</span></span><br><span class="line">jsonpArray = jsonpArray.slice();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 jsonpArray 为 []，不做任何事</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.push</span></span><br><span class="line"><span class="keyword">var</span> parentJsonpFunction = oldJsonpFunction;</span><br></pre></td></tr></table></figure>

<p>初始化结束后，变化就是 <code>window</code> 上挂载了一个 <code>webpackJsonp</code> 数组，它的值为<code> []</code>；此外，这个数组的 <code>push</code> 被改写为 <code>webpackJsonpCallback</code> 函数，我们在后面会提到这些准备工作的作用。</p>
<p>接着是 <code>__webpack_require__ </code>入口模块，由于 <code>__webpack_require__</code> 函数没有改变，我们继续观察入口模块执行函数有了什么变化。</p>
<p>显然，<code>import(&#39;../utils/math.js&#39;)</code> 被转化为<code>__webpack_require__.e(0).then(__webpack_require__.bind(null, &quot;./src/utils/math.js&quot;))</code>。0 是 <code>./src/utils/math.js</code> 所在 <code>chunk</code> 的<code>id</code>，「同步加载模块」的逻辑拆分成了「先加载 <code>chunk</code>，完成后再加载模块」。</p>
<p>我们翻到 <code>__webpack_require__.e </code>的定义位置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promises = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// installedChunks 是在 webpackBootstrap 中维护的 chunk 缓存</span></span><br><span class="line">  <span class="keyword">var</span> installedChunkData = installedChunks[chunkId];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// chunk 未加载</span></span><br><span class="line">  <span class="keyword">if</span>(installedChunkData !== <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// installedChunkData 为 promise 表示 chunk 加载中</span></span><br><span class="line">    <span class="keyword">if</span>(installedChunkData) &#123;</span><br><span class="line">      promises.push(installedChunkData[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*** 首次加载 chunk: ***/</span></span><br><span class="line">      <span class="comment">// 初始化 promise 对象</span></span><br><span class="line">      <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        installedChunkData = installedChunks[chunkId] = [resolve, reject];</span><br><span class="line">      &#125;);</span><br><span class="line">      promises.push(installedChunkData[<span class="number">2</span>] = promise);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建 script 标签加载 chunk</span></span><br><span class="line">      <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">      <span class="keyword">var</span> onScriptComplete;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ... 省略一些 script 属性设置</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// src 根据 publicPath 和 chunkId 拼接</span></span><br><span class="line">      script.src = jsonpScriptSrc(chunkId);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载结束回调函数，处理 script 加载完成、加载超时、加载失败的情况</span></span><br><span class="line">      onScriptComplete = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        script.onerror = script.onload = <span class="literal">null</span>; <span class="comment">// 避免 IE 内存泄漏问题</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">var</span> chunk = installedChunks[chunkId];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 script 加载完成，但 chunk 没有加载完成的情况</span></span><br><span class="line">        <span class="keyword">if</span>(chunk !== <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// chunk 加载中</span></span><br><span class="line">          <span class="keyword">if</span>(chunk) &#123;</span><br><span class="line">            <span class="keyword">var</span> errorType = event &amp;&amp; (event.type === <span class="string">&#x27;load&#x27;</span> ? <span class="string">&#x27;missing&#x27;</span> : event.type);</span><br><span class="line">            <span class="keyword">var</span> realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;</span><br><span class="line">            <span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Loading chunk &#x27;</span> + chunkId + <span class="string">&#x27; failed.\n(&#x27;</span> + errorType + <span class="string">&#x27;: &#x27;</span> + realSrc + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            error.type = errorType;</span><br><span class="line">            error.request = realSrc;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reject(error)</span></span><br><span class="line">            chunk[<span class="number">1</span>](error);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 统一将没有加载的 chunk 标记为未加载</span></span><br><span class="line">          installedChunks[chunkId] = <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 12 秒超时时间</span></span><br><span class="line">      <span class="keyword">var</span> timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        onScriptComplete(&#123; <span class="attr">type</span>: <span class="string">&#x27;timeout&#x27;</span>, <span class="attr">target</span>: script &#125;);</span><br><span class="line">      &#125;, <span class="number">120000</span>);</span><br><span class="line"></span><br><span class="line">      script.onerror = script.onload = onScriptComplete;</span><br><span class="line">      head.appendChild(script);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*** 首次加载 chunk ***/</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看起来有点长，我们一步步剖析，先从第一行和最后一行来看，整个函数将异步加载的过程封装到了 <code>promise</code> 中，最终导出。</p>
<p>接着从第二行开始，<code>installedChunkData</code> 从缓存中取值，显然首次加载 <code>chunk</code> 时此处是 <code>undefined</code>。接下来，<code>installedChunkData</code> 的 <code>undefined</code> 值触发了第一层 <code>if</code> 语句的判断条件。紧接着进行到第二层 <code>if</code> 语句，此时根据判断条件走入 <code>else </code>块，这里 <code>if</code> 块里的内容我们先战略跳过，<code>else </code>里主要有两块内容，一是 <code>chunk</code> 脚本加载过程，这个过程创建了一个 <code>script</code> 标签，使其请求 <code>chunk</code>所在地址并执行<code> chunk</code> 内容；二是初始化 <code>promise</code> ，并用 <code>promis</code> 控制 <code>chunk</code> 文件加载过程。</p>
<p>不过，我们只在这段 <code>else</code> 代码块中找到了 <code>reject</code> 的使用处，也就是在 chunk 加载异常时<code> chunk[1](error)</code> 的地方，但并没发现更重要的 <code>resolve </code>的使用地点，仅仅是把 <code>resolve</code> 挂在了缓存上（<code>installedChunks[chunkId] = [resolve, reject]</code>）。</p>
<p>这里的 <code>chunk</code> 文件加载下来会发生什么呢？让我们打开<code>dist/0.js </code>一探究竟：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] || []).push([[<span class="number">0</span>], &#123;</span><br><span class="line">  <span class="string">&quot;./src/utils/math.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">      &quot;use strict&quot;</span>;</span><br><span class="line">      __webpack_require__.r(__webpack_exports__);</span><br><span class="line">      <span class="comment">/* harmony export (binding) */</span></span><br><span class="line">      __webpack_require__.d(__webpack_exports__, <span class="string">&quot;plus&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> plus;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> plus = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>我们发现了：</p>
<ol>
<li>久违的 <code>./src/utils/math.js</code> 模块</li>
<li><code>window[&quot;webpackJsonp&quot;]</code> 数组的使用地点</li>
</ol>
<p>这段代码开始执行，把异步加载相关的 <code>chunk id</code> 与模块传给<code> push</code> 函数。而前面已经提到过，<code>window[&quot;webpackJsonp&quot;] </code>数组的 <code>push</code> 函数已被重写为 <code>webpackJsonpCallback</code> 函数，它的定义位置在 <code>webpackBootstrap</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunkIds = data[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> moreModules = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then flag all &quot;chunkIds&quot; as loaded and fire callback</span></span><br><span class="line">  <span class="keyword">var</span> moduleId, chunkId, i = <span class="number">0</span>, resolves = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 chunk 标记为已加载</span></span><br><span class="line">  <span class="keyword">for</span>(;i &lt; chunkIds.length; i++) &#123;</span><br><span class="line">    chunkId = chunkIds[i];</span><br><span class="line">    <span class="keyword">if</span>(installedChunks[chunkId]) &#123;</span><br><span class="line">      resolves.push(installedChunks[chunkId][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    installedChunks[chunkId] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 &quot;moreModules&quot; 加到 webpackBootstrap 中的 modules 闭包变量中。</span></span><br><span class="line">  <span class="keyword">for</span>(moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">      modules[moduleId] = moreModules[moduleId];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// parentJsonpFunction 是 window[&quot;webpackJsonp&quot;] 的原生 push</span></span><br><span class="line">  <span class="comment">// 将 data 加入全局数组，缓存 chunk 内容</span></span><br><span class="line">  <span class="keyword">if</span>(parentJsonpFunction) parentJsonpFunction(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 resolve 后，加载 chunk 的 promise 状态变为 resolved，then 内的函数开始执行。</span></span><br><span class="line">  <span class="keyword">while</span>(resolves.length) &#123;</span><br><span class="line">    resolves.shift()();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>走进这个函数中，意味着异步加载的 <code>chunk</code> 内容已经拿到，这个时候我们要完成两件事，一是让依赖这次异步加载结果的模块继续执行，二是缓存加载结果。</p>
<p>关于第一点，我们回忆一下之前 <code>__webpack_require__.e</code> 的内容，此时 <code>chunk</code> 还处于「加载中」的状态，也就是说对应的 <code>installedChunks[chunkId]</code> 的值此时为<code> [resolve, reject, promise]</code>。 而这里，<code>chunk</code> 已经加载，但 <code>promise</code> 还未决议，于是 <code>webpackJsonpCallback</code> 内部定义了一个 <code>resolves</code> 变量用来收集 <code>installedChunks</code> 上的 <code>resolve</code> 并执行它。`</p>
<p>接下来说到第二点，就要涉及几个层面的缓存了。</p>
<p>首先是 <code>chunk</code> 层面，这里有两个相关操作，操作一将 <code>installedChunks[chunkId]</code> 置为 0 可以让 <code>__webpack_require__.e </code>在第二次加载同一 <code>chunk</code> 时返回一个立即决议的 <code>promise</code>（<code>Promise.all([])</code>）；操作二将 <code>chunk data</code> 添加进 <code>window[&quot;webpackJsonp&quot;]</code> 数组，可以在多入口模式时，方便地拿到已加载过的 <code>chunk</code> 缓存。通过以下代码实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 缓存执行部分 ***/</span></span><br><span class="line"><span class="keyword">var</span> jsonpArray = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] || [];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);</span><br><span class="line"><span class="keyword">var</span> parentJsonpFunction = oldJsonpFunction;</span><br><span class="line"><span class="comment">/*** 缓存执行部分 ***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 缓存添加部分 ***/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 此处的 parentJsonpFunction 是 window[&quot;webpackJsonp&quot;] 数组的原生 push</span></span><br><span class="line">    <span class="keyword">if</span> (parentJsonpFunction) parentJsonpFunction(data);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*** 缓存添加部分 ***/</span></span><br></pre></td></tr></table></figure>
<p>而在 <code>modules</code> 层面，<code>chunk</code> 中的 <code>moreModule</code>s 被合入入口文件的<code> modules</code> 中，可供下一个微任务中的 <code>__webpack_require__</code> 同步加载模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;./src/index.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Hello webpack!&#x27;</span>);</span><br><span class="line">      <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        __webpack_require__.e(<span class="number">0</span>).then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">&quot;./src/utils/math.js&quot;</span>)).then(<span class="function"><span class="params">mathUtil</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;1 + 2: &#x27;</span> + mathUtil.plus(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>__webpack_require__.e(0) </code>返回的 <code>promise</code> 决议后，<code>__webpack_require__.bind(null, &quot;./src/utils/math.js&quot;)</code> 可以加载到<code>chunk</code>携带的模块，并返回模块作为下一个微任务函数的入参，接下来就是 <code>Webpack Loader</code> 翻译过的其他业务代码了。</p>
<p>现在让我们把异步流程梳理一下：</p>
<p><img src="http://images.pingan8787.com/20190718_articlex2.jpg" alt="图片描述"></p>
<p><img src="http://images.pingan8787.com/2019_07_12guild_page.png" alt="2019_07_12guild_page"></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-07-18</span><i class="fa fa-tag"></i><a class="tag" href="/tags/前端开发/" title="前端开发">前端开发 </a><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a><a class="tag" href="/tags/Webpack/" title="Webpack">Webpack </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://pingan8787.github.io/2019/07/18/167-【Webpack】Webpack怎么运行/,pingan8787,167-【Webpack】Webpack怎么运行,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/07/23/168-%E3%80%90JavaScript%E3%80%91%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8sort%E6%96%B9%E6%B3%95/" title="168-【JavaScript】正确使用sort方法">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/07/13/166-%E3%80%90Hybrid%E3%80%91HybirdApp%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%AD9%E4%B8%AA%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%EF%BC%88WebView-%E8%B0%83%E8%AF%95%E7%AD%89%EF%BC%89/" title="166-【Hybrid】HybirdApp应用开发中9个必备知识点复习（WebView/调试等）">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>