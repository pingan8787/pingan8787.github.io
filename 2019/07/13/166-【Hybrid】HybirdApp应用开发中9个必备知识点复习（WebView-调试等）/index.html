<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><meta name="description" content="王平安个人博客,pingan8787,前端开发,人工智能,AI,深度学习,前端框架vue,angular,react,nodejs,python,numpy,pandas,anaconda,Tensorflow,高等数学,概率论,统计学神经网络,"><title>166-【Hybrid】HybirdApp应用开发中9个必备知识点复习（WebView/调试等） · pingan8787</title><meta name="description" content="Author
王平安



E-mail
&amp;#112;&amp;#x69;&amp;#x6e;&amp;#103;&amp;#97;&amp;#110;&amp;#56;&amp;#55;&amp;#x38;&amp;#x37;&amp;#64;&amp;#113;&amp;#x71;&amp;#46;&amp;#x63;&amp;#111;&amp;#109;


博  客
www.pingan8787.com


微  "><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script type="text/javascript" src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js"></script><script type="text/javascript" src="https://hm.baidu.com/hm.js?de7c89214c05d551ef3ec12341cd0b9e"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;border-radius:15px;"><h3 title=""><a href="/">pingan8787</a></h3></div></div><ul class="my_tages_ul clearfix"><li class="my_tages_li next pagbuttons"><a class="btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"> 前端开发</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 人工智能</a></li><li class="my_tages_li next pagbuttons"><a class="btn btn" target="_blank" rel="noopener" href="http://www.pingan8787.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"> 深度学习</a></li></ul><ul class="my_icon"><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://github.com/pingan8787" title="github"><img src="http://images.pingan8787.com/assets/icon_26_github.png" alt="github"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.yuque.com/wangpingan/cute-frontend" title="语雀"><img src="http://images.pingan8787.com/assets/icon_26_yuque.png" alt="语雀"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/cute-javascript" title="知乎"><img src="http://images.pingan8787.com/icon_zhihu.png" alt="知乎"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://juejin.im/user/586fc337a22b9d0058807d53/posts" title="掘金"><img src="http://images.pingan8787.com/icon_juejin.png" alt="掘金"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://segmentfault.com/blog/pingan8787" title="思否"><img src="http://images.pingan8787.com/icon_sf.png" alt="思否"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36380426" title="CSDN"><img src="http://images.pingan8787.com/icon_csdn.png" alt="CSDN"></a></li><li class="my_icon_li"><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/2ec5d94afd60" title="简书"><img src="http://images.pingan8787.com/icon_jianshu.png" alt="简书"></a></li></ul><div style="text-align:center;"><wb:follow-button uid="1689651205" type="red_1" style="margin-top:10px;width:67px;height:24px;display: inline-block;"></wb:follow-button></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>博客作者：</span></a><a href="https://github.com/pingan8787" target="_blank"> pingan8787（leo）</a><div class="by_farbox"> <a href="https://beian.miit.gov.cn/" target="_blank">备案编号：闽ICP备17012095号-1</a></div></div></div><s></s><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/leo">关于Leo</a></li><li><a href="/production">作品</a></li><li><a href="/Catalog">目录</a></li><li><a href="http://js.pingan8787.com" target="_blank">Cute-JavaScript</a></li><li><a href="https://github.com/pingan8787" target="_blank">Github</a></li></div><!--.information//.back_btn
  //li
    //if is_post()
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)") 
    //else
      //a.fa.fa-chevron-left(onclick="window.history.go(-1)",style="display:none;") 
//.avatar
//  img(src= url_for('images/logo@2x.png'))--></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>166-【Hybrid】HybirdApp应用开发中9个必备知识点复习（WebView/调试等）</a></h3></div><div class="post-content"><hr>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#112;&#x69;&#x6e;&#103;&#97;&#110;&#56;&#55;&#x38;&#x37;&#64;&#113;&#x71;&#46;&#x63;&#111;&#109;">&#112;&#x69;&#x6e;&#103;&#97;&#110;&#56;&#55;&#x38;&#x37;&#64;&#113;&#x71;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>微信公众号</td>
<td>前端自习课</td>
</tr>
<tr>
<td><img src="http://images.pingan8787.com/Hybrid%E5%B0%81%E9%9D%A22.png" alt="bg"></td>
<td></td>
</tr>
</tbody></table>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们大前端团队内部 📖<strong>每周一练</strong> 的知识复习计划继续加油，本篇文章是 <strong>《Hybrid APP 混合应用专题》</strong> 主题的第二期和第三期的合集。  </p>
<p>这一期共整理了 10 个问题，和相应的参考答案，文字和图片较多，<strong>建议大家可以收藏，根据文章目录来阅读</strong>。</p>
<p>之前分享的每周内容，我都整理到掘金收藏集 <a target="_blank" rel="noopener" href="https://juejin.im/collection/5cd11b0af265da0346227e24">📔《EFT每周一练》</a> 上啦，欢迎点赞收藏咯💕💕。  </p>
<p><strong>内容回顾：</strong></p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d125306e51d45773e418aab">《EFT 每周分享 —— Hybrid App 应用开发中 5 个必备知识点复习》</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d0de954e51d4556be5b3a6f">《EFT 每周分享 —— HTTP 的15个常见知识点复习》</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/collection/5cd11b0af265da0346227e24">《EFT 每周分享 —— 数据结构与算法合集》</a></p>
</li>
</ol>
<p><strong>文章收录：</strong> </p>
<p>本系列所有文章，都将收录在 Github 上，<a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo-EveryWeek">欢迎点击查阅</a>。   </p>
<blockquote>
<p>注：本文整理部分资料来源网络，有些图片/段落找不到原文出处，如有侵权，联系删除。</p>
</blockquote>
<h3 id="一、iOS-平台中-UIWebView-与-WKWebView-有什么区别？"><a href="#一、iOS-平台中-UIWebView-与-WKWebView-有什么区别？" class="headerlink" title="一、iOS 平台中 UIWebView 与 WKWebView 有什么区别？"></a>一、iOS 平台中 UIWebView 与 WKWebView 有什么区别？</h3><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="http://www.cocoachina.com/articles/17337">《UIWebView与WKWebView》</a></p>
</blockquote>
<p><code>UIWebView</code> 是苹果继承于 <code>UIView</code> 封装的一个加载 web 内容的类,它可以加载任何远端的web数据展示在你的页面上，你可以像浏览器一样前进后退刷新等操作。不过苹果在 iOS8 以后推出了 <code>WKWebView</code> 来加载 Web，并应用于 iOS 和 OSX 中，它取代了 <code>UIWebView</code> 和 <code>WebView</code> ，在两个平台上支持同一套 API。</p>
<p>它脱离于 <code>UIWebView</code> 的设计，将原本的设计拆分成14个类，和3个代理协议，虽然是这样但是了解之后其实用法比较简单，依照职责单一的原则，每个协议做的事情根据功能分类。</p>
<p><img src="http://cdn.cocimg.com/ueditor/upload/image/20160810/1470807807124957.png" alt="UIWebView"></p>
<p><code>WKWebView</code> 与 <code>UIWebView</code> 的区别：  </p>
<ul>
<li><p><code>WKWebView</code> 的内存远远没有 <code>UIWebView</code> 的开销大,而且没有缓存；</p>
</li>
<li><p><code>WKWebView</code> 拥有高达 60FPS 滚动刷新率及内置手势；</p>
</li>
<li><p><code>WKWebView</code> 支持了更多的 HTML5 特性；</p>
</li>
<li><p><code>WKWebView</code> 高效的 app 和 web 信息交换通道；</p>
</li>
<li><p><code>WKWebView</code> 允许 <code>JavaScript</code> 的 <code>Nitro</code> 库加载并使用, <code>UIWebView</code> 中限制了；</p>
</li>
<li><p><code>WKWebView</code> 目前缺少关于页码相关的 API；</p>
</li>
<li><p><code>WKWebView</code> 提供加载网页进度的属性；</p>
</li>
<li><p><code>WKWebView</code> 使用 Safari 相同的 JavaScript 引擎；  </p>
</li>
<li><p><code>WKWebView</code> 增加加载进度属性： <code>estimatedProgress</code> ；</p>
</li>
<li><p><code>WKWebView</code> 不支持页面缓存，需要自己注入 <code>cookie</code> , 而 <code>UIWebView</code> 是自动注入 <code>cookie</code> ；</p>
</li>
<li><p><code>WKWebView</code> 无法发送 <code>POST</code> 参数问题；</p>
</li>
<li><p><code>WKWebView</code> 可以和js直接互调函数，不像 <code>UIWebView</code> 需要第三方库 <code>WebViewJavascriptBridge</code> 来协助处理和 js 的交互；</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<p>大多数App需要支持 <code>iOS7</code> 以上的版本，而 <code>WKWebView</code> 只在 <code>iOS8</code> 后才能用，所以需要一个兼容性方案，既 <code>iOS7</code> 下用 <code>UIWebView</code> ，<code>iOS8</code> 后用 <code>WKWebView</code> 。但是目前 <code>IOS10</code> 以下的系统以及很少了，</p>
<p><strong>小结：</strong>   </p>
<p><code>WKWebView</code> 相较于 <code>UIWebView</code> 在整体上有较大的提升，满足 iOS 上面使用同一套控件的功能，同时对整个内存的开销以及滚动刷新率和 JS 交互做了优化的处理。</p>
<p>依据<strong>职责单一原则</strong>，拆分成了三个协议去实现 <code>WebView</code> 的响应，解耦了 JS 交互和加载进度的响应处理。 </p>
<p><code>WKWebView</code> 没有做缓存处理,所以<strong>对网页需要缓存的加载性能要求没那么高</strong>的还是可以考虑 <code>UIWebView</code> 。</p>
<h3 id="二、WKWebView-有哪一些坑？"><a href="#二、WKWebView-有哪一些坑？" class="headerlink" title="二、WKWebView 有哪一些坑？"></a>二、WKWebView 有哪一些坑？</h3><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://kknews.cc/tech/x2rzg3g.html">《WKWebView 那些坑》</a></p>
</blockquote>
<h4 id="1-WKWebView-白屏问题"><a href="#1-WKWebView-白屏问题" class="headerlink" title="1. WKWebView 白屏问题"></a>1. WKWebView 白屏问题</h4><p><code>WKWebView</code> 实际上是个多进程组件，这也是它加载速度更快，内存暂用更低的原因。</p>
<p>在 <code>UIWebView</code> 上当内存占用太大的时候，App Process 会 crash；而在 <code>WKWebView</code> 上当总体的内存占用比较大的时候，WebContent Process 会 crash，从而出现白屏现象。</p>
<p><strong>解决办法：</strong></p>
<ol>
<li><strong>借助 WKNavigtionDelegate</strong>  </li>
</ol>
<p>当 <code>WKWebView</code> 总体内存占用过大，页面即将白屏的时候，系统会调用上面的回调函数，我们在该函数里执行<code>[webView reload]</code>(这个时候 <code>webView.URL</code> 取值尚不为<code> nil</code>）解决白屏问题。在一些高内存消耗的页面可能会频繁刷新当前页面，H5侧也要做相应的适配操作。</p>
<ol start="2">
<li><strong>检测 webView.title 是否为空</strong></li>
</ol>
<p>并不是所有 H5 页面白屏的时候都会调用上面的回调函数，比如，最近遇到在一个高内存消耗的 H5 页面上 present 系统相机，拍照完毕后返回原来页面的时候出现白屏现象（拍照过程消耗了大量内存，导致内存紧张，WebContent Process 被系统挂起），但上面的回调函数并没有被调用。在 <code>WKWebView</code> 白屏的时候，另一种现象是 <code>webView.titile</code> 会被置空, 因此，可以在 <code>viewWillAppear</code> 的时候检测 <code>webView.title</code> 是否为空来 <code>reload</code> 页面。</p>
<h4 id="2-WKWebView-Cookie-问题"><a href="#2-WKWebView-Cookie-问题" class="headerlink" title="2. WKWebView Cookie 问题"></a>2. WKWebView Cookie 问题</h4><p><code>WKWebView</code> <code>Cookie</code> 问题在于 <code>WKWebView</code> 发起的请求不会自动带上存储于 <code>NSHTTPCookieStorage</code> 容器中的 <code>Cookie</code>，而在 <code>UIWebView</code> 会自动带上 <code>Cookie</code>。  </p>
<p><strong>原因是：</strong>   </p>
<p><code>WKWebView</code> 拥有自己的私有存储，不会将 <code>Cookie</code> 存入到标准的 <code>Cookie</code> 容器<code>NSHTTPCookieStorage</code> 中。</p>
<p>实践发现 <code>WKWebView</code> 实例其实也会将 <code>Cookie</code> 存储于 <code>NSHTTPCookieStorage</code> 中，但存储时机有延迟，在 <code>iOS 8 </code>上，当页面跳转的时候，当前页面的 <code>Cookie</code> 会写入 <code>NSHTTPCookieStorage</code> 中，而在 <code>iOS 10</code> 上，JS 执行 <code>document.cookie</code> 或服务器 <code>set-cookie</code> 注入的 <code>Cookie</code> 会很快同步到 <code>NSHTTPCookieStorage</code> 中，FireFox 工程师曾建议通过 <code>reset WKProcessPool</code> 来触发 <code>Cookie</code> 同步到 <code>NSHTTPCookieStorage</code> 中，实践发现不起作用，并可能会引发当前页面 <code>session cookie </code>丢失等问题。</p>
<p><strong>解决办法1：</strong>  </p>
<p><code>WKWebView loadRequest</code> 前，在 <code>request header</code> 中设置 <code>Cookie</code>, 解决首个请求 <code>Cookie</code> 带不上的问题；</p>
<p><strong>解决办法2：</strong>  </p>
<p>通过 <code>document.cookie</code> 设置 <code>Cookie</code> 解决后续页面(同域)<code>Ajax``、iframe</code> 请求的 <code>Cookie</code> 问题；(注意：<code>document.cookie()</code> 无法跨域设置 <code>cookie</code>)。</p>
<h4 id="3-WKWebView-loadRequest-问题"><a href="#3-WKWebView-loadRequest-问题" class="headerlink" title="3. WKWebView loadRequest 问题"></a>3. WKWebView loadRequest 问题</h4><p>在 <code>WKWebView</code> 上通过 <code>loadRequest</code> 发起的 <code>post</code> 请求 <code>body</code> 数据会丢失，同样是由于<strong>进程间通信性能问题</strong>， <code>HTTPBody</code> 字段被丢弃。</p>
<h4 id="4-WKWebView-NSURLProtocol问题"><a href="#4-WKWebView-NSURLProtocol问题" class="headerlink" title="4. WKWebView NSURLProtocol问题"></a>4. WKWebView NSURLProtocol问题</h4><p><code>WKWebView</code> 在独立于 app 进程之外的进程中执行网络请求，请求数据不经过主进程，因此，在 <code>WKWebView</code> 上直接使用 <code>NSURLProtocol</code> 无法拦截请求。</p>
<p><strong>解决办法：</strong>  </p>
<p>由于 <code>WKWebView</code> 在独立进程里执行网络请求。一旦注册 <code>http(s) scheme</code> 后，网络请求将从 <code>Network Process</code> 发送到 <code>App Process</code>，这样 <code>NSURLProtocol</code> 才能拦截网络请求。在 <code>webkit2</code> 的设计里使用 <code>MessageQueue</code> 进行进程之间的通信，Network Process 会将请求 <code>encode</code> 成一个 <code>Message</code>,然后通过 IPC 发送给<code> App Process</code>。出于性能的原因，<code>encode</code> 的时候 <code>HTTPBody</code> 和 <code>HTTPBodyStream</code> 这两个字段会被丢弃掉了。</p>
<h4 id="5-WKWebView-页面样式问题"><a href="#5-WKWebView-页面样式问题" class="headerlink" title="5. WKWebView 页面样式问题"></a>5. WKWebView 页面样式问题</h4><p>在 <code>WKWebView</code> 适配过程中，我们发现部分 H5 页面元素位置向下偏移或被拉伸变形，追踪后发现主要是 H5 页面高度值异常导致。</p>
<p><strong>解决办法：</strong>  </p>
<p>调整 <code>WKWebView</code> 布局方式，避免调整<code> webView.scrollView.contentInset</code> 。实际上，即便在  <code>UIWebView</code>  上也不建议直接调整 <code>webView.scrollView.contentInset</code> 的值，这确实会带来一些奇怪的问题。如果某些特殊情况下非得调整 <code>contentInset</code> 不可的话，可以通过下面方式让H5页面恢复正常显示。</p>
<h4 id="6-WKWebView-截屏问题"><a href="#6-WKWebView-截屏问题" class="headerlink" title="6. WKWebView 截屏问题"></a>6. WKWebView 截屏问题</h4><p>WKWebView 下通过 -[CALayer renderInContext:]实现截屏的方式失效，需要通过以下方式实现截屏功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIView (ImageSnapshot) </span><br><span class="line">- (UIImage*)imageSnapshot &#123; </span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(self.bounds.size,YES,self.contentScaleFactor);</span><br><span class="line">    [self drawViewHierarchyInRect:self.bounds afterScreenUpdates:YES]; </span><br><span class="line">    UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext(); </span><br><span class="line">    UIGraphicsEndImageContext(); </span><br><span class="line">    return newImage; </span><br><span class="line">&#125; </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>然而这种方式依然解决不了 <code>webGL</code> 页面的截屏问题，截屏结果不是空白就是纯黑图片。  </p>
<p><strong>解决办法：</strong>  </p>
<p>无奈之下，我们只能约定一个JS接口，让游戏开发商实现该接口，具体是通过 <code>canvas</code> <code>getImageData()</code>方法取得图片数据后返回 <code>base64</code> 格式的数据，客户端在需要截图的时候，调用这个JS接口获取<code>base64 String</code>并转换成 <code>UIImage</code>。</p>
<h4 id="7-WKWebView-crash问题"><a href="#7-WKWebView-crash问题" class="headerlink" title="7. WKWebView crash问题"></a>7. WKWebView crash问题</h4><p>如果 <code>WKWebView</code> 退出的时候，JS刚好执行了 <code>window.alert()</code>,  alert 框可能弹不出来，<code>completionHandler</code> 最后没有被执行，导致<code> crash</code>；</p>
<p>另一种情况是在 <code>WKWebView</code> 一打开，JS就执行 <code>window.alert()</code>，这个时候由于 <code>WKWebView</code> 所在的 <code>UIViewController</code> 出现（ <code>push</code> 或 <code>present</code> ）的动画尚未结束，alert 框可能弹不出来，<code>completionHandler </code>最后没有被执行，导致 <code>crash</code>。   </p>
<h4 id="8-视频自动播放"><a href="#8-视频自动播放" class="headerlink" title="8. 视频自动播放"></a>8. 视频自动播放</h4><p><code>WKWebView</code> 需要通过 <code>WKWebViewConfiguration.mediaPlaybackRequiresUserAction</code> 设置是否允许自动播放，但一定要在 <code>WKWebView</code> 初始化之前设置，在 <code>WKWebView</code> 初始化之后设置无效。</p>
<h4 id="9-goBack-API问题"><a href="#9-goBack-API问题" class="headerlink" title="9. goBack API问题"></a>9. goBack API问题</h4><p><code>WKWebView</code> 上调用 <code>-[WKWebView goBack]</code>, 回退到上一个页面后不会触发<code>window.onload()</code> 函数、不会执行JS。</p>
<h4 id="10-页面滚动速率"><a href="#10-页面滚动速率" class="headerlink" title="10. 页面滚动速率"></a>10. 页面滚动速率</h4><p><code>WKWebView</code> 需要通过 <code>scrollView delegate</code> 调整滚动速率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView &#123;</span><br><span class="line">    scrollView.decelerationRate = UIScrollViewDecelerationRateNormal; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、Crosswalk-是什么，它有什么作用？"><a href="#三、Crosswalk-是什么，它有什么作用？" class="headerlink" title="三、Crosswalk 是什么，它有什么作用？"></a>三、Crosswalk 是什么，它有什么作用？</h3><blockquote>
<p>参考网站： <a target="_blank" rel="noopener" href="https://crosswalk-project.org/">《Crosswalk Github》</a><br>参考文章： <a target="_blank" rel="noopener" href="https://www.mobibrw.com/2015/1934">《Crosswalk入门》</a></p>
</blockquote>
<p><strong>Crosswalk</strong> 是一款开源的 web 引擎。目前 <strong>Crosswalk</strong> 正式支持的移动操作系统包括 Android 和 Tizen ，在 Android 4.0 及以上的系统中使用 <strong>Crosswalk</strong> 的 Web 应用程序在 HTML5 方面可以有一致的体验，<strong>同时和系统的整合交互方面（比如启动画面、权限管理、应用切换、社交分享等等）可以做到类似原生应用</strong>。</p>
<p>现在 <strong>Crosswalk</strong> 已经成为众多知名 HTML5 平台和应用的推荐引擎，包括 Google Mobile Chrome App 、 Intel XDK 、 Famo.us 和 Construct2 等等，未来的 Cordova 4.0 也计划集成 <strong>Crosswalk</strong> 。</p>
<h3 id="四、常见的-WebView-性能优化方案有哪一些？"><a href="#四、常见的-WebView-性能优化方案有哪一些？" class="headerlink" title="四、常见的 WebView 性能优化方案有哪一些？"></a>四、常见的 WebView 性能优化方案有哪一些？</h3><h4 id="0-问题分析"><a href="#0-问题分析" class="headerlink" title="0. 问题分析"></a>0. 问题分析</h4><p>首先需要了解，对于一个普通用户来讲，打开一个 WebView 通常会经历哪几个阶段，一般有这些：</p>
<ol>
<li><p>交互无反馈;</p>
</li>
<li><p>到达新的页面，页面白屏;</p>
</li>
<li><p>页面基本框架出现，但是没有数据；页面处于loading状态;</p>
</li>
<li><p>出现所需的数据;</p>
</li>
</ol>
<p><img src="http://images.pingan8787.com/20190712Hybrid01.jpeg" alt="webview1">   </p>
<p>当 App 首次打开时，默认是并不初始化浏览器内核的；只有当创建 <code>WebView</code> 实例的时候，才会创建 <code>WebView</code> 的基础框架。</p>
<p>所以与浏览器不同，App 中打开 <code>WebView</code> 的第一步并不是建立连接，而是启动浏览器内核。</p>
<p>于是我们找到了“<strong>为什么WebView总是很慢</strong>”的原因之一：</p>
<ul>
<li><p>在浏览器中，我们输入地址时（甚至在之前），浏览器就可以开始加载页面。</p>
</li>
<li><p>而在客户端中，客户端需要先花费时间初始化 <code>WebView</code> 完成后，才开始加载。</p>
</li>
</ul>
<p>而这段时间，由于WebView还不存在，所有后续的过程是完全阻塞的。因此由于这段过程发生在 native 的代码中，单纯靠前端代码是无法优化的；大部分的方案都是前端和客户端协作完成，以下是几个业界采用过的方案：   </p>
<h4 id="1-全局-WebView"><a href="#1-全局-WebView" class="headerlink" title="1. 全局 WebView"></a>1. 全局 WebView</h4><p>在客户端刚启动时，就初始化一个全局的 <code>WebView</code> 待用，并隐藏，当用户访问了 <code>WebView</code> 时，直接使用这个 <code>WebView</code> 加载对应网页，并展示。</p>
<p>这种方法可以<strong>比较有效的减少 WebView 在App中的首次打开时间</strong>。当用户访问页面时，不需要初始化 WebView 的时间。</p>
<p>当然这也带来了一些问题，包括：</p>
<ul>
<li><p>额外的内存消耗。</p>
</li>
<li><p>页面间跳转需要清空上一个页面的痕迹，更容易内存泄露。</p>
</li>
</ul>
<h4 id="2-WebView-动态加载"><a href="#2-WebView-动态加载" class="headerlink" title="2. WebView 动态加载"></a>2. WebView 动态加载</h4><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f64e1b1c90d9">《WebView常用优化方案》</a></p>
</blockquote>
<p><code>WebView</code> 动态加载。就是不在 <code>xml</code> 中写 <code>WebView</code> ，写一个 <code>layout</code> ，然后把 <code>WebView</code> add 进去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WebView mWebView = <span class="keyword">new</span> WebView(getApplicationgContext());</span><br><span class="line">LinearLayout mll = findViewById(R.id.xxx);</span><br><span class="line">mll.addView(mWebView);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    mWebView.removeAllViews();</span><br><span class="line">    mWebView.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用的 <code>getApplicationContext()</code> 也是防止内存溢出，这种方法有一个问题。如果你需要在 <code>WebView</code> 中打开链接或者你打开的页面带有 flash，获得你的 <code>WebView</code> 想弹出一个 <code>dialog</code> ，都会导致从 <code>ApplicationContext</code> 到 <code>ActivityContext</code> 的强制类型转换错误，从而导致你应用崩溃。</p>
<p>这是因为在加载 flash 的时候，系统会首先把你的 <code>WebView</code> 作为父控件，然后在该控件上绘制 flash ，他想找一个 <code>Activity</code> 的 <code>Context</code> 来绘制他，但是你传入的是 <code>ApplicationContext</code> 。然后就崩溃了。</p>
<h4 id="3-独立的web进程，与主进程隔开"><a href="#3-独立的web进程，与主进程隔开" class="headerlink" title="3. 独立的web进程，与主进程隔开"></a>3. 独立的web进程，与主进程隔开</h4><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f64e1b1c90d9">《WebView常用优化方案》</a></p>
</blockquote>
<p>这个方法被运用于类似 qq ，微信这样的超级 app 中，这也是解决任何 <code>WebView</code> 内存问题屡试不爽的方法 对于封装的 <code>webactivity</code> ，在<code> manifest.xml</code> 中设置。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.webview.WebViewActivity&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTop&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">&quot;:remote&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;unspecified&quot;</span> </span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在关闭 <code>webactivity</code> 时销毁进程：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overrideprotected</span> <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;                </span><br><span class="line"><span class="keyword">super</span>.onDestroy(); </span><br><span class="line">    System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭浏览器后便销毁整个进程，这样一般 95% 的情况下不会造成内存泄漏之类的问题，但这就涉及到 android 进程间通讯，比较不方便处理，优劣参半，也是可选的一个方案。   </p>
<h4 id="4-WebView-释放"><a href="#4-WebView-释放" class="headerlink" title="4. WebView 释放"></a>4. WebView 释放</h4><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f64e1b1c90d9">《WebView常用优化方案》</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWebView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果先调用destroy()方法，则会命中if (isDestroyed()) return;这一行代码，需要先onDetachedFromWindow()，再</span></span><br><span class="line">        <span class="comment">// destory()</span></span><br><span class="line">        ViewParent parent = mWebView.getParent();</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ((ViewGroup) parent).removeView(mWebView);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        mWebView.stopLoading();</span><br><span class="line">        <span class="comment">// 退出时调用此方法，移除绑定的服务，否则某些特定系统会报错</span></span><br><span class="line">        mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">false</span>);</span><br><span class="line">        mWebView.clearHistory();</span><br><span class="line">        mWebView.clearView();</span><br><span class="line">        mWebView.removeAllViews();</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mWebView.destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">​</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、在-Android-平台下如何调试-WebView？"><a href="#五、在-Android-平台下如何调试-WebView？" class="headerlink" title="五、在 Android 平台下如何调试 WebView？"></a>五、在 Android 平台下如何调试 WebView？</h3><h4 id="1-在-Chrome-浏览器上调试"><a href="#1-在-Chrome-浏览器上调试" class="headerlink" title="1. 在 Chrome 浏览器上调试"></a>1. 在 Chrome 浏览器上调试</h4><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3591eebbe797">《Android调试webview》</a>     </p>
</blockquote>
<p><strong>1.1 条件：</strong>   </p>
<ul>
<li><p>在 Android 设备或模拟器运行 Android4.4 或更高版本，Android 设备上启用 <strong>USB调试模式</strong>。</p>
</li>
<li><p>Chrome 30 或更高版本。更强大的 WebView 界面调试功能需要 Chrome31 或更高版本。</p>
</li>
<li><p>Android 应用程序中的 WebView 配置为<strong>可调试模式</strong>。</p>
</li>
</ul>
<p><strong>1.2 Android 代码中配置 WebView 为可调试：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;  </span><br><span class="line">    WebView.setWebContentsDebuggingEnabled(<span class="keyword">true</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>注意 web 调测不受 <code>app manifest</code> 文件中 <code>debuggable</code> 标记状态的影响，如果希望仅 <code>debuggable</code> 为 <code>true</code> 时才能使用 web 调测，那么运行时检测此标记，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;  </span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">0</span> != ( getApplcationInfo().flags &amp;= ApplicationInfo.FLAG_DEBUGGABLE ) ) &#123;  </span><br><span class="line">        WebView.setWebContentsDebuggingEnabled(<span class="keyword">true</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>1.3 手机开启 USB 调试选项，并用 USB 连接电脑：</strong>   </p>
<p>开启 Android 手机的开发者选项，一般在 <strong>系统设置</strong> - <strong>Android版本</strong> 进行多次点击会触发开启开发者选项，然后进入开发者选项页面，开启USB调试。</p>
<p>为了避免每次调试时看到此警告，勾选“<strong>总是允许从这台计算机</strong>”，并单击“<strong>确定</strong>”。</p>
<p><strong>1.4 在 Chrome 中启用设置“USB web debugging”（不会影响WebView）：</strong>  </p>
<p>在 Chrome 上访问 <code>chrome://inspect/#devices</code> 或 <code>about:inspect</code> 访问已启用调试的 WebView 列表，<strong>需要翻墙</strong>。</p>
<p>然后在 WebView 列表中选择你要调试的页面，点击“ <code>Inspect</code> ”选项，跟调试 PC 网页一样，使用 Chrome 控制台进行调试。   </p>
<p><img src="http://images.pingan8787.com/20190707hybrid01.png" alt="Chrome 控制台"></p>
<p><img src="http://images.pingan8787.com/20190707hybrid02.png" alt="Chrome 控制台"></p>
<p><strong>1.5 小技巧：</strong>   </p>
<p>（1）访问 <code>chrome://inspect/#devices</code> 如果 chrome 没有检测到 <code>Remote Target</code> 中的页面，可能需要安装一下 Chrome 的 ADB 插件，也可以在 Chrome 翻墙访问 <code>https://chrome-devtools-frontend.appspot.com</code>；</p>
<p>（2）对于腾讯系的 APP，默认采用 X5内核 ，需要将 <code>WebViewDebugHook</code> 的 git 目录下的 <code>debug.conf</code> 文件拷贝到 SD卡 的根目录下即可。</p>
<h4 id="2-使用-DebugGap-调试"><a href="#2-使用-DebugGap-调试" class="headerlink" title="2. 使用 DebugGap 调试"></a>2. 使用 DebugGap 调试</h4><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009240637">《Android下的webview调试》</a></p>
</blockquote>
<p><strong>2.1 Windows 下载 DebugGap 并配置：</strong>   </p>
<p>在电脑上面下载 Windows 版本的 <code>DebugGap</code> 软件包（下载链接：<a target="_blank" rel="noopener" href="http://www.debuggap.com/">DebugGap</a>），下载完成后解压下来。</p>
<p>安装完成后，运行 <code>DebugGap</code> ，开始配置：</p>
<ul>
<li>通常情况下，<code>DebugGap</code> 可以自动获取IP，并设置默认的端口，如果没有，你可以手动设置；</li>
<li>点击“<strong>连接</strong>”按钮启动各种客户端的侦听器；</li>
</ul>
<p><img src="http://images.pingan8787.com/20190707hybrid03.png" alt="DebugGap"></p>
<p><strong>2.2 在客户端上配置：</strong></p>
<p>在调试项目中要进行测试的 HTML 界面中引入 <code>debuggap.js</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;debuggap.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当调试项目的加载时，您的应用程序将会有一个蓝色的地方，点击会出现一个四叶三叶草的东西，点击“<strong>配置</strong>”，显示配置页面。输入与远程 DebugGap 上的主机和端口相同的主机和端口，例如 <code>192.168.1.4:11111</code>，然后点击“<strong>连接</strong>”按钮。</p>
<p><img src="http://images.pingan8787.com/20190707hybrid04.png" alt="DebugGap"></p>
<p>1.4电脑端远程 DebugGap 将检测即将到来的客户端，开发人员可以单击每个客户端进行调试。</p>
<p><img src="http://images.pingan8787.com/20190707hybrid05.png" alt="DebugGap"></p>
<h3 id="六、在-iOS-平台下如何调试-WebView？"><a href="#六、在-iOS-平台下如何调试-WebView？" class="headerlink" title="六、在 iOS 平台下如何调试 WebView？"></a>六、在 iOS 平台下如何调试 WebView？</h3><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dianming/p/6902442.html">《iOS之Safari调试webView/H5页面》</a></p>
</blockquote>
<p>一般我们通过 Mac 的 Safari浏览器 来调试，但是要注意两点：</p>
<ul>
<li><p>如果调试的是 APP 中 WebView 的页面，则需要这个 APP 的包支持调试，如果不能调试，需要让 iOS 开发人员重签名 APP（可能需要将我们 iOS 设备的 ID 写入到可信任设备列表中，然后使用 iTunes 安装客户端提供的测试包即可）。</p>
</li>
<li><p>如果调试的是 H5 页面，可以直接在手机的 Safari浏览器 打开直接调试。   </p>
</li>
</ul>
<p>下面开始说说在 Mac 上如何调试：   </p>
<h4 id="1-开启-Safari-开发菜单"><a href="#1-开启-Safari-开发菜单" class="headerlink" title="1. 开启 Safari 开发菜单"></a>1. 开启 Safari 开发菜单</h4><p>先将 iPhone 连接到 Mac，在 Mac 的 Safari 偏好设置中，开启开发菜单。具体步骤为：Safari -&gt; 偏好设置… -&gt; 高级 -&gt; 勾选在菜单栏显示“<strong>开发</strong>”菜单。</p>
<p><img src="http://images.pingan8787.com/20190707hybrid06.jpg" alt="Safari"></p>
<h4 id="2-iPhone-开启-Web检查器"><a href="#2-iPhone-开启-Web检查器" class="headerlink" title="2. iPhone 开启 Web检查器"></a>2. iPhone 开启 Web检查器</h4><p>具体步骤为：设置 -&gt; Safari -&gt; 高级 -&gt; Web 检查器。</p>
<p><img src="http://images.pingan8787.com/20190707hybrid07.jpg" alt="Safari"></p>
<h4 id="3-调试-APP-内的-WebView"><a href="#3-调试-APP-内的-WebView" class="headerlink" title="3. 调试 APP 内的 WebView"></a>3. 调试 APP 内的 WebView</h4><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://imnerd.org/ios-webview-debug.html">《前端 WEBVIEW 指南之 IOS 调试篇》</a></p>
</blockquote>
<p>在 Safari-&gt; 开发中，看到自己的设备以及 WebView 中网页，点击后即可开启对应页面的 <code>Inspector</code> ，可以用来进行断点调试。   </p>
<p><img src="http://images.pingan8787.com/20190707hybrid09.png" alt="Safari"></p>
<p><img src="http://images.pingan8787.com/20190707hybrid10.png" alt="Safari"></p>
<h3 id="七、在内嵌版调试过程中，Fiddler-或-Charles-能起到什么作用？"><a href="#七、在内嵌版调试过程中，Fiddler-或-Charles-能起到什么作用？" class="headerlink" title="七、在内嵌版调试过程中，Fiddler 或 Charles 能起到什么作用？"></a>七、在内嵌版调试过程中，Fiddler 或 Charles 能起到什么作用？</h3><p>这两者都是强大的抓包工具，原理是以<strong>web代理服务器</strong>的形式进行工作的，使用的代理地址是：<code>127.0.0.1</code>，端口默认为<code>8888</code>，我们也可以通过设置进行修改。</p>
<p><strong>代理</strong>就是在客户端和服务器之间设置一道关卡，客户端先将请求数据发送出去后，代理服务器会将数据包进行拦截，代理服务器再冒充客户端发送数据到服务器；同理，服务器将响应数据返回，代理服务器也会将数据拦截，再返回给客户端。</p>
<p>Fiddler 或 Charles 的主要作用有：   </p>
<ul>
<li>可以代理请求，用来查看页面发送的请求和接收的响应；</li>
<li>可以修改请求的响应，用来模拟自己想要的数据；</li>
<li>可以模拟网络请求的速度；</li>
<li>可以代理服务器的静态资源请求，指向本地文件，省去频繁发布 H5 包，达到快速调试目的；</li>
</ul>
<blockquote>
<p>补充链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/miantest/p/7289694.html">《Fiddler工具使用介绍一》</a></p>
</blockquote>
<h3 id="八、调试企业微信、微信和钉钉版时，可以使用哪些工具？"><a href="#八、调试企业微信、微信和钉钉版时，可以使用哪些工具？" class="headerlink" title="八、调试企业微信、微信和钉钉版时，可以使用哪些工具？"></a>八、调试企业微信、微信和钉钉版时，可以使用哪些工具？</h3><h4 id="1-调试企业微信、微信"><a href="#1-调试企业微信、微信" class="headerlink" title="1. 调试企业微信、微信"></a>1. 调试企业微信、微信</h4><ul>
<li>**<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">微信开发者工具</a>**，可以用来调试页面基本功能；</li>
<li>**<a target="_blank" rel="noopener" href="https://work.weixin.qq.com/api/devtools/devtool.php">企业微信接口调试工具</a>**，可以用来调试企业微信的接口；</li>
</ul>
<h4 id="2-调试钉钉"><a href="#2-调试钉钉" class="headerlink" title="2. 调试钉钉"></a>2. 调试钉钉</h4><ul>
<li>**<a target="_blank" rel="noopener" href="https://files.alicdn.com/tpsservice/76ac853fc96075414a837d8bbae89030.pdf">钉钉Android开发版</a>**，用来调试Android上的钉钉应用；</li>
</ul>
<h4 id="3-通用"><a href="#3-通用" class="headerlink" title="3. 通用"></a>3. 通用</h4><ul>
<li><strong>Fiddler 或 Charles</strong>，可以拦截接口替换文件，来调试应用；</li>
</ul>
<h3 id="九、常见的调试技巧有哪些？"><a href="#九、常见的调试技巧有哪些？" class="headerlink" title="九、常见的调试技巧有哪些？"></a>九、常见的调试技巧有哪些？</h3><h4 id="1-Chrome-控制台调试"><a href="#1-Chrome-控制台调试" class="headerlink" title="1. Chrome 控制台调试"></a>1. Chrome 控制台调试</h4><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenbeibei520/p/9959555.html">《前端常见调试技巧篇总结（持续更新…）》</a></p>
</blockquote>
<p><strong>1.1 Source 面板断点调试 JS</strong><br>从左到右，各个图标表示的功能分别为：</p>
<ul>
<li><code>Pause/Resume script execution</code>：暂停/恢复脚本执行（程序执行到下一断点停止）。</li>
<li><code>Step over next function call</code>：执行到下一步的函数调用（跳到下一行）。</li>
<li><code>Step into next function call</code>：进入当前函数。</li>
<li><code>Step out of current function</code>：跳出当前执行函数。</li>
<li><code>Deactive/Active all breakpoints</code>：关闭/开启所有断点（不会取消）。</li>
<li><code>Pause on exceptions</code>：异常情况自动断点设置。</li>
</ul>
<p><strong>1.2 Element 面板调试 DOM：</strong>   </p>
<p>右击元素，选择 <code>break on</code> 选项：  </p>
<p><img src="http://images.pingan8787.com/20190707hybrid14.png" alt="break on"></p>
<ul>
<li><code>Subtree modifications</code> 选项，是指<strong>当节点内部子节点变化时断点</strong>；    </li>
</ul>
<p><img src="http://images.pingan8787.com/20190707hybrid11.gif" alt="break on"></p>
<ul>
<li><code>Attributes modifications</code> 选项，是指<strong>当节点属性发生变化时断点</strong>；   </li>
</ul>
<p><img src="http://images.pingan8787.com/20190707hybrid12.gif" alt="break on"></p>
<ul>
<li><code>node removal</code> 选项，是指<strong>当节点被移除时断点</strong>；   </li>
</ul>
<p><img src="http://images.pingan8787.com/20190707hybrid13.png" alt="break on"></p>
<h4 id="2-console-调试"><a href="#2-console-调试" class="headerlink" title="2. console 调试"></a>2. console 调试</h4><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a0405221/article/details/85248433">《Console调试常用用法》</a></p>
</blockquote>
<p><strong>2.1 显示信息的命令：</strong> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;normal&quot;</span>);         <span class="comment">// 用于输出普通信息</span></span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">&quot;information&quot;</span>);   <span class="comment">// 用于输出提示性信息</span></span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">&quot;error&quot;</span>);        <span class="comment">// 用于输出错误信息</span></span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">&quot;warn&quot;</span>);          <span class="comment">// 用于输出警示信息</span></span><br><span class="line"><span class="built_in">console</span>.clear();               <span class="comment">// 清空控制台信息</span></span><br></pre></td></tr></table></figure>

<p><strong>2.2 计时功能：</strong>   </p>
<p><code>console.time()</code> 和 <code>console.timeEnd()</code> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;控制台计时器&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++)&#123;&#125;       </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&quot;控制台计时器&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>2.3 信息分组：</strong>   </p>
<p><code>console.group()</code> 和 <code>console.groupEnd()</code>：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.group(<span class="string">&quot;第一组信息&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第一组第一条：我的博客&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第一组第二条：CSDN&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.group(<span class="string">&quot;第二组信息&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第二组第一条：程序爱好者QQ群&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第二组第二条：欢迎你加入&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br></pre></td></tr></table></figure>

<p><strong>2.4 将对象以树状结构展现：</strong>   </p>
<p><code>console.dir()</code> 可以显示一个对象所有的属性和方法：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> info = &#123;</span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;Alan&quot;</span>,</span><br><span class="line">    <span class="attr">age</span> : <span class="string">&quot;27&quot;</span>,</span><br><span class="line">    <span class="attr">grilFriend</span> : <span class="string">&quot;nothing&quot;</span>,</span><br><span class="line">    <span class="attr">getName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.dir(info);</span><br></pre></td></tr></table></figure>

<p><strong>2.5 显示某个节点的内容：</strong>   </p>
<p><code>console.dirxml()</code> 用来显示网页的某个节点( <code>node</code>) 所包含的 <code>html/xml</code> 代码：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">node.innerHTML += <span class="string">&quot;&lt;p&gt;追加的元素显示吗&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.dirxml(node);</span><br></pre></td></tr></table></figure>

<p><strong>2.5 统计代码被执行的次数：</strong>  </p>
<p>使用 <code>console.count()</code>：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.count(<span class="string">&quot;myFunction 被执行的次数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">myFunction();       <span class="comment">//myFunction 被执行的次数: 1</span></span><br><span class="line">myFunction();       <span class="comment">//myFunction 被执行的次数: 2</span></span><br><span class="line">myFunction();       <span class="comment">//myFunction 被执行的次数: 3</span></span><br></pre></td></tr></table></figure>

<p><strong>2.6 输出表格：</strong>   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.table(mytable);</span><br></pre></td></tr></table></figure>

<h4 id="3-调试各种页面尺寸"><a href="#3-调试各种页面尺寸" class="headerlink" title="3. 调试各种页面尺寸"></a>3. 调试各种页面尺寸</h4><p>虽然把各种各样的手机都摆在桌子上看起来很酷，但却很不现实。但是，浏览器内却提供了你所需要的一切。进入检查面板点击“<strong>切换设备模式</strong>”按钮。这样，就可以在窗口内调整视窗的大小。</p>
<h4 id="4-debugger-断点"><a href="#4-debugger-断点" class="headerlink" title="4. debugger 断点"></a>4. debugger 断点</h4><p>具体的说就是通过在代码中添加” <code>debugger; </code>“语句，当代码执行到该语句的时候就会自动断点。  </p>
<p><img src="http://images.pingan8787.com/20190712Hybrid02.gif" alt="debugger"></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>对于初入混合应用开发的小伙伴，还有经常需要调试混合应用的小伙伴，相信会有帮助😁</p>
<p>大家加油~</p>
<h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><blockquote>
<p>本文首发在 <a target="_blank" rel="noopener" href="http://www.pingan8787.com/">pingan8787个人博客</a>，如需转载请保留个人介绍。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Author</th>
<th>王平安</th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td><a href="mailto:&#x70;&#105;&#x6e;&#103;&#97;&#x6e;&#56;&#x37;&#56;&#x37;&#64;&#113;&#113;&#46;&#x63;&#x6f;&#109;">&#x70;&#105;&#x6e;&#103;&#97;&#x6e;&#56;&#x37;&#56;&#x37;&#64;&#113;&#113;&#46;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>博  客</td>
<td><a target="_blank" rel="noopener" href="http://www.pingan8787.com/">www.pingan8787.com</a></td>
</tr>
<tr>
<td>微  信</td>
<td>pingan8787</td>
</tr>
<tr>
<td>每日文章推荐</td>
<td><a target="_blank" rel="noopener" href="https://github.com/pingan8787/Leo_Reading/issues">https://github.com/pingan8787/Leo_Reading/issues</a></td>
</tr>
<tr>
<td>ES小册</td>
<td>js.pingan8787.com</td>
</tr>
</tbody></table>
<h3 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h3><p><img src="http://images.pingan8787.com/2019_07_12guild_page.png" alt="bg">  </p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-07-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/前端开发/" title="前端开发">前端开发 </a><a class="tag" href="/tags/原创/" title="原创">原创 </a><a class="tag" href="/tags/HTTP/" title="HTTP">HTTP </a><a class="tag" href="/tags/Hybrid/" title="Hybrid">Hybrid </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://pingan8787.github.io/2019/07/13/166-【Hybrid】HybirdApp应用开发中9个必备知识点复习（WebView-调试等）/,pingan8787,166-【Hybrid】HybirdApp应用开发中9个必备知识点复习（WebView/调试等）,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/07/18/167-%E3%80%90Webpack%E3%80%91Webpack%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C/" title="167-【Webpack】Webpack怎么运行">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/06/26/165-%E3%80%90Hybrid%E3%80%91HybridApp%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%AD5%E4%B8%AA%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/" title="165-【Hybrid】HybridApp应用开发中5个必备知识点复习">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>